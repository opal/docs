<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>glob.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            glob.js
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/glob/glob.js</li>
            <li>Last modified: 2015-08-19 03:18:33 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>// Approach: // // 1. Get the minimatch set // 2. For each pattern in the
set, PROCESS(pattern, false) // 3. Store matches per-set, then uniq them //
// PROCESS(pattern, inGlobStar) // Get the first [n] items from pattern
that are all strings // Join these together.  This is PREFIX. //   If there
is no more remaining, then stat(PREFIX) and //   add to matches if it
succeeds.  END. // // If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = [] // else readdir(PREFIX) as ENTRIES //   If fail, END
// // with ENTRIES //   If <a href="n">pattern</a> is GLOBSTAR //     //
handle the case where the globstar match is empty //     // by pruning it
out, and testing the resulting pattern //     <a
href="0..n">PROCESS(pattern</a> + pattern[n+1 .. $], false) //     //
handle other <a
href="node_modules/minimatch/node_modules/brace-expansion/test/cases_txt.html">cases</a>.
//     for ENTRY in ENTRIES (not dotfiles) //       // attach globstar +
tail onto the entry //       // Mark that this entry is a globstar match //
<a href="0..n">PROCESS(pattern</a> + ENTRY + pattern[n .. $], true) // //  
else // not globstar //     for ENTRY in ENTRIES (not dotfiles, unless <a
href="n">pattern</a> is dot) //       <a
href="../../../../../../classes/Test.html">Test</a> ENTRY against <a
href="n">pattern</a> //       If fails, continue //       If passes, <a
href="0..n">PROCESS(pattern</a> + item + pattern[n+1 .. $]) // // Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,â€¦] for directories, or `false` for // 
things that don&#39;t exist.</p>

<p>module.exports = glob</p>

<p>var fs = require(&#39;fs&#39;) var minimatch = require(&#39;minimatch&#39;)
var Minimatch = minimatch.Minimatch var inherits =
require(&#39;inherits&#39;) var EE = require(&#39;events&#39;).EventEmitter
var path = require(&#39;path&#39;) var assert = require(&#39;assert&#39;)
var globSync = require(&#39;./sync.js&#39;) var common =
require(&#39;./common.js&#39;) var alphasort = common.alphasort var
alphasorti = common.alphasorti var isAbsolute = common.isAbsolute var
setopts = common.setopts var ownProp = common.ownProp var inflight =
require(&#39;inflight&#39;) var util = require(&#39;util&#39;)</p>

<p>var once = require(&#39;once&#39;)</p>

<p>function glob (pattern, options, cb) {</p>

<pre><code>if (typeof options === &#39;function&#39;) cb = options, options = {}
if (!options) options = {}

if (options.sync) {
  if (cb)
    throw new TypeError(&#39;callback provided to sync glob&#39;)
  return globSync(pattern, options)
}

return new Glob(pattern, options, cb)</code></pre>

<p>}</p>

<p>glob.sync = globSync var GlobSync = glob.GlobSync = globSync.GlobSync</p>

<p>// old api surface glob.glob = glob</p>

<p>glob.hasMagic = function (pattern, options_) {</p>

<pre><code>var options = util._extend({}, options_)
options.noprocess = true

var g = new Glob(pattern, options)
var set = g.minimatch.set
if (set.length &gt; 1)
  return true

for (var j = 0; j &lt; set[0].length; j++) {
  if (typeof set[0][j] !== &#39;string&#39;)
    return true
}

return false</code></pre>

<p>}</p>

<p>glob.Glob = Glob inherits(Glob, EE) function Glob (pattern, options, cb) {</p>

<pre><code>if (typeof options === &#39;function&#39;) {
  cb = options
  options = null
}

if (options &amp;&amp; options.sync) {
  if (cb)
    throw new TypeError(&#39;callback provided to sync glob&#39;)
  return new GlobSync(pattern, options)
}

if (!(this instanceof Glob))
  return new Glob(pattern, options, cb)

setopts(this, pattern, options)

// process each pattern in the minimatch set
var n = this.minimatch.set.length

// The matches are stored as {&lt;filename&gt;: true,...} so that
// duplicates are automagically pruned.
// Later, we do an Object.keys() on these.
// Keep them as a list so we can fill in when nonull is set.
this.matches = new Array(n)

if (typeof cb === &#39;function&#39;) {
  cb = once(cb)
  this.on(&#39;error&#39;, cb)
  this.on(&#39;end&#39;, function (matches) {
    cb(null, matches)
  })
}

var self = this
var n = this.minimatch.set.length
this._processing = 0
this.matches = new Array(n)

this._emitQueue = []
this._processQueue = []
this.paused = false

if (this.noprocess)
  return this

if (n === 0)
  return done()

for (var i = 0; i &lt; n; i ++) {
  this._process(this.minimatch.set[i], i, false, done)
}

function done () {
  --self._processing
  if (self._processing &lt;= 0)
    self._finish()
}</code></pre>

<p>}</p>

<p>Glob.prototype._finish = function () {</p>

<pre><code>assert(this instanceof Glob)
if (this.aborted)
  return

//console.error(&#39;FINISH&#39;, this.matches)
common.finish(this)
this.emit(&#39;end&#39;, this.found)</code></pre>

<p>}</p>

<p>Glob.prototype._mark = function (p) {</p>

<pre><code>return common.mark(this, p)
</code></pre>

<p>}</p>

<p>Glob.prototype._makeAbs = function (f) {</p>

<pre><code>return common.makeAbs(this, f)
</code></pre>

<p>}</p>

<p>Glob.prototype.abort = function () {</p>

<pre><code>this.aborted = true
this.emit(&#39;abort&#39;)
</code></pre>

<p>}</p>

<p>Glob.prototype.pause = function () {</p>

<pre><code>if (!this.paused) {
  this.paused = true
  this.emit(&#39;pause&#39;)
}</code></pre>

<p>}</p>

<p>Glob.prototype.resume = function () {</p>

<pre><code>if (this.paused) {
  this.emit(&#39;resume&#39;)
  this.paused = false
  if (this._emitQueue.length) {
    var eq = this._emitQueue.slice(0)
    this._emitQueue.length = 0
    for (var i = 0; i &lt; eq.length; i ++) {
      var e = eq[i]
      this._emitMatch(e[0], e[1])
    }
  }
  if (this._processQueue.length) {
    var pq = this._processQueue.slice(0)
    this._processQueue.length = 0
    for (var i = 0; i &lt; pq.length; i ++) {
      var p = pq[i]
      this._processing--
      this._process(p[0], p[1], p[2], p[3])
    }
  }
}</code></pre>

<p>}</p>

<p>Glob.prototype._process = function (pattern, index, inGlobStar, cb) {</p>

<pre><code>assert(this instanceof Glob)
assert(typeof cb === &#39;function&#39;)

if (this.aborted)
  return

this._processing++
if (this.paused) {
  this._processQueue.push([pattern, index, inGlobStar, cb])
  return
}

//console.error(&#39;PROCESS %d&#39;, this._processing, pattern)

// Get the first [n] parts of pattern that are all strings.
var n = 0
while (typeof pattern[n] === &#39;string&#39;) {
  n ++
}
// now n is the index of the first one that is *not* a string.

// see if there&#39;s anything else
var prefix
switch (n) {
  // if not, then this is rather simple
  case pattern.length:
    this._processSimple(pattern.join(&#39;/&#39;), index, cb)
    return

  case 0:
    // pattern *starts* with some non-trivial item.
    // going to readdir(cwd), but not include the prefix in matches.
    prefix = null
    break

  default:
    // pattern has some string bits in the front.
    // whatever it starts with, whether that&#39;s &#39;absolute&#39; like /foo/bar,
    // or &#39;relative&#39; like &#39;../baz&#39;
    prefix = pattern.slice(0, n).join(&#39;/&#39;)
    break
}

var remain = pattern.slice(n)

// get the list of entries.
var read
if (prefix === null)
  read = &#39;.&#39;
else if (isAbsolute(prefix) || isAbsolute(pattern.join(&#39;/&#39;))) {
  if (!prefix || !isAbsolute(prefix))
    prefix = &#39;/&#39; + prefix
  read = prefix
} else
  read = prefix

var abs = this._makeAbs(read)

var isGlobStar = remain[0] === minimatch.GLOBSTAR
if (isGlobStar)
  this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
else
  this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)</code></pre>

<p>}</p>

<p>Glob.prototype._processReaddir = function (prefix, read, abs, remain,
index, inGlobStar, cb) {</p>

<pre><code>var self = this
this._readdir(abs, inGlobStar, function (er, entries) {
  return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
})</code></pre>

<p>}</p>

<p>Glob.prototype._processReaddir2 = function (prefix, read, abs, remain,
index, inGlobStar, entries, cb) {</p>

<pre><code>// if the abs isn&#39;t a dir, then nothing can match!
if (!entries)
  return cb()

// It will only match dot entries if it starts with a dot, or if
// dot is set.  Stuff like @(.foo|.bar) isn&#39;t allowed.
var pn = remain[0]
var negate = !!this.minimatch.negate
var rawGlob = pn._glob
var dotOk = this.dot || rawGlob.charAt(0) === &#39;.&#39;

var matchedEntries = []
for (var i = 0; i &lt; entries.length; i++) {
  var e = entries[i]
  if (e.charAt(0) !== &#39;.&#39; || dotOk) {
    var m
    if (negate &amp;&amp; !prefix) {
      m = !e.match(pn)
    } else {
      m = e.match(pn)
    }
    if (m)
      matchedEntries.push(e)
  }
}

//console.error(&#39;prd2&#39;, prefix, entries, remain[0]._glob, matchedEntries)

var len = matchedEntries.length
// If there are no matched entries, then nothing matches.
if (len === 0)
  return cb()

// if this is the last remaining pattern bit, then no need for
// an additional stat *unless* the user has specified mark or
// stat explicitly.  We know they exist, since readdir returned
// them.

if (remain.length === 1 &amp;&amp; !this.mark &amp;&amp; !this.stat) {
  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  for (var i = 0; i &lt; len; i ++) {
    var e = matchedEntries[i]
    if (prefix) {
      if (prefix !== &#39;/&#39;)
        e = prefix + &#39;/&#39; + e
      else
        e = prefix + e
    }

    if (e.charAt(0) === &#39;/&#39; &amp;&amp; !this.nomount) {
      e = path.join(this.root, e)
    }
    this._emitMatch(index, e)
  }
  // This was the last one, and no stats were needed
  return cb()
}

// now test all matched entries as stand-ins for that part
// of the pattern.
remain.shift()
for (var i = 0; i &lt; len; i ++) {
  var e = matchedEntries[i]
  var newPattern
  if (prefix) {
    if (prefix !== &#39;/&#39;)
      e = prefix + &#39;/&#39; + e
    else
      e = prefix + e
  }
  this._process([e].concat(remain), index, inGlobStar, cb)
}
cb()</code></pre>

<p>}</p>

<p>Glob.prototype._emitMatch = function (index, e) {</p>

<pre><code>if (this.aborted)
  return

if (!this.matches[index][e]) {
  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  if (this.nodir) {
    var c = this.cache[this._makeAbs(e)]
    if (c === &#39;DIR&#39; || Array.isArray(c))
      return
  }

  this.matches[index][e] = true
  if (!this.stat &amp;&amp; !this.mark)
    return this.emit(&#39;match&#39;, e)

  var self = this
  this._stat(this._makeAbs(e), function (er, c, st) {
    self.emit(&#39;stat&#39;, e, st)
    self.emit(&#39;match&#39;, e)
  })
}</code></pre>

<p>}</p>

<p>Glob.prototype._readdirInGlobStar = function (abs, cb) {</p>

<pre><code>if (this.aborted)
  return

var lstatkey = &#39;lstat\0&#39; + abs
var self = this
var lstatcb = inflight(lstatkey, lstatcb_)

if (lstatcb)
  fs.lstat(abs, lstatcb)

function lstatcb_ (er, lstat) {
  if (er)
    return cb()

  var isSym = lstat.isSymbolicLink()
  self.symlinks[abs] = isSym

  // If it&#39;s not a symlink or a dir, then it&#39;s definitely a regular file.
  // don&#39;t bother doing a readdir in that case.
  if (!isSym &amp;&amp; !lstat.isDirectory()) {
    self.cache[abs] = &#39;FILE&#39;
    cb()
  } else
    self._readdir(abs, false, cb)
}</code></pre>

<p>}</p>

<p>Glob.prototype._readdir = function (abs, inGlobStar, cb) {</p>

<pre><code>if (this.aborted)
  return

cb = inflight(&#39;readdir\0&#39;+abs+&#39;\0&#39;+inGlobStar, cb)
if (!cb)
  return

//console.error(&#39;RD %j %j&#39;, +inGlobStar, abs)
if (inGlobStar &amp;&amp; !ownProp(this.symlinks, abs))
  return this._readdirInGlobStar(abs, cb)

if (ownProp(this.cache, abs)) {
  var c = this.cache[abs]
  if (!c || c === &#39;FILE&#39;)
    return cb()

  if (Array.isArray(c))
    return cb(null, c)
}

var self = this
fs.readdir(abs, readdirCb(this, abs, cb))</code></pre>

<p>}</p>

<p>function readdirCb (self, abs, cb) {</p>

<pre><code>return function (er, entries) {
  if (er)
    self._readdirError(abs, er, cb)
  else
    self._readdirEntries(abs, entries, cb)
}</code></pre>

<p>}</p>

<p>Glob.prototype._readdirEntries = function (abs, entries, cb) {</p>

<pre><code>if (this.aborted)
  return

// if we haven&#39;t asked to stat everything, then just
// assume that everything in there exists, so we can avoid
// having to stat it a second time.
if (!this.mark &amp;&amp; !this.stat) {
  for (var i = 0; i &lt; entries.length; i ++) {
    var e = entries[i]
    if (abs === &#39;/&#39;)
      e = abs + e
    else
      e = abs + &#39;/&#39; + e
    this.cache[e] = true
  }
}

this.cache[abs] = entries
return cb(null, entries)</code></pre>

<p>}</p>

<p>Glob.prototype._readdirError = function (f, er, cb) {</p>

<pre><code>if (this.aborted)
  return

// handle errors, and cache the information
switch (er.code) {
  case &#39;ENOTDIR&#39;: // totally normal. means it *does* exist.
    this.cache[f] = &#39;FILE&#39;
    break

  case &#39;ENOENT&#39;: // not terribly unusual
  case &#39;ELOOP&#39;:
  case &#39;ENAMETOOLONG&#39;:
  case &#39;UNKNOWN&#39;:
    this.cache[f] = false
    break

  default: // some unusual error.  Treat as failure.
    this.cache[f] = false
    if (this.strict) return this.emit(&#39;error&#39;, er)
    if (!this.silent) console.error(&#39;glob error&#39;, er)
    break
}
return cb()</code></pre>

<p>}</p>

<p>Glob.prototype._processGlobStar = function (prefix, read, abs, remain,
index, inGlobStar, cb) {</p>

<pre><code>var self = this
this._readdir(abs, inGlobStar, function (er, entries) {
  self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
})</code></pre>

<p>}</p>

<p>Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain,
index, inGlobStar, entries, cb) {</p>

<pre><code>//console.error(&#39;pgs2&#39;, prefix, remain[0], entries)

// no entries means not a dir, so it can never have matches
// foo.txt/** doesn&#39;t match foo.txt
if (!entries)
  return cb()

// test without the globstar, and with every child both below
// and replacing the globstar.
var remainWithoutGlobStar = remain.slice(1)
var gspref = prefix ? [ prefix ] : []
var noGlobStar = gspref.concat(remainWithoutGlobStar)

// the noGlobStar pattern exits the inGlobStar state
this._process(noGlobStar, index, false, cb)

var isSym = this.symlinks[abs]
var len = entries.length

// If it&#39;s a symlink, and we&#39;re in a globstar, then stop
if (isSym &amp;&amp; inGlobStar)
  return cb()

for (var i = 0; i &lt; len; i++) {
  var e = entries[i]
  if (e.charAt(0) === &#39;.&#39; &amp;&amp; !this.dot)
    continue

  // these two cases enter the inGlobStar state
  var instead = gspref.concat(entries[i], remainWithoutGlobStar)
  this._process(instead, index, true, cb)

  var below = gspref.concat(entries[i], remain)
  this._process(below, index, true, cb)
}

cb()</code></pre>

<p>}</p>

<p>Glob.prototype._processSimple = function (prefix, index, cb) {</p>

<pre><code>// XXX review this.  Shouldn&#39;t it be doing the mounting etc
// before doing stat?  kinda weird?
var self = this
this._stat(prefix, function (er, exists) {
  self._processSimple2(prefix, index, er, exists, cb)
})</code></pre>

<p>} Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb)
{</p>

<pre><code>//console.error(&#39;ps2&#39;, prefix, exists)

if (!this.matches[index])
  this.matches[index] = Object.create(null)

// If it doesn&#39;t exist, then just mark the lack of results
if (!exists)
  return cb()

if (prefix &amp;&amp; isAbsolute(prefix) &amp;&amp; !this.nomount) {
  var trail = /[\/\\]$/.test(prefix)
  if (prefix.charAt(0) === &#39;/&#39;) {
    prefix = path.join(this.root, prefix)
  } else {
    prefix = path.resolve(this.root, prefix)
    if (trail)
      prefix += &#39;/&#39;
  }
}

if (process.platform === &#39;win32&#39;)
  prefix = prefix.replace(/\\/g, &#39;/&#39;)

// Mark this as a match
this._emitMatch(index, prefix)
cb()</code></pre>

<p>}</p>

<p>// Returns either &#39;DIR&#39;, &#39;FILE&#39;, or false
Glob.prototype._stat = function (f, cb) {</p>

<pre><code>var abs = f
if (f.charAt(0) === &#39;/&#39;)
  abs = path.join(this.root, f)
else if (this.changedCwd)
  abs = path.resolve(this.cwd, f)

if (f.length &gt; this.maxLength)
  return cb()

if (!this.stat &amp;&amp; ownProp(this.cache, f)) {
  var c = this.cache[f]

  if (Array.isArray(c))
    c = &#39;DIR&#39;

  // It exists, but not how we need it
  if (abs.slice(-1) === &#39;/&#39; &amp;&amp; c !== &#39;DIR&#39;)
    return cb()

  return cb(null, c)
}

var exists
var stat = this.statCache[abs]
if (stat !== undefined) {
  if (stat === false)
    return cb(null, stat)
  else
    return cb(null, stat.isDirectory() ? &#39;DIR&#39; : &#39;FILE&#39;, stat)
}

var self = this
var statcb = inflight(&#39;stat\0&#39; + abs, statcb_)
if (statcb)
  fs.stat(abs, statcb)

function statcb_ (er, stat) {
  self._stat2(f, abs, er, stat, cb)
}</code></pre>

<p>}</p>

<p>Glob.prototype._stat2 = function (f, abs, er, stat, cb) {</p>

<pre><code>if (er) {
  this.statCache[abs] = false
  return cb()
}

this.statCache[abs] = stat

if (abs.slice(-1) === &#39;/&#39; &amp;&amp; !stat.isDirectory())
  return cb(null, false, stat)

var c = stat.isDirectory() ? &#39;DIR&#39; : &#39;FILE&#39;
this.cache[f] = this.cache[f] || c
return cb(null, c, stat)</code></pre>

<p>}</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
