<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>action_container.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            action_container.js
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/js-yaml/node_modules/argparse/lib/action_container.js</li>
            <li>Last modified: 2015-08-19 01:14:21 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<pre><code> internal
class ActionContainer

Action container. Parent for [[ArgumentParser]] and [[ArgumentGroup]]</code></pre>

<p>&#39;use strict&#39;;</p>

<p>var format = require(&#39;util&#39;).format; var _      =
require(&#39;underscore&#39;);</p>

<p>_.str = require(&#39;underscore.string&#39;);</p>

<p>// Constants var $$ = require(&#39;./const&#39;);</p>

<p>//Actions var ActionHelp = require(&#39;./action/help&#39;); var
ActionAppend = require(&#39;./action/append&#39;); var ActionAppendConstant
= require(&#39;./action/append/constant&#39;); var ActionCount =
require(&#39;./action/count&#39;); var ActionStore =
require(&#39;./action/store&#39;); var ActionStoreConstant =
require(&#39;./action/store/constant&#39;); var ActionStoreTrue =
require(&#39;./action/store/true&#39;); var ActionStoreFalse =
require(&#39;./action/store/false&#39;); var ActionVersion =
require(&#39;./action/version&#39;); var ActionSubparsers =
require(&#39;./action/subparsers&#39;);</p>

<p>// Errors var argumentErrorHelper = require(&#39;./argument/error&#39;);</p>

<pre><code>new ActionContainer(options)

Action container. Parent for [[ArgumentParser]] and [[ArgumentGroup]]

##### Options:

- `description` -- A description of what the program does
- `prefixChars`  -- Characters that prefix optional arguments
- `argumentDefault`  -- The default value for all arguments
- `conflictHandler` -- The conflict handler to use for duplicate arguments</code></pre>

<p>var ActionContainer = module.exports = function ActionContainer(options) {</p>

<pre><code>options = options || {};

this.description = options.description;
this.argumentDefault = options.argumentDefault;
this.prefixChars = options.prefixChars || &#39;&#39;;
this.conflictHandler = options.conflictHandler;

// set up registries
this._registries = {};

// register actions
this.register(&#39;action&#39;, null, ActionStore);
this.register(&#39;action&#39;, &#39;store&#39;, ActionStore);
this.register(&#39;action&#39;, &#39;storeConst&#39;, ActionStoreConstant);
this.register(&#39;action&#39;, &#39;storeTrue&#39;, ActionStoreTrue);
this.register(&#39;action&#39;, &#39;storeFalse&#39;, ActionStoreFalse);
this.register(&#39;action&#39;, &#39;append&#39;, ActionAppend);
this.register(&#39;action&#39;, &#39;appendConst&#39;, ActionAppendConstant);
this.register(&#39;action&#39;, &#39;count&#39;, ActionCount);
this.register(&#39;action&#39;, &#39;help&#39;, ActionHelp);
this.register(&#39;action&#39;, &#39;version&#39;, ActionVersion);
this.register(&#39;action&#39;, &#39;parsers&#39;, ActionSubparsers);

// raise an exception if the conflict handler is invalid
this._getHandler();

// action storage
this._actions = [];
this._optionStringActions = {};

// groups
this._actionGroups = [];
this._mutuallyExclusiveGroups = [];

// defaults storage
this._defaults = {};

// determines whether an &quot;option&quot; looks like a negative number
// -1, -1.5 -5e+4
this._regexpNegativeNumber = new RegExp(&#39;^[-]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$&#39;);

// whether or not there are any optionals that look like negative
// numbers -- uses a list so it can be shared and edited
this._hasNegativeNumberOptionals = [];</code></pre>

<p>};</p>

<p>// Groups must be required, then ActionContainer already defined var
ArgumentGroup = require(&#39;./argument/group&#39;); var
MutuallyExclusiveGroup = require(&#39;./argument/exclusive&#39;);</p>

<p>// // Registration methods //</p>

<p>/**</p>

<pre><code>ActionContainer#register(registryName, value, object) -&gt; Void
- registryName (String) : object type action|type
- value (string) : keyword
- object (Object|Function) : handler

 Register handlers
/</code></pre>

<p>ActionContainer.prototype.register = function (registryName, value, object)
{</p>

<pre><code>this._registries[registryName] = this._registries[registryName] || {};
this._registries[registryName][value] = object;
</code></pre>

<p>};</p>

<p>ActionContainer.prototype._registryGet = function (registryName, value,
defaultValue) {</p>

<pre><code>if (3 &gt; arguments.length) {
  defaultValue = null;
}
return this._registries[registryName][value] || defaultValue;</code></pre>

<p>};</p>

<p>// // Namespace default accessor methods //</p>

<p>/**</p>

<pre><code>ActionContainer#setDefaults(options) -&gt; Void
- options (object):hash of options see [[Action.new]]

Set defaults
/</code></pre>

<p>ActionContainer.prototype.setDefaults = function (options) {</p>

<pre><code>options = options || {};
for (var property in options) {
  this._defaults[property] = options[property];
}

// if these defaults match any existing arguments, replace the previous
// default on the object with the new one
this._actions.forEach(function (action) {
  if (action.dest in options) {
    action.defaultValue = options[action.dest];
  }
});</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>ActionContainer#getDefault(dest) -&gt; Mixed
- dest (string): action destination

Return action default value
/</code></pre>

<p>ActionContainer.prototype.getDefault = function (dest) {</p>

<pre><code>var result = (_.has(this._defaults, dest)) ? this._defaults[dest] : null;

this._actions.forEach(function (action) {
  if (action.dest === dest &amp;&amp; _.has(action, &#39;defaultValue&#39;)) {
    result = action.defaultValue;
  }
});

return result;</code></pre>

<p>}; // // Adding argument actions //</p>

<p>/**</p>

<pre><code>ActionContainer#addArgument(args, options) -&gt; Object
- args (Array): array of argument keys
- options (Object): action objects see [[Action.new]]

#### Examples
- addArgument([-f, --foo], {action:&#39;store&#39;, defaultValue=1, ...})
- addArgument([&#39;bar&#39;], action: &#39;store&#39;, nargs:1, ...})
/</code></pre>

<p>ActionContainer.prototype.addArgument = function (args, options) {</p>

<pre><code>args = args;
options = options || {};

if (!_.isArray(args)) {
  throw new TypeError(&#39;addArgument first argument should be an array&#39;);
}
if (!_.isObject(options) || _.isArray(options)) {
  throw new TypeError(&#39;addArgument second argument should be a hash&#39;);
}

// if no positional args are supplied or only one is supplied and
// it doesn&#39;t look like an option string, parse a positional argument
if (!args || args.length === 1 &amp;&amp; this.prefixChars.indexOf(args[0][0]) &lt; 0) {
  if (args &amp;&amp; !!options.dest) {
    throw new Error(&#39;dest supplied twice for positional argument&#39;);
  }
  options = this._getPositional(args, options);

  // otherwise, we&#39;re adding an optional argument
} else {
  options = this._getOptional(args, options);
}

// if no default was supplied, use the parser-level default
if (_.isUndefined(options.defaultValue)) {
  var dest = options.dest;
  if (_.has(this._defaults, dest)) {
    options.defaultValue = this._defaults[dest];
  } else if (!_.isUndefined(this.argumentDefault)) {
    options.defaultValue = this.argumentDefault;
  }
}

// create the action object, and add it to the parser
var ActionClass = this._popActionClass(options);
if (! _.isFunction(ActionClass)) {
  throw new Error(format(&#39;Unknown action &quot;%s&quot;.&#39;, ActionClass));
}
var action = new ActionClass(options);

// throw an error if the action type is not callable
var typeFunction = this._registryGet(&#39;type&#39;, action.type, action.type);
if (!_.isFunction(typeFunction)) {
  throw new Error(format(&#39;&quot;%s&quot; is not callable&#39;, typeFunction));
}

return this._addAction(action);</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>ActionContainer#addArgumentGroup(options) -&gt; ArgumentGroup
- options (Object): hash of options see [[ArgumentGroup.new]]

Create new arguments groups
/</code></pre>

<p>ActionContainer.prototype.addArgumentGroup = function (options) {</p>

<pre><code>var group = new ArgumentGroup(this, options);
this._actionGroups.push(group);
return group;</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>ActionContainer#addMutuallyExclusiveGroup(options) -&gt; ArgumentGroup
- options (Object): {required: false}

Create new mutual exclusive groups
/</code></pre>

<p>ActionContainer.prototype.addMutuallyExclusiveGroup = function (options) {</p>

<pre><code>var group = new MutuallyExclusiveGroup(this, options);
this._mutuallyExclusiveGroups.push(group);
return group;</code></pre>

<p>};</p>

<p>ActionContainer.prototype._addAction = function (action) {</p>

<pre><code>var self = this;

// resolve any conflicts
this._checkConflict(action);

// add to actions list
this._actions.push(action);
action.container = this;

// index the action by any option strings it has
action.optionStrings.forEach(function (optionString) {
  self._optionStringActions[optionString] = action;
});

// set the flag if any option strings look like negative numbers
action.optionStrings.forEach(function (optionString) {
  if (optionString.match(self._regexpNegativeNumber)) {
    if (!_.any(self._hasNegativeNumberOptionals)) {
      self._hasNegativeNumberOptionals.push(true);
    }
  }
});

// return the created action
return action;</code></pre>

<p>};</p>

<p>ActionContainer.prototype._removeAction = function (action) {</p>

<pre><code>var actionIndex = this._actions.indexOf(action);
if (actionIndex &gt;= 0) {
  this._actions.splice(actionIndex, 1);
}</code></pre>

<p>};</p>

<p>ActionContainer.prototype._addContainerActions = function (container) {</p>

<pre><code>// collect groups by titles
var titleGroupMap = {};
this._actionGroups.forEach(function (group) {
  if (titleGroupMap[group.title]) {
    throw new Error(format(&#39;Cannot merge actions - two groups are named &quot;%s&quot;.&#39;, group.title));
  }
  titleGroupMap[group.title] = group;
});

// map each action to its group
var groupMap = {};
function actionHash(action) {
  // unique (hopefully?) string suitable as dictionary key
  return action.getName();
}
container._actionGroups.forEach(function (group) {
  // if a group with the title exists, use that, otherwise
  // create a new group matching the container&#39;s group
  if (!titleGroupMap[group.title]) {
    titleGroupMap[group.title] = this.addArgumentGroup({
      title: group.title,
      description: group.description
    });
  }

  // map the actions to their new group
  group._groupActions.forEach(function (action) {
    groupMap[actionHash(action)] = titleGroupMap[group.title];
  });
}, this);

// add container&#39;s mutually exclusive groups
// NOTE: if add_mutually_exclusive_group ever gains title= and
// description= then this code will need to be expanded as above
var mutexGroup;
container._mutuallyExclusiveGroups.forEach(function (group) {
  mutexGroup = this.addMutuallyExclusiveGroup({
      required: group.required
    });
  // map the actions to their new mutex group
  group._groupActions.forEach(function (action) {
    groupMap[actionHash(action)] = mutexGroup;
  });
}, this);  // forEach takes a &#39;this&#39; argument

// add all actions to this container or their group
container._actions.forEach(function (action) {
  var key = actionHash(action);
  if (!!groupMap[key]) {
    groupMap[key]._addAction(action);
  }
  else
  {
    this._addAction(action);
  }
});</code></pre>

<p>};</p>

<p>ActionContainer.prototype._getPositional = function (dest, options) {</p>

<pre><code>if (_.isArray(dest)) {
  dest = _.first(dest);
}
// make sure required is not specified
if (options.required) {
  throw new Error(&#39;&quot;required&quot; is an invalid argument for positionals.&#39;);
}

// mark positional arguments as required if at least one is
// always required
if (options.nargs !== $$.OPTIONAL &amp;&amp; options.nargs !== $$.ZERO_OR_MORE) {
  options.required = true;
}
if (options.nargs === $$.ZERO_OR_MORE &amp;&amp; options.defaultValue === undefined) {
  options.required = true;
}

// return the keyword arguments with no option strings
options.dest = dest;
options.optionStrings = [];
return options;</code></pre>

<p>};</p>

<p>ActionContainer.prototype._getOptional = function (args, options) {</p>

<pre><code>var prefixChars = this.prefixChars;
var optionStrings = [];
var optionStringsLong = [];

// determine short and long option strings
args.forEach(function (optionString) {
  // error on strings that don&#39;t start with an appropriate prefix
  if (prefixChars.indexOf(optionString[0]) &lt; 0) {
    throw new Error(format(&#39;Invalid option string &quot;%s&quot;: must start with a &quot;%s&quot;.&#39;,
      optionString,
      prefixChars
    ));
  }

  // strings starting with two prefix characters are long options
  optionStrings.push(optionString);
  if (optionString.length &gt; 1 &amp;&amp; prefixChars.indexOf(optionString[1]) &gt;= 0) {
    optionStringsLong.push(optionString);
  }
});

// infer dest, &#39;--foo-bar&#39; -&gt; &#39;foo_bar&#39; and &#39;-x&#39; -&gt; &#39;x&#39;
var dest = options.dest || null;
delete options.dest;

if (!dest) {
  var optionStringDest = optionStringsLong.length ? optionStringsLong[0] :optionStrings[0];
  dest = _.str.strip(optionStringDest, this.prefixChars);

  if (dest.length === 0) {
    throw new Error(
      format(&#39;dest= is required for options like &quot;%s&quot;&#39;, optionStrings.join(&#39;, &#39;))
    );
  }
  dest = dest.replace(/-/g, &#39;_&#39;);
}

// return the updated keyword arguments
options.dest = dest;
options.optionStrings = optionStrings;

return options;</code></pre>

<p>};</p>

<p>ActionContainer.prototype._popActionClass = function (options,
defaultValue) {</p>

<pre><code>defaultValue = defaultValue || null;

var action = (options.action || defaultValue);
delete options.action;

var actionClass = this._registryGet(&#39;action&#39;, action, action);
return actionClass;
</code></pre>

<p>};</p>

<p>ActionContainer.prototype._getHandler = function () {</p>

<pre><code>var handlerString = this.conflictHandler;
var handlerFuncName = &quot;_handleConflict&quot; + _.str.capitalize(handlerString);
var func = this[handlerFuncName];
if (typeof func === &#39;undefined&#39;) {
  var msg = &quot;invalid conflict resolution value: &quot; + handlerString;
  throw new Error(msg);
} else {
  return func;
}</code></pre>

<p>};</p>

<p>ActionContainer.prototype._checkConflict = function (action) {</p>

<pre><code>var optionStringActions = this._optionStringActions;
var conflictOptionals = [];

// find all options that conflict with this option
// collect pairs, the string, and an existing action that it conflicts with
action.optionStrings.forEach(function (optionString) {
  var conflOptional = optionStringActions[optionString];
  if (typeof conflOptional !== &#39;undefined&#39;) {
    conflictOptionals.push([optionString, conflOptional]);
  }
});

if (conflictOptionals.length &gt; 0) {
  var conflictHandler = this._getHandler();
  conflictHandler.call(this, action, conflictOptionals);
}</code></pre>

<p>};</p>

<p>ActionContainer.prototype._handleConflictError = function (action,
conflOptionals) {</p>

<pre><code>var conflicts = _.map(conflOptionals, function (pair) {return pair[0]; });
conflicts = conflicts.join(&#39;, &#39;);
throw argumentErrorHelper(
  action,
  format(&#39;Conflicting option string(s): %s&#39;, conflicts)
);</code></pre>

<p>};</p>

<p>ActionContainer.prototype._handleConflictResolve = function (action,
conflOptionals) {</p>

<pre><code>// remove all conflicting options
var self = this;
conflOptionals.forEach(function (pair) {
  var optionString = pair[0];
  var conflictingAction = pair[1];
  // remove the conflicting option string
  var i = conflictingAction.optionStrings.indexOf(optionString);
  if (i &gt;= 0) {
    conflictingAction.optionStrings.splice(i, 1);
  }
  delete self._optionStringActions[optionString];
  // if the option now has no option string, remove it from the
  // container holding it
  if (conflictingAction.optionStrings.length === 0) {
    conflictingAction.container._removeAction(conflictingAction);
  }
});</code></pre>

<p>};</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
