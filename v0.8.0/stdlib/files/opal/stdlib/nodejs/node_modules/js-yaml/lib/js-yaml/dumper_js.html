<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>dumper.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            dumper.js
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/js-yaml/lib/js-yaml/dumper.js</li>
            <li>Last modified: 2015-08-19 01:14:21 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>&#39;use strict&#39;;</p>

<p>var common              = require(&#39;./common&#39;); var YAMLException   
= require(&#39;./exception&#39;); var DEFAULT_FULL_SCHEMA =
require(&#39;./schema/default_full&#39;); var DEFAULT_SAFE_SCHEMA =
require(&#39;./schema/default_safe&#39;);</p>

<p>var _toString       = Object.prototype.toString; var _hasOwnProperty =
Object.prototype.hasOwnProperty;</p>

<p>var CHAR_TAB                  = 0x09;    Tab</p>

<p>var CHAR_LINE_FEED            = 0x0A;    LF</p>

<p>var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */ var CHAR_SPACE              
= 0x20; /* Space */ var CHAR_EXCLAMATION          = 0x21; /* ! */ var
CHAR_DOUBLE_QUOTE         = 0x22; /* “ */ var CHAR_SHARP                =
0x23; /* # */ var CHAR_PERCENT              = 0x25; /* % */ var
CHAR_AMPERSAND            = 0x26; /* &amp; */ var CHAR_SINGLE_QUOTE        
= 0x27; /* &#39; */ var CHAR_ASTERISK             = 0x2A; /* * */ var
CHAR_COMMA                = 0x2C; /* , */ var CHAR_MINUS                =
0x2D; /* - */ var CHAR_COLON                = 0x3A; /* : */ var
CHAR_GREATER_THAN         = 0x3E; /* &gt; */ var CHAR_QUESTION            
= 0x3F; /* ? */ var CHAR_COMMERCIAL_AT        = 0x40; /* @ */ var
CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */ var CHAR_RIGHT_SQUARE_BRACKET =
0x5D; /* ] */ var CHAR_GRAVE_ACCENT         = 0x60; /* ` */ var
CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */ var CHAR_VERTICAL_LINE        =
0x7C; /* | */ var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */</p>

<p>var ESCAPE_SEQUENCES = {};</p>

<p><a href="0x00">ESCAPE_SEQUENCES</a>   = &#39;\0&#39;; <a
href="0x07">ESCAPE_SEQUENCES</a>   = &#39;\a&#39;; <a
href="0x08">ESCAPE_SEQUENCES</a>   = &#39;\b&#39;; <a
href="0x09">ESCAPE_SEQUENCES</a>   = &#39;\t&#39;; <a
href="0x0A">ESCAPE_SEQUENCES</a>   = &#39;\n&#39;; <a
href="0x0B">ESCAPE_SEQUENCES</a>   = &#39;\v&#39;; <a
href="0x0C">ESCAPE_SEQUENCES</a>   = &#39;\f&#39;; <a
href="0x0D">ESCAPE_SEQUENCES</a>   = &#39;\r&#39;; <a
href="0x1B">ESCAPE_SEQUENCES</a>   = &#39;\e&#39;; <a
href="0x22">ESCAPE_SEQUENCES</a>   = &#39;\“&#39;; <a
href="0x5C">ESCAPE_SEQUENCES</a>   = &#39;\\&#39;; <a
href="0x85">ESCAPE_SEQUENCES</a>   = &#39;\N&#39;; <a
href="0xA0">ESCAPE_SEQUENCES</a>   = &#39;_&#39;; <a
href="0x2028">ESCAPE_SEQUENCES</a> = &#39;\L&#39;; <a
href="0x2029">ESCAPE_SEQUENCES</a> = &#39;\P&#39;;</p>

<p>var DEPRECATED_BOOLEANS_SYNTAX = [</p>

<pre><code>&#39;y&#39;, &#39;Y&#39;, &#39;yes&#39;, &#39;Yes&#39;, &#39;YES&#39;, &#39;on&#39;, &#39;On&#39;, &#39;ON&#39;,
&#39;n&#39;, &#39;N&#39;, &#39;no&#39;, &#39;No&#39;, &#39;NO&#39;, &#39;off&#39;, &#39;Off&#39;, &#39;OFF&#39;</code></pre>

<p>];</p>

<p>function compileStyleMap(schema, map) {</p>

<pre><code>var result, keys, index, length, tag, style, type;

if (null === map) {
  return {};
}

result = {};
keys = Object.keys(map);

for (index = 0, length = keys.length; index &lt; length; index += 1) {
  tag = keys[index];
  style = String(map[tag]);

  if (&#39;!!&#39; === tag.slice(0, 2)) {
    tag = &#39;tag:yaml.org,2002:&#39; + tag.slice(2);
  }

  type = schema.compiledTypeMap[tag];

  if (type &amp;&amp; _hasOwnProperty.call(type.styleAliases, style)) {
    style = type.styleAliases[style];
  }

  result[tag] = style;
}

return result;</code></pre>

<p>}</p>

<p>function encodeHex(character) {</p>

<pre><code>var string, handle, length;

string = character.toString(16).toUpperCase();

if (character &lt;= 0xFF) {
  handle = &#39;x&#39;;
  length = 2;
} else if (character &lt;= 0xFFFF) {
  handle = &#39;u&#39;;
  length = 4;
} else if (character &lt;= 0xFFFFFFFF) {
  handle = &#39;U&#39;;
  length = 8;
} else {
  throw new YAMLException(&#39;code point within a string may not be greater than 0xFFFFFFFF&#39;);
}

return &#39;\\&#39; + handle + common.repeat(&#39;0&#39;, length - string.length) + string;</code></pre>

<p>}</p>

<p>function State(options) {</p>

<pre><code>this.schema      = options[&#39;schema&#39;] || DEFAULT_FULL_SCHEMA;
this.indent      = Math.max(1, (options[&#39;indent&#39;] || 2));
this.skipInvalid = options[&#39;skipInvalid&#39;] || false;
this.flowLevel   = (common.isNothing(options[&#39;flowLevel&#39;]) ? -1 : options[&#39;flowLevel&#39;]);
this.styleMap    = compileStyleMap(this.schema, options[&#39;styles&#39;] || null);

this.implicitTypes = this.schema.compiledImplicit;
this.explicitTypes = this.schema.compiledExplicit;

this.tag = null;
this.result = &#39;&#39;;

this.duplicates = [];
this.usedDuplicates = null;
</code></pre>

<p>}</p>

<p>function generateNextLine(state, level) {</p>

<pre><code>return &#39;\n&#39; + common.repeat(&#39; &#39;, state.indent * level);
</code></pre>

<p>}</p>

<p>function testImplicitResolving(state, str) {</p>

<pre><code>var index, length, type;

for (index = 0, length = state.implicitTypes.length; index &lt; length; index += 1) {
  type = state.implicitTypes[index];

  if (type.resolve(str)) {
    return true;
  }
}

return false;</code></pre>

<p>}</p>

<p>function writeScalar(state, object) {</p>

<pre><code>var isQuoted, checkpoint, position, length, character, first;

state.dump = &#39;&#39;;
isQuoted = false;
checkpoint = 0;
first = object.charCodeAt(0) || 0;

if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
  // Ensure compatibility with YAML 1.0/1.1 loaders.
  isQuoted = true;
} else if (0 === object.length) {
  // Quote empty string
  isQuoted = true;
} else if (CHAR_SPACE    === first ||
           CHAR_SPACE    === object.charCodeAt(object.length - 1)) {
  isQuoted = true;
} else if (CHAR_MINUS    === first ||
           CHAR_QUESTION === first) {
  // Don&#39;t check second symbol for simplicity
  isQuoted = true;
}

for (position = 0, length = object.length; position &lt; length; position += 1) {
  character = object.charCodeAt(position);

  if (!isQuoted) {
    if (CHAR_TAB                  === character ||
        CHAR_LINE_FEED            === character ||
        CHAR_CARRIAGE_RETURN      === character ||
        CHAR_COMMA                === character ||
        CHAR_LEFT_SQUARE_BRACKET  === character ||
        CHAR_RIGHT_SQUARE_BRACKET === character ||
        CHAR_LEFT_CURLY_BRACKET   === character ||
        CHAR_RIGHT_CURLY_BRACKET  === character ||
        CHAR_SHARP                === character ||
        CHAR_AMPERSAND            === character ||
        CHAR_ASTERISK             === character ||
        CHAR_EXCLAMATION          === character ||
        CHAR_VERTICAL_LINE        === character ||
        CHAR_GREATER_THAN         === character ||
        CHAR_SINGLE_QUOTE         === character ||
        CHAR_DOUBLE_QUOTE         === character ||
        CHAR_PERCENT              === character ||
        CHAR_COMMERCIAL_AT        === character ||
        CHAR_COLON                === character ||
        CHAR_GRAVE_ACCENT         === character) {
      isQuoted = true;
    }
  }

  if (ESCAPE_SEQUENCES[character] ||
      !((0x00020 &lt;= character &amp;&amp; character &lt;= 0x00007E) ||
        (0x00085 === character)                         ||
        (0x000A0 &lt;= character &amp;&amp; character &lt;= 0x00D7FF) ||
        (0x0E000 &lt;= character &amp;&amp; character &lt;= 0x00FFFD) ||
        (0x10000 &lt;= character &amp;&amp; character &lt;= 0x10FFFF))) {
    state.dump += object.slice(checkpoint, position);
    state.dump += ESCAPE_SEQUENCES[character] || encodeHex(character);
    checkpoint = position + 1;
    isQuoted = true;
  }
}

if (checkpoint &lt; position) {
  state.dump += object.slice(checkpoint, position);
}

if (!isQuoted &amp;&amp; testImplicitResolving(state, state.dump)) {
  isQuoted = true;
}

if (isQuoted) {
  state.dump = &#39;&quot;&#39; + state.dump + &#39;&quot;&#39;;
}</code></pre>

<p>}</p>

<p>function writeFlowSequence(state, level, object) {</p>

<pre><code>var _result = &#39;&#39;,
    _tag    = state.tag,
    index,
    length;

for (index = 0, length = object.length; index &lt; length; index += 1) {
  // Write only valid elements.
  if (writeNode(state, level, object[index], false, false)) {
    if (0 !== index) {
      _result += &#39;, &#39;;
    }
    _result += state.dump;
  }
}

state.tag = _tag;
state.dump = &#39;[&#39; + _result + &#39;]&#39;;</code></pre>

<p>}</p>

<p>function writeBlockSequence(state, level, object, compact) {</p>

<pre><code>var _result = &#39;&#39;,
    _tag    = state.tag,
    index,
    length;

for (index = 0, length = object.length; index &lt; length; index += 1) {
  // Write only valid elements.
  if (writeNode(state, level + 1, object[index], true, true)) {
    if (!compact || 0 !== index) {
      _result += generateNextLine(state, level);
    }
    _result += &#39;- &#39; + state.dump;
  }
}

state.tag = _tag;
state.dump = _result || &#39;[]&#39;; // Empty sequence if no valid values.</code></pre>

<p>}</p>

<p>function writeFlowMapping(state, level, object) {</p>

<pre><code>var _result       = &#39;&#39;,
    _tag          = state.tag,
    objectKeyList = Object.keys(object),
    index,
    length,
    objectKey,
    objectValue,
    pairBuffer;

for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
  pairBuffer = &#39;&#39;;

  if (0 !== index) {
    pairBuffer += &#39;, &#39;;
  }

  objectKey = objectKeyList[index];
  objectValue = object[objectKey];

  if (!writeNode(state, level, objectKey, false, false)) {
    continue; // Skip this pair because of invalid key;
  }

  if (state.dump.length &gt; 1024) {
    pairBuffer += &#39;? &#39;;
  }

  pairBuffer += state.dump + &#39;: &#39;;

  if (!writeNode(state, level, objectValue, false, false)) {
    continue; // Skip this pair because of invalid value.
  }

  pairBuffer += state.dump;

  // Both key and value are valid.
  _result += pairBuffer;
}

state.tag = _tag;
state.dump = &#39;{&#39; + _result + &#39;}&#39;;</code></pre>

<p>}</p>

<p>function writeBlockMapping(state, level, object, compact) {</p>

<pre><code>var _result       = &#39;&#39;,
    _tag          = state.tag,
    objectKeyList = Object.keys(object),
    index,
    length,
    objectKey,
    objectValue,
    explicitPair,
    pairBuffer;

for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
  pairBuffer = &#39;&#39;;

  if (!compact || 0 !== index) {
    pairBuffer += generateNextLine(state, level);
  }

  objectKey = objectKeyList[index];
  objectValue = object[objectKey];

  if (!writeNode(state, level + 1, objectKey, true, true)) {
    continue; // Skip this pair because of invalid key.
  }

  explicitPair = (null !== state.tag &amp;&amp; &#39;?&#39; !== state.tag) ||
                 (state.dump &amp;&amp; state.dump.length &gt; 1024);

  if (explicitPair) {
    if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += &#39;?&#39;;
    } else {
      pairBuffer += &#39;? &#39;;
    }
  }

  pairBuffer += state.dump;

  if (explicitPair) {
    pairBuffer += generateNextLine(state, level);
  }

  if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
    continue; // Skip this pair because of invalid value.
  }

  if (state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
    pairBuffer += &#39;:&#39;;
  } else {
    pairBuffer += &#39;: &#39;;
  }

  pairBuffer += state.dump;

  // Both key and value are valid.
  _result += pairBuffer;
}

state.tag = _tag;
state.dump = _result || &#39;{}&#39;; // Empty mapping if no valid pairs.</code></pre>

<p>}</p>

<p>function detectType(state, object, explicit) {</p>

<pre><code>var _result, typeList, index, length, type, style;

typeList = explicit ? state.explicitTypes : state.implicitTypes;

for (index = 0, length = typeList.length; index &lt; length; index += 1) {
  type = typeList[index];

  if ((type.instanceOf  || type.predicate) &amp;&amp;
      (!type.instanceOf || ((&#39;object&#39; === typeof object) &amp;&amp; (object instanceof type.instanceOf))) &amp;&amp;
      (!type.predicate  || type.predicate(object))) {

    state.tag = explicit ? type.tag : &#39;?&#39;;

    if (type.represent) {
      style = state.styleMap[type.tag] || type.defaultStyle;

      if (&#39;[object Function]&#39; === _toString.call(type.represent)) {
        _result = type.represent(object, style);
      } else if (_hasOwnProperty.call(type.represent, style)) {
        _result = type.represent[style](object, style);
      } else {
        throw new YAMLException(&#39;!&lt;&#39; + type.tag + &#39;&gt; tag resolver accepts not &quot;&#39; + style + &#39;&quot; style&#39;);
      }

      state.dump = _result;
    }

    return true;
  }
}

return false;</code></pre>

<p>}</p>

<p>// Serializes `object` and writes it to global `result`. // Returns true on
success, or false on invalid object. // function writeNode(state, level,
object, block, compact) {</p>

<pre><code>state.tag = null;
state.dump = object;

if (!detectType(state, object, false)) {
  detectType(state, object, true);
}

var type = _toString.call(state.dump);

if (block) {
  block = (0 &gt; state.flowLevel || state.flowLevel &gt; level);
}

if ((null !== state.tag &amp;&amp; &#39;?&#39; !== state.tag) || (2 !== state.indent &amp;&amp; level &gt; 0)) {
  compact = false;
}

var objectOrArray = &#39;[object Object]&#39; === type || &#39;[object Array]&#39; === type,
    duplicateIndex,
    duplicate;

if (objectOrArray) {
  duplicateIndex = state.duplicates.indexOf(object);
  duplicate = duplicateIndex !== -1;
}

if (duplicate &amp;&amp; state.usedDuplicates[duplicateIndex]) {
  state.dump = &#39;*ref_&#39; + duplicateIndex;
} else {
  if (objectOrArray &amp;&amp; duplicate &amp;&amp; !state.usedDuplicates[duplicateIndex]) {
    state.usedDuplicates[duplicateIndex] = true;
  }
  if (&#39;[object Object]&#39; === type) {
    if (block &amp;&amp; (0 !== Object.keys(state.dump).length)) {
      writeBlockMapping(state, level, state.dump, compact);
      if (duplicate) {
        state.dump = &#39;&amp;ref_&#39; + duplicateIndex + (0 === level ? &#39;\n&#39; : &#39;&#39;) + state.dump;
      }
    } else {
      writeFlowMapping(state, level, state.dump);
      if (duplicate) {
        state.dump = &#39;&amp;ref_&#39; + duplicateIndex + &#39; &#39; + state.dump;
      }
    }
  } else if (&#39;[object Array]&#39; === type) {
    if (block &amp;&amp; (0 !== state.dump.length)) {
      writeBlockSequence(state, level, state.dump, compact);
      if (duplicate) {
        state.dump = &#39;&amp;ref_&#39; + duplicateIndex + (0 === level ? &#39;\n&#39; : &#39;&#39;) + state.dump;
      }
    } else {
      writeFlowSequence(state, level, state.dump);
      if (duplicate) {
        state.dump = &#39;&amp;ref_&#39; + duplicateIndex + &#39; &#39; + state.dump;
      }
    }
  } else if (&#39;[object String]&#39; === type) {
    if (&#39;?&#39; !== state.tag) {
      writeScalar(state, state.dump);
    }
  } else if (state.skipInvalid) {
    return false;
  } else {
    throw new YAMLException(&#39;unacceptable kind of an object to dump &#39; + type);
  }

  if (null !== state.tag &amp;&amp; &#39;?&#39; !== state.tag) {
    state.dump = &#39;!&lt;&#39; + state.tag + &#39;&gt; &#39; + state.dump;
  }
}

return true;</code></pre>

<p>}</p>

<p>function getDuplicateReferences(object, state) {</p>

<pre><code>var objects = [],
    duplicatesIndexes = [],
    index,
    length;

inspectNode(object, objects, duplicatesIndexes);

for (index = 0, length = duplicatesIndexes.length; index &lt; length; index += 1) {
  state.duplicates.push(objects[duplicatesIndexes[index]]);
}
state.usedDuplicates = new Array(length);</code></pre>

<p>}</p>

<p>function inspectNode(object, objects, duplicatesIndexes) {</p>

<pre><code>var type = _toString.call(object),
    objectKeyList,
    index,
    length;

if (null !== object &amp;&amp; &#39;object&#39; === typeof object) {
  index = objects.indexOf(object);
  if (-1 !== index) {
    if (-1 === duplicatesIndexes.indexOf(index)) {
      duplicatesIndexes.push(index);
    }
  } else {
    objects.push(object);

    if(Array.isArray(object)) {
      for (index = 0, length = object.length; index &lt; length; index += 1) {
        inspectNode(object[index], objects, duplicatesIndexes);
      }
    } else {
      objectKeyList = Object.keys(object);

      for (index = 0, length = objectKeyList.length; index &lt; length; index += 1) {
        inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
      }
    }
  }
}</code></pre>

<p>}</p>

<p>function dump(input, options) {</p>

<pre><code>options = options || {};

var state = new State(options);

getDuplicateReferences(input, state);

if (writeNode(state, 0, input, true, true)) {
  return state.dump + &#39;\n&#39;;
} else {
  return &#39;&#39;;
}</code></pre>

<p>}</p>

<p>function safeDump(input, options) {</p>

<pre><code>return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
</code></pre>

<p>}</p>

<p>module.exports.dump     = dump; module.exports.safeDump = safeDump;</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
