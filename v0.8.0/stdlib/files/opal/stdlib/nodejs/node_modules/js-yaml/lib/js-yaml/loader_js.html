<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>loader.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            loader.js
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/js-yaml/lib/js-yaml/loader.js</li>
            <li>Last modified: 2015-08-19 01:14:21 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>&#39;use strict&#39;;</p>

<p>var common              = require(&#39;./common&#39;); var YAMLException   
= require(&#39;./exception&#39;); var Mark                =
require(&#39;./mark&#39;); var DEFAULT_SAFE_SCHEMA =
require(&#39;./schema/default_safe&#39;); var DEFAULT_FULL_SCHEMA =
require(&#39;./schema/default_full&#39;);</p>

<p>var _hasOwnProperty = Object.prototype.hasOwnProperty;</p>

<p>var CONTEXT_FLOW_IN   = 1; var CONTEXT_FLOW_OUT  = 2; var CONTEXT_BLOCK_IN 
= 3; var CONTEXT_BLOCK_OUT = 4;</p>

<p>var CHOMPING_CLIP  = 1; var CHOMPING_STRIP = 2; var CHOMPING_KEEP  = 3;</p>

<p>var PATTERN_NON_PRINTABLE         =
/[x00-x08x0Bx0Cx0E-x1Fx7F-x84x86-x9FuD800-uDFFFuFFFEuFFFF]/; var
PATTERN_NON_ASCII_LINE_BREAKS = /[x85u2028u2029]/; var
PATTERN_FLOW_INDICATORS       = /[,[]{}]/; var PATTERN_TAG_HANDLE          
= /^(?:!|!!|![a-z-]+!)$/i; var PATTERN_TAG_URI               =
/^(?:!|[^,[]{}])(?:%[0-9a-f]{2}|[<a
href="\">0-9a-z-#;/?:@&=+$,_.!~*‘()</a>])*$/i;</p>

<p>function is_EOL© {</p>

<pre><code>return (c === 0x0A   LF   ) || (c === 0x0D   CR   );</code></pre>

<p>}</p>

<p>function is_WHITE_SPACE© {</p>

<pre><code>return (c === 0x09/* Tab */) || (c === 0x20/* Space */);</code></pre>

<p>}</p>

<p>function is_WS_OR_EOL© {</p>

<pre><code>return (c === 0x09/* Tab */) ||
       (c === 0x20/* Space */) ||
       (c === 0x0A/* LF */) ||
       (c === 0x0D/* CR */);</code></pre>

<p>}</p>

<p>function is_FLOW_INDICATOR© {</p>

<pre><code>return 0x2C/* , */ === c ||
       0x5B/* [ */ === c ||
       0x5D/* ] */ === c ||
       0x7B/* { */ === c ||
       0x7D/* } */ === c;</code></pre>

<p>}</p>

<p>function fromHexCode© {</p>

<pre><code>var lc;

if ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x39/* 9 */)) {
  return c - 0x30;
}

lc = c | 0x20;
if ((0x61/* a */ &lt;= lc) &amp;&amp; (lc &lt;= 0x66/* f */)) {
  return lc - 0x61 + 10;
}

return -1;</code></pre>

<p>}</p>

<p>function escapedHexLen© {</p>

<pre><code>if (c === 0x78/* x */) { return 2; }
if (c === 0x75/* u */) { return 4; }
if (c === 0x55/* U */) { return 8; }
return 0;</code></pre>

<p>}</p>

<p>function fromDecimalCode© {</p>

<pre><code>if ((0x30/* 0 */ &lt;= c) &amp;&amp; (c &lt;= 0x39/* 9 */)) {
  return c - 0x30;
}

return -1;</code></pre>

<p>}</p>

<p>function simpleEscapeSequence© {</p>

<pre><code>return (c === 0x30/* 0 */) ? &#39;\x00&#39; :
       (c === 0x61/* a */) ? &#39;\x07&#39; :
       (c === 0x62/* b */) ? &#39;\x08&#39; :
       (c === 0x74/* t */) ? &#39;\x09&#39; :
       (c === 0x09/* Tab */) ? &#39;\x09&#39; :
       (c === 0x6E/* n */) ? &#39;\x0A&#39; :
       (c === 0x76/* v */) ? &#39;\x0B&#39; :
       (c === 0x66/* f */) ? &#39;\x0C&#39; :
       (c === 0x72/* r */) ? &#39;\x0D&#39; :
       (c === 0x65/* e */) ? &#39;\x1B&#39; :
       (c === 0x20/* Space */) ? &#39; &#39; :
       (c === 0x22/* &quot; */) ? &#39;\x22&#39; :
       (c === 0x2F/* / */) ? &#39;/&#39; :
       (c === 0x5C/* \ */) ? &#39;\x5C&#39; :
       (c === 0x4E/* N */) ? &#39;\x85&#39; :
       (c === 0x5F/* _ */) ? &#39;\xA0&#39; :
       (c === 0x4C/* L */) ? &#39;\u2028&#39; :
       (c === 0x50/* P */) ? &#39;\u2029&#39; : &#39;&#39;;</code></pre>

<p>}</p>

<p>function charFromCodepoint© {</p>

<pre><code>if (c &lt;= 0xFFFF) {
  return String.fromCharCode(c);
} else {
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(((c - 0x010000) &gt;&gt; 10) + 0xD800,
                             ((c - 0x010000) &amp; 0x03FF) + 0xDC00);
}</code></pre>

<p>}</p>

<p>var simpleEscapeCheck = new Array(256); // integer, for fast access var
simpleEscapeMap = new Array(256); for (var i = 0; i &lt; 256; i++) {</p>

<pre><code>simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
simpleEscapeMap[i] = simpleEscapeSequence(i);
</code></pre>

<p>}</p>

<p>function State(input, options) {</p>

<pre><code>this.input = input;

this.filename  = options[&#39;filename&#39;]  || null;
this.schema    = options[&#39;schema&#39;]    || DEFAULT_FULL_SCHEMA;
this.onWarning = options[&#39;onWarning&#39;] || null;
this.legacy    = options[&#39;legacy&#39;]    || false;

this.implicitTypes = this.schema.compiledImplicit;
this.typeMap       = this.schema.compiledTypeMap;

this.length     = input.length;
this.position   = 0;
this.line       = 0;
this.lineStart  = 0;
this.lineIndent = 0;

this.documents = [];

/*
this.version;
this.checkLineBreaks;
this.tagMap;
this.anchorMap;
this.tag;
this.anchor;
this.kind;
this.result;*/</code></pre>

<p>}</p>

<p>function generateError(state, message) {</p>

<pre><code>return new YAMLException(
  message,
  new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));</code></pre>

<p>}</p>

<p>function throwError(state, message) {</p>

<pre><code>throw generateError(state, message);
</code></pre>

<p>}</p>

<p>function throwWarning(state, message) {</p>

<pre><code>var error = generateError(state, message);

if (state.onWarning) {
  state.onWarning.call(null, error);
} else {
  throw error;
}</code></pre>

<p>}</p>

<p>var directiveHandlers = {</p>

<pre><code>&#39;YAML&#39;: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (null !== state.version) {
      throwError(state, &#39;duplication of %YAML directive&#39;);
    }

    if (1 !== args.length) {
      throwError(state, &#39;YAML directive accepts exactly one argument&#39;);
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (null === match) {
      throwError(state, &#39;ill-formed argument of the YAML directive&#39;);
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (1 !== major) {
      throwError(state, &#39;unacceptable YAML version of the document&#39;);
    }

    state.version = args[0];
    state.checkLineBreaks = (minor &lt; 2);

    if (1 !== minor &amp;&amp; 2 !== minor) {
      throwWarning(state, &#39;unsupported YAML version of the document&#39;);
    }
  },

&#39;TAG&#39;: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (2 !== args.length) {
      throwError(state, &#39;TAG directive accepts exactly two arguments&#39;);
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, &#39;ill-formed tag handle (first argument) of the TAG directive&#39;);
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, &#39;there is a previously declared suffix for &quot;&#39; + handle + &#39;&quot; tag handle&#39;);
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, &#39;ill-formed tag prefix (second argument) of the TAG directive&#39;);
    }

    state.tagMap[handle] = prefix;
  }</code></pre>

<p>};</p>

<p>function captureSegment(state, start, end, checkJson) {</p>

<pre><code>var _position, _length, _character, _result;

if (start &lt; end) {
  _result = state.input.slice(start, end);

  if (checkJson) {
    for (_position = 0, _length = _result.length;
         _position &lt; _length;
         _position += 1) {
      _character = _result.charCodeAt(_position);
      if (!(0x09 === _character ||
            0x20 &lt;= _character &amp;&amp; _character &lt;= 0x10FFFF)) {
        throwError(state, &#39;expected valid JSON character&#39;);
      }
    }
  }

  state.result += _result;
}</code></pre>

<p>}</p>

<p>function mergeMappings(state, destination, source) {</p>

<pre><code>var sourceKeys, key, index, quantity;

if (!common.isObject(source)) {
  throwError(state, &#39;cannot merge mappings; the provided source object is unacceptable&#39;);
}

sourceKeys = Object.keys(source);

for (index = 0, quantity = sourceKeys.length; index &lt; quantity; index += 1) {
  key = sourceKeys[index];

  if (!_hasOwnProperty.call(destination, key)) {
    destination[key] = source[key];
  }
}</code></pre>

<p>}</p>

<p>function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {</p>

<pre><code>var index, quantity;

keyNode = String(keyNode);

if (null === _result) {
  _result = {};
}

if (&#39;tag:yaml.org,2002:merge&#39; === keyTag) {
  if (Array.isArray(valueNode)) {
    for (index = 0, quantity = valueNode.length; index &lt; quantity; index += 1) {
      mergeMappings(state, _result, valueNode[index]);
    }
  } else {
    mergeMappings(state, _result, valueNode);
  }
} else {
  _result[keyNode] = valueNode;
}

return _result;</code></pre>

<p>}</p>

<p>function readLineBreak(state) {</p>

<pre><code>var ch;

ch = state.input.charCodeAt(state.position);

if (0x0A/* LF */ === ch) {
  state.position++;
} else if (0x0D/* CR */ === ch) {
  state.position++;
  if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
    state.position++;
  }
} else {
  throwError(state, &#39;a line break is expected&#39;);
}

state.line += 1;
state.lineStart = state.position;</code></pre>

<p>}</p>

<p>function skipSeparationSpace(state, allowComments, checkIndent) {</p>

<pre><code>var lineBreaks = 0,
    ch = state.input.charCodeAt(state.position);

while (0 !== ch) {
  while (is_WHITE_SPACE(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (allowComments &amp;&amp; 0x23/* # */ === ch) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0x0A/* LF */ &amp;&amp; ch !== 0x0D/* CR */ &amp;&amp; 0 !== ch);
  }

  if (is_EOL(ch)) {
    readLineBreak(state);

    ch = state.input.charCodeAt(state.position);
    lineBreaks++;
    state.lineIndent = 0;

    while (0x20/* Space */ === ch) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
  } else {
    break;
  }
}

if (-1 !== checkIndent &amp;&amp; 0 !== lineBreaks &amp;&amp; state.lineIndent &lt; checkIndent) {
  throwWarning(state, &#39;deficient indentation&#39;);
}

return lineBreaks;</code></pre>

<p>}</p>

<p>function testDocumentSeparator(state) {</p>

<pre><code>var _position = state.position,
    ch;

ch = state.input.charCodeAt(_position);

// Condition state.position === state.lineStart is tested
// in parent on each call, for efficiency. No needs to test here again.
if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &amp;&amp;
    state.input.charCodeAt(_position + 1) === ch &amp;&amp;
    state.input.charCodeAt(_position+ 2) === ch) {

  _position += 3;

  ch = state.input.charCodeAt(_position);

  if (ch === 0 || is_WS_OR_EOL(ch)) {
    return true;
  }
}

return false;</code></pre>

<p>}</p>

<p>function writeFoldedLines(state, count) {</p>

<pre><code>if (1 === count) {
  state.result += &#39; &#39;;
} else if (count &gt; 1) {
  state.result += common.repeat(&#39;\n&#39;, count - 1);
}</code></pre>

<p>}</p>

<p>function readPlainScalar(state, nodeIndent, withinFlowCollection) {</p>

<pre><code>var preceding,
    following,
    captureStart,
    captureEnd,
    hasPendingContent,
    _line,
    _lineStart,
    _lineIndent,
    _kind = state.kind,
    _result = state.result,
    ch;

ch = state.input.charCodeAt(state.position);

if (is_WS_OR_EOL(ch)             ||
    is_FLOW_INDICATOR(ch)        ||
    0x23/* # */           === ch ||
    0x26/* &amp; */           === ch ||
    0x2A/* * */           === ch ||
    0x21/* ! */           === ch ||
    0x7C/* | */           === ch ||
    0x3E/* &gt; */           === ch ||
    0x27/* &#39; */           === ch ||
    0x22/* &quot; */           === ch ||
    0x25/* % */           === ch ||
    0x40/* @ */           === ch ||
    0x60/* ` */           === ch) {
  return false;
}

if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
  following = state.input.charCodeAt(state.position + 1);

  if (is_WS_OR_EOL(following) ||
      withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {
    return false;
  }
}

state.kind = &#39;scalar&#39;;
state.result = &#39;&#39;;
captureStart = captureEnd = state.position;
hasPendingContent = false;

while (0 !== ch) {
  if (0x3A/* : */ === ch) {
    following = state.input.charCodeAt(state.position+1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {
      break;
    }

  } else if (0x23/* # */ === ch) {
    preceding = state.input.charCodeAt(state.position - 1);

    if (is_WS_OR_EOL(preceding)) {
      break;
    }

  } else if ((state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) ||
             withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(ch)) {
    break;

  } else if (is_EOL(ch)) {
    _line = state.line;
    _lineStart = state.lineStart;
    _lineIndent = state.lineIndent;
    skipSeparationSpace(state, false, -1);

    if (state.lineIndent &gt;= nodeIndent) {
      hasPendingContent = true;
      ch = state.input.charCodeAt(state.position);
      continue;
    } else {
      state.position = captureEnd;
      state.line = _line;
      state.lineStart = _lineStart;
      state.lineIndent = _lineIndent;
      break;
    }
  }

  if (hasPendingContent) {
    captureSegment(state, captureStart, captureEnd, false);
    writeFoldedLines(state, state.line - _line);
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
  }

  if (!is_WHITE_SPACE(ch)) {
    captureEnd = state.position + 1;
  }

  ch = state.input.charCodeAt(++state.position);
}

captureSegment(state, captureStart, captureEnd, false);

if (state.result) {
  return true;
} else {
  state.kind = _kind;
  state.result = _result;
  return false;
}</code></pre>

<p>}</p>

<p>function readSingleQuotedScalar(state, nodeIndent) {</p>

<pre><code>var ch,
    captureStart, captureEnd;

ch = state.input.charCodeAt(state.position);

if (0x27/* &#39; */ !== ch) {
  return false;
}

state.kind = &#39;scalar&#39;;
state.result = &#39;&#39;;
state.position++;
captureStart = captureEnd = state.position;

while (0 !== (ch = state.input.charCodeAt(state.position))) {
  if (0x27/* &#39; */ === ch) {
    captureSegment(state, captureStart, state.position, true);
    ch = state.input.charCodeAt(++state.position);

    if (0x27/* &#39; */ === ch) {
      captureStart = captureEnd = state.position;
      state.position++;
    } else {
      return true;
    }

  } else if (is_EOL(ch)) {
    captureSegment(state, captureStart, captureEnd, true);
    writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
    captureStart = captureEnd = state.position;

  } else if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {
    throwError(state, &#39;unexpected end of the document within a single quoted scalar&#39;);

  } else {
    state.position++;
    captureEnd = state.position;
  }
}

throwError(state, &#39;unexpected end of the stream within a single quoted scalar&#39;);</code></pre>

<p>}</p>

<p>function readDoubleQuotedScalar(state, nodeIndent) {</p>

<pre><code>var captureStart,
    captureEnd,
    hexLength,
    hexResult,
    tmp, tmpEsc,
    ch;

ch = state.input.charCodeAt(state.position);

if (0x22/* &quot; */ !== ch) {
  return false;
}

state.kind = &#39;scalar&#39;;
state.result = &#39;&#39;;
state.position++;
captureStart = captureEnd = state.position;

while (0 !== (ch = state.input.charCodeAt(state.position))) {
  if (0x22/* &quot; */ === ch) {
    captureSegment(state, captureStart, state.position, true);
    state.position++;
    return true;

  } else if (0x5C/* \ */ === ch) {
    captureSegment(state, captureStart, state.position, true);
    ch = state.input.charCodeAt(++state.position);

    if (is_EOL(ch)) {
      skipSeparationSpace(state, false, nodeIndent);

      //TODO: rework to inline fn with no type cast?
    } else if (ch &lt; 256 &amp;&amp; simpleEscapeCheck[ch]) {
      state.result += simpleEscapeMap[ch];
      state.position++;

    } else if ((tmp = escapedHexLen(ch)) &gt; 0) {
      hexLength = tmp;
      hexResult = 0;

      for (; hexLength &gt; 0; hexLength--) {
        ch = state.input.charCodeAt(++state.position);

        if ((tmp = fromHexCode(ch)) &gt;= 0) {
          hexResult = (hexResult &lt;&lt; 4) + tmp;

        } else {
          throwError(state, &#39;expected hexadecimal character&#39;);
        }
      }

      state.result += charFromCodepoint(hexResult);

      state.position++;

    } else {
      throwError(state, &#39;unknown escape sequence&#39;);
    }

    captureStart = captureEnd = state.position;

  } else if (is_EOL(ch)) {
    captureSegment(state, captureStart, captureEnd, true);
    writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
    captureStart = captureEnd = state.position;

  } else if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {
    throwError(state, &#39;unexpected end of the document within a double quoted scalar&#39;);

  } else {
    state.position++;
    captureEnd = state.position;
  }
}

throwError(state, &#39;unexpected end of the stream within a double quoted scalar&#39;);</code></pre>

<p>}</p>

<p>function readFlowCollection(state, nodeIndent) {</p>

<pre><code>var readNext = true,
    _line,
    _tag     = state.tag,
    _result,
    _anchor  = state.anchor,
    following,
    terminator,
    isPair,
    isExplicitPair,
    isMapping,
    keyNode,
    keyTag,
    valueNode,
    ch;

ch = state.input.charCodeAt(state.position);

if (ch === 0x5B/* [ */) {
  terminator = 0x5D/* ] */;
  isMapping = false;
  _result = [];
} else if (ch === 0x7B/* { */) {
  terminator = 0x7D/* } */;
  isMapping = true;
  _result = {};
} else {
  return false;
}

if (null !== state.anchor) {
  state.anchorMap[state.anchor] = _result;
}

ch = state.input.charCodeAt(++state.position);

while (0 !== ch) {
  skipSeparationSpace(state, true, nodeIndent);

  ch = state.input.charCodeAt(state.position);

  if (ch === terminator) {
    state.position++;
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = isMapping ? &#39;mapping&#39; : &#39;sequence&#39;;
    state.result = _result;
    return true;
  } else if (!readNext) {
    throwError(state, &#39;missed comma between flow collection entries&#39;);
  }

  keyTag = keyNode = valueNode = null;
  isPair = isExplicitPair = false;

  if (0x3F/* ? */ === ch) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following)) {
      isPair = isExplicitPair = true;
      state.position++;
      skipSeparationSpace(state, true, nodeIndent);
    }
  }

  _line = state.line;
  composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
  keyTag = state.tag;
  keyNode = state.result;
  skipSeparationSpace(state, true, nodeIndent);

  ch = state.input.charCodeAt(state.position);

  if ((isExplicitPair || state.line === _line) &amp;&amp; 0x3A/* : */ === ch) {
    isPair = true;
    ch = state.input.charCodeAt(++state.position);
    skipSeparationSpace(state, true, nodeIndent);
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    valueNode = state.result;
  }

  if (isMapping) {
    storeMappingPair(state, _result, keyTag, keyNode, valueNode);
  } else if (isPair) {
    _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
  } else {
    _result.push(keyNode);
  }

  skipSeparationSpace(state, true, nodeIndent);

  ch = state.input.charCodeAt(state.position);

  if (0x2C/* , */ === ch) {
    readNext = true;
    ch = state.input.charCodeAt(++state.position);
  } else {
    readNext = false;
  }
}

throwError(state, &#39;unexpected end of the stream within a flow collection&#39;);</code></pre>

<p>}</p>

<p>function readBlockScalar(state, nodeIndent) {</p>

<pre><code>var captureStart,
    folding,
    chomping       = CHOMPING_CLIP,
    detectedIndent = false,
    textIndent     = nodeIndent,
    emptyLines     = 0,
    atMoreIndented = false,
    tmp,
    ch;

ch = state.input.charCodeAt(state.position);

if (ch === 0x7C/* | */) {
  folding = false;
} else if (ch === 0x3E/* &gt; */) {
  folding = true;
} else {
  return false;
}

state.kind = &#39;scalar&#39;;
state.result = &#39;&#39;;

while (0 !== ch) {
  ch = state.input.charCodeAt(++state.position);

  if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
    if (CHOMPING_CLIP === chomping) {
      chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
    } else {
      throwError(state, &#39;repeat of a chomping mode identifier&#39;);
    }

  } else if ((tmp = fromDecimalCode(ch)) &gt;= 0) {
    if (tmp === 0) {
      throwError(state, &#39;bad explicit indentation width of a block scalar; it cannot be less than one&#39;);
    } else if (!detectedIndent) {
      textIndent = nodeIndent + tmp - 1;
      detectedIndent = true;
    } else {
      throwError(state, &#39;repeat of an indentation width identifier&#39;);
    }

  } else {
    break;
  }
}

if (is_WHITE_SPACE(ch)) {
  do { ch = state.input.charCodeAt(++state.position); }
  while (is_WHITE_SPACE(ch));

  if (0x23/* # */ === ch) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (!is_EOL(ch) &amp;&amp; (0 !== ch));
  }
}

while (0 !== ch) {
  readLineBreak(state);
  state.lineIndent = 0;

  ch = state.input.charCodeAt(state.position);

  while ((!detectedIndent || state.lineIndent &lt; textIndent) &amp;&amp;
         (0x20/* Space */ === ch)) {
    state.lineIndent++;
    ch = state.input.charCodeAt(++state.position);
  }

  if (!detectedIndent &amp;&amp; state.lineIndent &gt; textIndent) {
    textIndent = state.lineIndent;
  }

  if (is_EOL(ch)) {
    emptyLines++;
    continue;
  }

  // End of the scalar.
  if (state.lineIndent &lt; textIndent) {

    // Perform the chomping.
    if (chomping === CHOMPING_KEEP) {
      state.result += common.repeat(&#39;\n&#39;, emptyLines);
    } else if (chomping === CHOMPING_CLIP) {
      if (detectedIndent) { // i.e. only if the scalar is not empty.
        state.result += &#39;\n&#39;;
      }
    }

    // Break this `while` cycle and go to the funciton&#39;s epilogue.
    break;
  }

  // Folded style: use fancy rules to handle line breaks.
  if (folding) {

    // Lines starting with white space characters (more-indented lines) are not folded.
    if (is_WHITE_SPACE(ch)) {
      atMoreIndented = true;
      state.result += common.repeat(&#39;\n&#39;, emptyLines + 1);

    // End of more-indented block.
    } else if (atMoreIndented) {
      atMoreIndented = false;
      state.result += common.repeat(&#39;\n&#39;, emptyLines + 1);

    // Just one line break - perceive as the same line.
    } else if (0 === emptyLines) {
      if (detectedIndent) { // i.e. only if we have already read some scalar content.
        state.result += &#39; &#39;;
      }

    // Several line breaks - perceive as different lines.
    } else {
      state.result += common.repeat(&#39;\n&#39;, emptyLines);
    }

  // Literal style: just add exact number of line breaks between content lines.
  } else {

    // If current line isn&#39;t the first one - count line break from the last content line.
    if (detectedIndent) {
      state.result += common.repeat(&#39;\n&#39;, emptyLines + 1);

    // In case of the first content line - count only empty lines.
    } else {
      state.result += common.repeat(&#39;\n&#39;, emptyLines);
    }
  }

  detectedIndent = true;
  emptyLines = 0;
  captureStart = state.position;

  while (!is_EOL(ch) &amp;&amp; (0 !== ch))
  { ch = state.input.charCodeAt(++state.position); }

  captureSegment(state, captureStart, state.position, false);
}

return true;</code></pre>

<p>}</p>

<p>function readBlockSequence(state, nodeIndent) {</p>

<pre><code>var _line,
    _tag      = state.tag,
    _anchor   = state.anchor,
    _result   = [],
    following,
    detected  = false,
    ch;

if (null !== state.anchor) {
  state.anchorMap[state.anchor] = _result;
}

ch = state.input.charCodeAt(state.position);

while (0 !== ch) {

  if (0x2D/* - */ !== ch) {
    break;
  }

  following = state.input.charCodeAt(state.position + 1);

  if (!is_WS_OR_EOL(following)) {
    break;
  }

  detected = true;
  state.position++;

  if (skipSeparationSpace(state, true, -1)) {
    if (state.lineIndent &lt;= nodeIndent) {
      _result.push(null);
      ch = state.input.charCodeAt(state.position);
      continue;
    }
  }

  _line = state.line;
  composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
  _result.push(state.result);
  skipSeparationSpace(state, true, -1);

  ch = state.input.charCodeAt(state.position);

  if ((state.line === _line || state.lineIndent &gt; nodeIndent) &amp;&amp; (0 !== ch)) {
    throwError(state, &#39;bad indentation of a sequence entry&#39;);
  } else if (state.lineIndent &lt; nodeIndent) {
    break;
  }
}

if (detected) {
  state.tag = _tag;
  state.anchor = _anchor;
  state.kind = &#39;sequence&#39;;
  state.result = _result;
  return true;
} else {
  return false;
}</code></pre>

<p>}</p>

<p>function readBlockMapping(state, nodeIndent, flowIndent) {</p>

<pre><code>var following,
    allowCompact,
    _line,
    _tag          = state.tag,
    _anchor       = state.anchor,
    _result       = {},
    keyTag        = null,
    keyNode       = null,
    valueNode     = null,
    atExplicitKey = false,
    detected      = false,
    ch;

if (null !== state.anchor) {
  state.anchorMap[state.anchor] = _result;
}

ch = state.input.charCodeAt(state.position);

while (0 !== ch) {
  following = state.input.charCodeAt(state.position + 1);
  _line = state.line; // Save the current line.

  //
  // Explicit notation case. There are two separate blocks:
  // first for the key (denoted by &quot;?&quot;) and second for the value (denoted by &quot;:&quot;)
  //
  if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) &amp;&amp; is_WS_OR_EOL(following)) {

    if (0x3F/* ? */ === ch) {
      if (atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, null);
        keyTag = keyNode = valueNode = null;
      }

      detected = true;
      atExplicitKey = true;
      allowCompact = true;

    } else if (atExplicitKey) {
      // i.e. 0x3A/* : */ === character after the explicit key.
      atExplicitKey = false;
      allowCompact = true;

    } else {
      throwError(state, &#39;incomplete explicit mapping pair; a key node is missed&#39;);
    }

    state.position += 1;
    ch = following;

  //
  // Implicit notation case. Flow-style node as the key first, then &quot;:&quot;, and the value.
  //
  } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

    if (state.line === _line) {
      ch = state.input.charCodeAt(state.position);

      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (0x3A/* : */ === ch) {
        ch = state.input.charCodeAt(++state.position);

        if (!is_WS_OR_EOL(ch)) {
          throwError(state, &#39;a whitespace character is expected after the key-value separator within a block mapping&#39;);
        }

        if (atExplicitKey) {
          storeMappingPair(state, _result, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = false;
        allowCompact = false;
        keyTag = state.tag;
        keyNode = state.result;

      } else if (detected) {
        throwError(state, &#39;can not read an implicit mapping pair; a colon is missed&#39;);

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else if (detected) {
      throwError(state, &#39;can not read a block mapping entry; a multiline key may not be an implicit key&#39;);

    } else {
      state.tag = _tag;
      state.anchor = _anchor;
      return true; // Keep the result of `composeNode`.
    }

  } else {
    break; // Reading is done. Go to the epilogue.
  }

  //
  // Common reading code for both explicit and implicit notations.
  //
  if (state.line === _line || state.lineIndent &gt; nodeIndent) {
    if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
      if (atExplicitKey) {
        keyNode = state.result;
      } else {
        valueNode = state.result;
      }
    }

    if (!atExplicitKey) {
      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
      keyTag = keyNode = valueNode = null;
    }

    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
  }

  if (state.lineIndent &gt; nodeIndent &amp;&amp; (0 !== ch)) {
    throwError(state, &#39;bad indentation of a mapping entry&#39;);
  } else if (state.lineIndent &lt; nodeIndent) {
    break;
  }
}

//
// Epilogue.
//

// Special case: last mapping&#39;s node contains only the key in explicit notation.
if (atExplicitKey) {
  storeMappingPair(state, _result, keyTag, keyNode, null);
}

// Expose the resulting mapping.
if (detected) {
  state.tag = _tag;
  state.anchor = _anchor;
  state.kind = &#39;mapping&#39;;
  state.result = _result;
}

return detected;</code></pre>

<p>}</p>

<p>function readTagProperty(state) {</p>

<pre><code>var _position,
    isVerbatim = false,
    isNamed    = false,
    tagHandle,
    tagName,
    ch;

ch = state.input.charCodeAt(state.position);

if (0x21/* ! */ !== ch) {
  return false;
}

if (null !== state.tag) {
  throwError(state, &#39;duplication of a tag property&#39;);
}

ch = state.input.charCodeAt(++state.position);

if (0x3C/* &lt; */ === ch) {
  isVerbatim = true;
  ch = state.input.charCodeAt(++state.position);

} else if (0x21/* ! */ === ch) {
  isNamed = true;
  tagHandle = &#39;!!&#39;;
  ch = state.input.charCodeAt(++state.position);

} else {
  tagHandle = &#39;!&#39;;
}

_position = state.position;

if (isVerbatim) {
  do { ch = state.input.charCodeAt(++state.position); }
  while (0 !== ch &amp;&amp; 0x3E/* &gt; */ !== ch);

  if (state.position &lt; state.length) {
    tagName = state.input.slice(_position, state.position);
    ch = state.input.charCodeAt(++state.position);
  } else {
    throwError(state, &#39;unexpected end of the stream within a verbatim tag&#39;);
  }
} else {
  while (0 !== ch &amp;&amp; !is_WS_OR_EOL(ch)) {

    if (0x21/* ! */ === ch) {
      if (!isNamed) {
        tagHandle = state.input.slice(_position - 1, state.position + 1);

        if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
          throwError(state, &#39;named tag handle cannot contain such characters&#39;);
        }

        isNamed = true;
        _position = state.position + 1;
      } else {
        throwError(state, &#39;tag suffix cannot contain exclamation marks&#39;);
      }
    }

    ch = state.input.charCodeAt(++state.position);
  }

  tagName = state.input.slice(_position, state.position);

  if (PATTERN_FLOW_INDICATORS.test(tagName)) {
    throwError(state, &#39;tag suffix cannot contain flow indicator characters&#39;);
  }
}

if (tagName &amp;&amp; !PATTERN_TAG_URI.test(tagName)) {
  throwError(state, &#39;tag name cannot contain such characters: &#39; + tagName);
}

if (isVerbatim) {
  state.tag = tagName;

} else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
  state.tag = state.tagMap[tagHandle] + tagName;

} else if (&#39;!&#39; === tagHandle) {
  state.tag = &#39;!&#39; + tagName;

} else if (&#39;!!&#39; === tagHandle) {
  state.tag = &#39;tag:yaml.org,2002:&#39; + tagName;

} else {
  throwError(state, &#39;undeclared tag handle &quot;&#39; + tagHandle + &#39;&quot;&#39;);
}

return true;</code></pre>

<p>}</p>

<p>function readAnchorProperty(state) {</p>

<pre><code>var _position,
    ch;

ch = state.input.charCodeAt(state.position);

if (0x26/* &amp; */ !== ch) {
  return false;
}

if (null !== state.anchor) {
  throwError(state, &#39;duplication of an anchor property&#39;);
}

ch = state.input.charCodeAt(++state.position);
_position = state.position;

while (0 !== ch &amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {
  ch = state.input.charCodeAt(++state.position);
}

if (state.position === _position) {
  throwError(state, &#39;name of an anchor node must contain at least one character&#39;);
}

state.anchor = state.input.slice(_position, state.position);
return true;</code></pre>

<p>}</p>

<p>function readAlias(state) {</p>

<pre><code>var _position, alias,
    len = state.length,
    input = state.input,
    ch;

ch = state.input.charCodeAt(state.position);

if (0x2A/* * */ !== ch) {
  return false;
}

ch = state.input.charCodeAt(++state.position);
_position = state.position;

while (0 !== ch &amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {
  ch = state.input.charCodeAt(++state.position);
}

if (state.position === _position) {
  throwError(state, &#39;name of an alias node must contain at least one character&#39;);
}

alias = state.input.slice(_position, state.position);

if (!state.anchorMap.hasOwnProperty(alias)) {
  throwError(state, &#39;unidentified alias &quot;&#39; + alias + &#39;&quot;&#39;);
}

state.result = state.anchorMap[alias];
skipSeparationSpace(state, true, -1);
return true;</code></pre>

<p>}</p>

<p>function composeNode(state, parentIndent, nodeContext, allowToSeek,
allowCompact) {</p>

<pre><code>var allowBlockStyles,
    allowBlockScalars,
    allowBlockCollections,
    indentStatus = 1, // 1: this&gt;parent, 0: this=parent, -1: this&lt;parent
    atNewLine  = false,
    hasContent = false,
    typeIndex,
    typeQuantity,
    type,
    flowIndent,
    blockIndent,
    _result;

state.tag    = null;
state.anchor = null;
state.kind   = null;
state.result = null;

allowBlockStyles = allowBlockScalars = allowBlockCollections =
  CONTEXT_BLOCK_OUT === nodeContext ||
  CONTEXT_BLOCK_IN  === nodeContext;

if (allowToSeek) {
  if (skipSeparationSpace(state, true, -1)) {
    atNewLine = true;

    if (state.lineIndent &gt; parentIndent) {
      indentStatus = 1;
    } else if (state.lineIndent === parentIndent) {
      indentStatus = 0;
    } else if (state.lineIndent &lt; parentIndent) {
      indentStatus = -1;
    }
  }
}

if (1 === indentStatus) {
  while (readTagProperty(state) || readAnchorProperty(state)) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      allowBlockCollections = allowBlockStyles;

      if (state.lineIndent &gt; parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent &lt; parentIndent) {
        indentStatus = -1;
      }
    } else {
      allowBlockCollections = false;
    }
  }
}

if (allowBlockCollections) {
  allowBlockCollections = atNewLine || allowCompact;
}

if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
  if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
    flowIndent = parentIndent;
  } else {
    flowIndent = parentIndent + 1;
  }

  blockIndent = state.position - state.lineStart;

  if (1 === indentStatus) {
    if (allowBlockCollections &amp;&amp;
        (readBlockSequence(state, blockIndent) ||
         readBlockMapping(state, blockIndent, flowIndent)) ||
        readFlowCollection(state, flowIndent)) {
      hasContent = true;
    } else {
      if ((allowBlockScalars &amp;&amp; readBlockScalar(state, flowIndent)) ||
          readSingleQuotedScalar(state, flowIndent) ||
          readDoubleQuotedScalar(state, flowIndent)) {
        hasContent = true;

      } else if (readAlias(state)) {
        hasContent = true;

        if (null !== state.tag || null !== state.anchor) {
          throwError(state, &#39;alias node should not have any properties&#39;);
        }

      } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
        hasContent = true;

        if (null === state.tag) {
          state.tag = &#39;?&#39;;
        }
      }

      if (null !== state.anchor) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  } else if (0 === indentStatus) {
    // Special case: block sequences are allowed to have same indentation level as the parent.
    // http://www.yaml.org/spec/1.2/spec.html#id2799784
    hasContent = allowBlockCollections &amp;&amp; readBlockSequence(state, blockIndent);
  }
}

if (null !== state.tag &amp;&amp; &#39;!&#39; !== state.tag) {
  if (&#39;?&#39; === state.tag) {
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
         typeIndex &lt; typeQuantity;
         typeIndex += 1) {
      type = state.implicitTypes[typeIndex];

      // Implicit resolving is not allowed for non-scalar types, and &#39;?&#39;
      // non-specific tag is only assigned to plain scalars. So, it isn&#39;t
      // needed to check for &#39;kind&#39; conformity.

      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
        state.result = type.construct(state.result);
        state.tag = type.tag;
        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
    type = state.typeMap[state.tag];

    if (null !== state.result &amp;&amp; type.kind !== state.kind) {
      throwError(state, &#39;unacceptable node kind for !&lt;&#39; + state.tag + &#39;&gt; tag; it should be &quot;&#39; + type.kind + &#39;&quot;, not &quot;&#39; + state.kind + &#39;&quot;&#39;);
    }

    if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
      throwError(state, &#39;cannot resolve a node with !&lt;&#39; + state.tag + &#39;&gt; explicit tag&#39;);
    } else {
      state.result = type.construct(state.result);
      if (null !== state.anchor) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  } else {
    throwWarning(state, &#39;unknown tag !&lt;&#39; + state.tag + &#39;&gt;&#39;);
  }
}

return null !== state.tag || null !== state.anchor || hasContent;</code></pre>

<p>}</p>

<p>function readDocument(state) {</p>

<pre><code>var documentStart = state.position,
    _position,
    directiveName,
    directiveArgs,
    hasDirectives = false,
    ch;

state.version = null;
state.checkLineBreaks = state.legacy;
state.tagMap = {};
state.anchorMap = {};

while (0 !== (ch = state.input.charCodeAt(state.position))) {
  skipSeparationSpace(state, true, -1);

  ch = state.input.charCodeAt(state.position);

  if (state.lineIndent &gt; 0 || 0x25/* % */ !== ch) {
    break;
  }

  hasDirectives = true;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch &amp;&amp; !is_WS_OR_EOL(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  directiveName = state.input.slice(_position, state.position);
  directiveArgs = [];

  if (directiveName.length &lt; 1) {
    throwError(state, &#39;directive name must not be less than one character in length&#39;);
  }

  while (0 !== ch) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (0x23/* # */ === ch) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (0 !== ch &amp;&amp; !is_EOL(ch));
      break;
    }

    if (is_EOL(ch)) {
      break;
    }

    _position = state.position;

    while (0 !== ch &amp;&amp; !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveArgs.push(state.input.slice(_position, state.position));
  }

  if (0 !== ch) {
    readLineBreak(state);
  }

  if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
    directiveHandlers[directiveName](state, directiveName, directiveArgs);
  } else {
    throwWarning(state, &#39;unknown document directive &quot;&#39; + directiveName + &#39;&quot;&#39;);
  }
}

skipSeparationSpace(state, true, -1);

if (0 === state.lineIndent &amp;&amp;
    0x2D/* - */ === state.input.charCodeAt(state.position) &amp;&amp;
    0x2D/* - */ === state.input.charCodeAt(state.position + 1) &amp;&amp;
    0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
  state.position += 3;
  skipSeparationSpace(state, true, -1);

} else if (hasDirectives) {
  throwError(state, &#39;directives end mark is expected&#39;);
}

composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
skipSeparationSpace(state, true, -1);

if (state.checkLineBreaks &amp;&amp;
    PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
  throwWarning(state, &#39;non-ASCII line breaks are interpreted as content&#39;);
}

state.documents.push(state.result);

if (state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {

  if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  }
  return;
}

if (state.position &lt; (state.length - 1)) {
  throwError(state, &#39;end of the stream or a document separator is expected&#39;);
} else {
  return;
}</code></pre>

<p>}</p>

<p>function loadDocuments(input, options) {</p>

<pre><code>input = String(input);
options = options || {};

if (0 !== input.length &amp;&amp;
    0x0A/* LF */ !== input.charCodeAt(input.length - 1) &amp;&amp;
    0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
  input += &#39;\n&#39;;
}

var state = new State(input, options);

if (PATTERN_NON_PRINTABLE.test(state.input)) {
  throwError(state, &#39;the stream contains non-printable characters&#39;);
}

// Use 0 as string terminator. That significantly simplifies bounds check.
state.input += &#39;\0&#39;;

while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
  state.lineIndent += 1;
  state.position += 1;
}

while (state.position &lt; (state.length - 1)) {
  readDocument(state);
}

return state.documents;</code></pre>

<p>}</p>

<p>function loadAll(input, iterator, options) {</p>

<pre><code>var documents = loadDocuments(input, options), index, length;

for (index = 0, length = documents.length; index &lt; length; index += 1) {
  iterator(documents[index]);
}</code></pre>

<p>}</p>

<p>function load(input, options) {</p>

<pre><code>var documents = loadDocuments(input, options), index, length;

if (0 === documents.length) {
  return undefined;
} else if (1 === documents.length) {
  return documents[0];
} else {
  throw new YAMLException(&#39;expected a single document in the stream, but found more&#39;);
}</code></pre>

<p>}</p>

<p>function safeLoadAll(input, output, options) {</p>

<pre><code>loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
</code></pre>

<p>}</p>

<p>function safeLoad(input, options) {</p>

<pre><code>return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
</code></pre>

<p>}</p>

<p>module.exports.loadAll     = loadAll; module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll; module.exports.safeLoad    =
safeLoad;</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
