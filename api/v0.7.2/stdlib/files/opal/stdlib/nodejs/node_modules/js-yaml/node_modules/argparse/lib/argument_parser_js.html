<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>argument_parser.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            argument_parser.js
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/js-yaml/node_modules/argparse/lib/argument_parser.js</li>
            <li>Last modified: 2015-08-29 16:13:52 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<pre><code>class ArgumentParser

Object for parsing command line strings into js objects.

Inherited from [[ActionContainer]]</code></pre>

<p>&#39;use strict&#39;;</p>

<p>var util    = require(&#39;util&#39;); var format  =
require(&#39;util&#39;).format; var Path    = require(&#39;path&#39;);</p>

<p>var _ = require(&#39;underscore&#39;); _.str =
require(&#39;underscore.string&#39;);</p>

<p>// Constants var $$ = require(&#39;./const&#39;);</p>

<p>var ActionContainer = require(&#39;./action_container&#39;);</p>

<p>// Errors var argumentErrorHelper = require(&#39;./argument/error&#39;);</p>

<p>var HelpFormatter = require(&#39;./help/formatter&#39;);</p>

<p>var Namespace = require(&#39;./namespace&#39;);</p>

<pre><code>new ArgumentParser(options)

Create a new ArgumentParser object.

##### Options:
- `prog`  The name of the program (default: Path.basename(process.argv[1]))
- `usage`  A usage message (default: auto-generated from arguments)
- `description`  A description of what the program does
- `epilog`  Text following the argument descriptions
- `parents`  Parsers whose arguments should be copied into this one
- `formatterClass`  HelpFormatter class for printing help messages
- `prefixChars`  Characters that prefix optional arguments
- `fromfilePrefixChars` Characters that prefix files containing additional arguments
- `argumentDefault`  The default value for all arguments
- `addHelp`  Add a -h/-help option
- `conflictHandler`  Specifies how to handle conflicting argument names
- `debug`  Enable debug mode. Argument errors throw exception in
  debug mode and process.exit in normal. Used for development and
  testing (default: false)

See also [original guide][1]

[1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects</code></pre>

<p>var ArgumentParser = module.exports = function ArgumentParser(options) {</p>

<pre><code>var self = this;
options = options || {};

options.description = (options.description || null);
options.argumentDefault = (options.argumentDefault || null);
options.prefixChars = (options.prefixChars || &#39;-&#39;);
options.conflictHandler = (options.conflictHandler || &#39;error&#39;);
ActionContainer.call(this, options);

options.addHelp = (options.addHelp === undefined || !!options.addHelp);
options.parents = (options.parents || []);
// default program name
options.prog = (options.prog || Path.basename(process.argv[1]));
this.prog = options.prog;
this.usage = options.usage;
this.epilog = options.epilog;
this.version = options.version;

this.debug = (options.debug === true);

this.formatterClass = (options.formatterClass || HelpFormatter);
this.fromfilePrefixChars = options.fromfilePrefixChars || null;
this._positionals = this.addArgumentGroup({title: &#39;Positional arguments&#39;});
this._optionals = this.addArgumentGroup({title: &#39;Optional arguments&#39;});
this._subparsers = null;

// register types
var FUNCTION_IDENTITY = function (o) {
  return o;
};
this.register(&#39;type&#39;, &#39;auto&#39;, FUNCTION_IDENTITY);
this.register(&#39;type&#39;, null, FUNCTION_IDENTITY);
this.register(&#39;type&#39;, &#39;int&#39;, function (x) {
  var result = parseInt(x, 10);
  if (isNaN(result)) {
    throw new Error(x + &#39; is not a valid integer.&#39;);
  }
  return result;
});
this.register(&#39;type&#39;, &#39;float&#39;, function (x) {
  var result = parseFloat(x);
  if (isNaN(result)) {
    throw new Error(x + &#39; is not a valid float.&#39;);
  }
  return result;
});
this.register(&#39;type&#39;, &#39;string&#39;, function (x) {
  return &#39;&#39; + x;
});

// add help and version arguments if necessary
var defaultPrefix = (this.prefixChars.indexOf(&#39;-&#39;) &gt; -1) ? &#39;-&#39; : this.prefixChars[0];
if (options.addHelp) {
  this.addArgument(
    [defaultPrefix + &#39;h&#39;, defaultPrefix + defaultPrefix + &#39;help&#39;],
    {
      action: &#39;help&#39;,
      defaultValue: $$.SUPPRESS,
      help: &#39;Show this help message and exit.&#39;
    }
  );
}
if (this.version !== undefined) {
  this.addArgument(
    [defaultPrefix + &#39;v&#39;, defaultPrefix + defaultPrefix + &#39;version&#39;],
    {
      action: &#39;version&#39;,
      version: this.version,
      defaultValue: $$.SUPPRESS,
      help: &quot;Show program&#39;s version number and exit.&quot;
    }
  );
}

// add parent arguments and defaults
options.parents.forEach(function (parent) {
  self._addContainerActions(parent);
  if (parent._defaults !== undefined) {
    for (var defaultKey in parent._defaults) {
      if (parent._defaults.hasOwnProperty(defaultKey)) {
        self._defaults[defaultKey] = parent._defaults[defaultKey];
      }
    }
  }
});</code></pre>

<p>}; util.inherits(ArgumentParser, ActionContainer);</p>

<p>/**</p>

<pre><code>ArgumentParser#addSubparsers(options) -&gt; [[ActionSubparsers]]
- options (object): hash of options see [[ActionSubparsers.new]]

See also [subcommands][1]

[1]:http://docs.python.org/dev/library/argparse.html#sub-commands
/</code></pre>

<p>ArgumentParser.prototype.addSubparsers = function (options) {</p>

<pre><code>if (!!this._subparsers) {
  this.error(&#39;Cannot have multiple subparser arguments.&#39;);
}

options = options || {};
options.debug = (this.debug === true);
options.optionStrings = [];
options.parserClass = (options.parserClass || ArgumentParser);

if (!!options.title || !!options.description) {

  this._subparsers = this.addArgumentGroup({
    title: (options.title || &#39;subcommands&#39;),
    description: options.description
  });
  delete options.title;
  delete options.description;

} else {
  this._subparsers = this._positionals;
}

// prog defaults to the usage message of this parser, skipping
// optional arguments and with no &quot;usage:&quot; prefix
if (!options.prog) {
  var formatter = this._getFormatter();
  var positionals = this._getPositionalActions();
  var groups = this._mutuallyExclusiveGroups;
  formatter.addUsage(this.usage, positionals, groups, &#39;&#39;);
  options.prog = _.str.strip(formatter.formatHelp());
}

// create the parsers action and add it to the positionals list
var ParsersClass = this._popActionClass(options, &#39;parsers&#39;);
var action = new ParsersClass(options);
this._subparsers._addAction(action);

// return the created parsers action
return action;</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._addAction = function (action) {</p>

<pre><code>if (action.isOptional()) {
  this._optionals._addAction(action);
} else {
  this._positionals._addAction(action);
}
return action;</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._getOptionalActions = function () {</p>

<pre><code>return this._actions.filter(function (action) {
  return action.isOptional();
});
</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._getPositionalActions = function () {</p>

<pre><code>return this._actions.filter(function (action) {
  return action.isPositional();
});
</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>ArgumentParser#parseArgs(args, namespace) -&gt; Namespace|Object
- args (array): input elements
- namespace (Namespace|Object): result object

Parsed args and throws error if some arguments are not recognized

See also [original guide][1]

[1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method
/</code></pre>

<p>ArgumentParser.prototype.parseArgs = function (args, namespace) {</p>

<pre><code>var argv;
var result = this.parseKnownArgs(args, namespace);

args = result[0];
argv = result[1];
if (argv &amp;&amp; argv.length &gt; 0) {
  this.error(
    format(&#39;Unrecognized arguments: %s.&#39;, argv.join(&#39; &#39;))
  );
}
return args;</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>ArgumentParser#parseKnownArgs(args, namespace) -&gt; array
- args (array): input options
- namespace (Namespace|Object): result object

Parse known arguments and return tuple of result object
and unknown args

See also [original guide][1]

[1]:http://docs.python.org/dev/library/argparse.html#partial-parsing
/</code></pre>

<p>ArgumentParser.prototype.parseKnownArgs = function (args, namespace) {</p>

<pre><code>var self = this;

// args default to the system args
args = args || process.argv.slice(2);

// default Namespace built from parser defaults
namespace = namespace || new Namespace();

self._actions.forEach(function (action) {
  if (action.dest !== $$.SUPPRESS) {
    if (!_.has(namespace, action.dest)) {
      if (action.defaultValue !== $$.SUPPRESS) {
        var defaultValue = action.defaultValue;
        if (_.isString(action.defaultValue)) {
          defaultValue = self._getValue(action, defaultValue);
        }
        namespace[action.dest] = defaultValue;
      }
    }
  }
});

_.keys(self._defaults).forEach(function (dest) {
  namespace[dest] = self._defaults[dest];
});

// parse the arguments and exit if there are any errors
try {
  var res = this._parseKnownArgs(args, namespace);

  namespace = res[0];
  args = res[1];
  if (_.has(namespace, $$._UNRECOGNIZED_ARGS_ATTR)) {
    args = _.union(args, namespace[$$._UNRECOGNIZED_ARGS_ATTR]);
    delete namespace[$$._UNRECOGNIZED_ARGS_ATTR];
  }
  return [namespace, args];
} catch (e) {
  this.error(e);
}</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._parseKnownArgs = function (argStrings, namespace)
{</p>

<pre><code>var self = this;

var extras = [];

// replace arg strings that are file references
if (this.fromfilePrefixChars !== null) {
  argStrings = this._readArgsFromFiles(argStrings);
}
// map all mutually exclusive arguments to the other arguments
// they can&#39;t occur with
// Python has &#39;conflicts = action_conflicts.setdefault(mutex_action, [])&#39;
// though I can&#39;t conceive of a way in which an action could be a member
// of two different mutually exclusive groups.

function actionHash(action) {
  // some sort of hashable key for this action
  // action itself cannot be a key in actionConflicts
  // I think getName() (join of optionStrings) is unique enough
  return action.getName();
}

var conflicts, key;
var actionConflicts = {};

this._mutuallyExclusiveGroups.forEach(function (mutexGroup) {
  mutexGroup._groupActions.forEach(function (mutexAction, i, groupActions) {
    key = actionHash(mutexAction);
    if (!_.has(actionConflicts, key)) {
      actionConflicts[key] = [];
    }
    conflicts = actionConflicts[key];
    conflicts.push.apply(conflicts, groupActions.slice(0, i));
    conflicts.push.apply(conflicts, groupActions.slice(i + 1));
  });
});

// find all option indices, and determine the arg_string_pattern
// which has an &#39;O&#39; if there is an option at an index,
// an &#39;A&#39; if there is an argument, or a &#39;-&#39; if there is a &#39;--&#39;
var optionStringIndices = {};

var argStringPatternParts = [];

argStrings.forEach(function (argString, argStringIndex) {
  if (argString === &#39;--&#39;) {
    argStringPatternParts.push(&#39;-&#39;);
    while (argStringIndex &lt; argStrings.length) {
      argStringPatternParts.push(&#39;A&#39;);
      argStringIndex++;
    }
  }
  // otherwise, add the arg to the arg strings
  // and note the index if it was an option
  else {
    var pattern;
    var optionTuple = self._parseOptional(argString);
    if (!optionTuple) {
      pattern = &#39;A&#39;;
    }
    else {
      optionStringIndices[argStringIndex] = optionTuple;
      pattern = &#39;O&#39;;
    }
    argStringPatternParts.push(pattern);
  }
});
var argStringsPattern = argStringPatternParts.join(&#39;&#39;);

var seenActions = [];
var seenNonDefaultActions = [];

function takeAction(action, argumentStrings, optionString) {
  seenActions.push(action);
  var argumentValues = self._getValues(action, argumentStrings);

  // error if this argument is not allowed with other previously
  // seen arguments, assuming that actions that use the default
  // value don&#39;t really count as &quot;present&quot;
  if (argumentValues !== action.defaultValue) {
    seenNonDefaultActions.push(action);
    if (!!actionConflicts[actionHash(action)]) {
      actionConflicts[actionHash(action)].forEach(function (actionConflict) {
        if (seenNonDefaultActions.indexOf(actionConflict) &gt;= 0) {
          throw argumentErrorHelper(
            action,
            format(&#39;Not allowed with argument &quot;%s&quot;.&#39;, actionConflict.getName())
          );
        }
      });
    }
  }

  if (argumentValues !== $$.SUPPRESS) {
    action.call(self, namespace, argumentValues, optionString);
  }
}

function consumeOptional(startIndex) {
  // get the optional identified at this index
  var optionTuple = optionStringIndices[startIndex];
  var action = optionTuple[0];
  var optionString = optionTuple[1];
  var explicitArg = optionTuple[2];

  // identify additional optionals in the same arg string
  // (e.g. -xyz is the same as -x -y -z if no args are required)
  var actionTuples = [];

  var args, argCount, start, stop;

  while (true) {
    if (!action) {
      extras.push(argStrings[startIndex]);
      return startIndex + 1;
    }
    if (!!explicitArg) {
      argCount = self._matchArgument(action, &#39;A&#39;);

      // if the action is a single-dash option and takes no
      // arguments, try to parse more single-dash options out
      // of the tail of the option string
      var chars = self.prefixChars;
      if (argCount === 0 &amp;&amp; chars.indexOf(optionString[1]) &lt; 0) {
        actionTuples.push([action, [], optionString]);
        optionString = optionString[0] + explicitArg[0];
        var newExplicitArg = explicitArg.slice(1) || null;
        var optionalsMap = self._optionStringActions;

        if (_.keys(optionalsMap).indexOf(optionString) &gt;= 0) {
          action = optionalsMap[optionString];
          explicitArg = newExplicitArg;
        }
        else {
          var msg = &#39;ignored explicit argument %r&#39;;
          throw argumentErrorHelper(action, msg);
        }
      }
      // if the action expect exactly one argument, we&#39;ve
      // successfully matched the option; exit the loop
      else if (argCount === 1) {
        stop = startIndex + 1;
        args = [explicitArg];
        actionTuples.push([action, args, optionString]);
        break;
      }
      // error if a double-dash option did not use the
      // explicit argument
      else {
        var message = &#39;ignored explicit argument %r&#39;;
        throw argumentErrorHelper(action, _.str.sprintf(message, explicitArg));
      }
    }
    // if there is no explicit argument, try to match the
    // optional&#39;s string arguments with the following strings
    // if successful, exit the loop
    else {

      start = startIndex + 1;
      var selectedPatterns = argStringsPattern.substr(start);

      argCount = self._matchArgument(action, selectedPatterns);
      stop = start + argCount;

      args = argStrings.slice(start, stop);

      actionTuples.push([action, args, optionString]);
      break;
    }

  }

  // add the Optional to the list and return the index at which
  // the Optional&#39;s string args stopped
  if (actionTuples.length &lt; 1) {
    throw new Error(&#39;length should be &gt; 0&#39;);
  }
  for (var i = 0; i &lt; actionTuples.length; i++) {
    takeAction.apply(self, actionTuples[i]);
  }
  return stop;
}

// the list of Positionals left to be parsed; this is modified
// by consume_positionals()
var positionals = self._getPositionalActions();

function consumePositionals(startIndex) {
  // match as many Positionals as possible
  var selectedPattern = argStringsPattern.substr(startIndex);
  var argCounts = self._matchArgumentsPartial(positionals, selectedPattern);

  // slice off the appropriate arg strings for each Positional
  // and add the Positional and its args to the list
  _.zip(positionals, argCounts).forEach(function (item) {
      var action = item[0];
      var argCount = item[1];
      if (argCount === undefined) {
        return;
      }
      var args = argStrings.slice(startIndex, startIndex + argCount);

      startIndex += argCount;
      takeAction(action, args);
    });

  // slice off the Positionals that we just parsed and return the
  // index at which the Positionals&#39; string args stopped
  positionals = positionals.slice(argCounts.length);
  return startIndex;
}

// consume Positionals and Optionals alternately, until we have
// passed the last option string
var startIndex = 0;
var position;

var maxOptionStringIndex = -1;

Object.keys(optionStringIndices).forEach(function (position) {
  maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, 10));
});

var positionalsEndIndex, nextOptionStringIndex;

while (startIndex &lt;= maxOptionStringIndex) {
  // consume any Positionals preceding the next option
  nextOptionStringIndex = null;
  for (position in optionStringIndices) {
    if (!optionStringIndices.hasOwnProperty(position)) { continue; }

    position = parseInt(position, 10);
    if (position &gt;= startIndex) {
      if (nextOptionStringIndex !== null) {
        nextOptionStringIndex = Math.min(nextOptionStringIndex, position);
      }
      else {
        nextOptionStringIndex = position;
      }
    }
  }

  if (startIndex !== nextOptionStringIndex) {
    positionalsEndIndex = consumePositionals(startIndex);
    // only try to parse the next optional if we didn&#39;t consume
    // the option string during the positionals parsing
    if (positionalsEndIndex &gt; startIndex) {
      startIndex = positionalsEndIndex;
      continue;
    }
    else {
      startIndex = positionalsEndIndex;
    }
  }

  // if we consumed all the positionals we could and we&#39;re not
  // at the index of an option string, there were extra arguments
  if (!optionStringIndices[startIndex]) {
    var strings = argStrings.slice(startIndex, nextOptionStringIndex);
    extras = extras.concat(strings);
    startIndex = nextOptionStringIndex;
  }
  // consume the next optional and any arguments for it
  startIndex = consumeOptional(startIndex);
}

// consume any positionals following the last Optional
var stopIndex = consumePositionals(startIndex);

// if we didn&#39;t consume all the argument strings, there were extras
extras = extras.concat(_.rest(argStrings, stopIndex));

// if we didn&#39;t use all the Positional objects, there were too few
// arg strings supplied.
if (positionals.length &gt; 0) {
  self.error(&#39;too few arguments&#39;);
}

// make sure all required actions were present
self._actions.forEach(function (action) {
  if (action.required) {
    if (_.indexOf(seenActions, action) &lt; 0) {
      self.error(format(&#39;Argument &quot;%s&quot; is required&#39;, action.getName()));
    }
  }
});

// make sure all required groups have one option present
var actionUsed = false;
self._mutuallyExclusiveGroups.forEach(function (group) {
  if (group.required) {
    actionUsed = _.any(group._groupActions, function (action) {
      return _.contains(seenNonDefaultActions, action);
    });

    // if no actions were used, report the error
    if (!actionUsed) {
      var names = [];
      group._groupActions.forEach(function (action) {
        if (action.help !== $$.SUPPRESS) {
          names.push(action.getName());
        }
      });
      names = names.join(&#39; &#39;);
      var msg = &#39;one of the arguments &#39; + names + &#39; is required&#39;;
      self.error(msg);
    }
  }
});

// return the updated namespace and the extra arguments
return [namespace, extras];</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._readArgsFromFiles = function (argStrings) {</p>

<pre><code>// expand arguments referencing files
var _this = this;
var fs = require(&#39;fs&#39;);
var newArgStrings = [];
argStrings.forEach(function (argString) {
  if (_this.fromfilePrefixChars.indexOf(argString[0]) &lt; 0) {
    // for regular arguments, just add them back into the list
    newArgStrings.push(argString);
  } else {
    // replace arguments referencing files with the file content
    try {
      var argstrs = [];
      var filename = argString.slice(1);
      var content = fs.readFileSync(filename, &#39;utf8&#39;);
      content = content.trim().split(&#39;\n&#39;);
      content.forEach(function (argLine) {
        _this.convertArgLineToArgs(argLine).forEach(function (arg) {
          argstrs.push(arg);
        });
        argstrs = _this._readArgsFromFiles(argstrs);
      });
      newArgStrings.push.apply(newArgStrings, argstrs);
    } catch (error) {
      return _this.error(error.message);
    }
  }
});
return newArgStrings;</code></pre>

<p>};</p>

<p>ArgumentParser.prototype.convertArgLineToArgs = function (argLine) {</p>

<pre><code>return [argLine];
</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._matchArgument = function (action,
regexpArgStrings) {</p>

<pre><code>// match the pattern for this action to the arg strings
var regexpNargs = new RegExp(&#39;^&#39; + this._getNargsPattern(action));
var matches = regexpArgStrings.match(regexpNargs);
var message;

// throw an exception if we weren&#39;t able to find a match
if (!matches) {
  switch (action.nargs) {
  case undefined:
  case null:
    message = &#39;Expected one argument.&#39;;
    break;
  case $$.OPTIONAL:
    message = &#39;Expected at most one argument.&#39;;
    break;
  case $$.ONE_OR_MORE:
    message = &#39;Expected at least one argument.&#39;;
    break;
  default:
    message = &#39;Expected %s argument(s)&#39;;
  }

  throw argumentErrorHelper(
    action,
    format(message, action.nargs)
  );
}
// return the number of arguments matched
return matches[1].length;</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._matchArgumentsPartial = function (actions,
regexpArgStrings) {</p>

<pre><code>// progressively shorten the actions list by slicing off the
// final actions until we find a match
var self = this;
var result = [];
var actionSlice, pattern, matches;
var i, j;

var getLength = function (string) {
  return string.length;
};

for (i = actions.length; i &gt; 0; i--) {
  pattern = &#39;&#39;;
  actionSlice = actions.slice(0, i);
  for (j = 0; j &lt; actionSlice.length; j++) {
    pattern += self._getNargsPattern(actionSlice[j]);
  }

  pattern = new RegExp(&#39;^&#39; + pattern);
  matches = regexpArgStrings.match(pattern);

  if (matches &amp;&amp; matches.length &gt; 0) {
    // need only groups
    matches = matches.splice(1);
    result = result.concat(matches.map(getLength));
    break;
  }
}

// return the list of arg string counts
return result;</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._parseOptional = function (argString) {</p>

<pre><code>var action, optionString, argExplicit, optionTuples;

// if it&#39;s an empty string, it was meant to be a positional
if (!argString) {
  return null;
}

// if it doesn&#39;t start with a prefix, it was meant to be positional
if (this.prefixChars.indexOf(argString[0]) &lt; 0) {
  return null;
}

// if the option string is present in the parser, return the action
if (!!this._optionStringActions[argString]) {
  return [this._optionStringActions[argString], argString, null];
}

// if it&#39;s just a single character, it was meant to be positional
if (argString.length === 1) {
  return null;
}

// if the option string before the &quot;=&quot; is present, return the action
if (argString.indexOf(&#39;=&#39;) &gt;= 0) {
  var argStringSplit = argString.split(&#39;=&#39;);
  optionString = argStringSplit[0];
  argExplicit = argStringSplit[1];

  if (!!this._optionStringActions[optionString]) {
    action = this._optionStringActions[optionString];
    return [action, optionString, argExplicit];
  }
}

// search through all possible prefixes of the option string
// and all actions in the parser for possible interpretations
optionTuples = this._getOptionTuples(argString);

// if multiple actions match, the option string was ambiguous
if (optionTuples.length &gt; 1) {
  var optionStrings = optionTuples.map(function (optionTuple) {
    return optionTuple[1];
  });
  this.error(format(
        &#39;Ambiguous option: &quot;%s&quot; could match %s.&#39;,
        argString, optionStrings.join(&#39;, &#39;)
  ));
// if exactly one action matched, this segmentation is good,
// so return the parsed action
} else if (optionTuples.length === 1) {
  return optionTuples[0];
}

// if it was not found as an option, but it looks like a negative
// number, it was meant to be positional
// unless there are negative-number-like options
if (argString.match(this._regexpNegativeNumber)) {
  if (!_.any(this._hasNegativeNumberOptionals)) {
    return null;
  }
}
// if it contains a space, it was meant to be a positional
if (argString.search(&#39; &#39;) &gt;= 0) {
  return null;
}

// it was meant to be an optional but there is no such option
// in this parser (though it might be a valid option in a subparser)
return [null, argString, null];</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._getOptionTuples = function (optionString) {</p>

<pre><code>var result = [];
var chars = this.prefixChars;
var optionPrefix;
var argExplicit;
var action;
var actionOptionString;

// option strings starting with two prefix characters are only split at
// the &#39;=&#39;
if (chars.indexOf(optionString[0]) &gt;= 0 &amp;&amp; chars.indexOf(optionString[1]) &gt;= 0) {
  if (optionString.indexOf(&#39;=&#39;) &gt;= 0) {
    var optionStringSplit = optionString.split(&#39;=&#39;, 1);

    optionPrefix = optionStringSplit[0];
    argExplicit = optionStringSplit[1];
  } else {
    optionPrefix = optionString;
    argExplicit = null;
  }

  for (actionOptionString in this._optionStringActions) {
    if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {
      action = this._optionStringActions[actionOptionString];
      result.push([action, actionOptionString, argExplicit]);
    }
  }

// single character options can be concatenated with their arguments
// but multiple character options always have to have their argument
// separate
} else if (chars.indexOf(optionString[0]) &gt;= 0 &amp;&amp; chars.indexOf(optionString[1]) &lt; 0) {
  optionPrefix = optionString;
  argExplicit = null;
  var optionPrefixShort = optionString.substr(0, 2);
  var argExplicitShort = optionString.substr(2);

  for (actionOptionString in this._optionStringActions) {
    action = this._optionStringActions[actionOptionString];
    if (actionOptionString === optionPrefixShort) {
      result.push([action, actionOptionString, argExplicitShort]);
    } else if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {
      result.push([action, actionOptionString, argExplicit]);
    }
  }

// shouldn&#39;t ever get here
} else {
  throw new Error(format(&#39;Unexpected option string: %s.&#39;, optionString));
}
// return the collected option tuples
return result;</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._getNargsPattern = function (action) {</p>

<pre><code>// in all examples below, we have to allow for &#39;--&#39; args
// which are represented as &#39;-&#39; in the pattern
var regexpNargs;

switch (action.nargs) {
// the default (null) is assumed to be a single argument
case undefined:
case null:
  regexpNargs = &#39;(-*A-*)&#39;;
  break;
// allow zero or more arguments
case $$.OPTIONAL:
  regexpNargs = &#39;(-*A?-*)&#39;;
  break;
// allow zero or more arguments
case $$.ZERO_OR_MORE:
  regexpNargs = &#39;(-*[A-]*)&#39;;
  break;
// allow one or more arguments
case $$.ONE_OR_MORE:
  regexpNargs = &#39;(-*A[A-]*)&#39;;
  break;
// allow any number of options or arguments
case $$.REMAINDER:
  regexpNargs = &#39;([-AO]*)&#39;;
  break;
// allow one argument followed by any number of options or arguments
case $$.PARSER:
  regexpNargs = &#39;(-*A[-AO]*)&#39;;
  break;
// all others should be integers
default:
  regexpNargs = &#39;(-*&#39; + _.str.repeat(&#39;-*A&#39;, action.nargs) + &#39;-*)&#39;;
}

// if this is an optional action, -- is not allowed
if (action.isOptional()) {
  regexpNargs = regexpNargs.replace(/-\*/g, &#39;&#39;);
  regexpNargs = regexpNargs.replace(/-/g, &#39;&#39;);
}

// return the pattern
return regexpNargs;</code></pre>

<p>};</p>

<p>// // Value conversion methods //</p>

<p>ArgumentParser.prototype._getValues = function (action, argStrings) {</p>

<pre><code>var self = this;

// for everything but PARSER args, strip out &#39;--&#39;
if (action.nargs !== $$.PARSER &amp;&amp; action.nargs !== $$.REMAINDER) {
  argStrings = argStrings.filter(function (arrayElement) {
    return arrayElement !== &#39;--&#39;;
  });
}

var value, argString;

// optional argument produces a default when not present
if (argStrings.length === 0 &amp;&amp; action.nargs === $$.OPTIONAL) {

  value = (action.isOptional()) ? action.constant: action.defaultValue;

  if (typeof(value) === &#39;string&#39;) {
    value = this._getValue(action, value);
    this._checkValue(action, value);
  }

// when nargs=&#39;*&#39; on a positional, if there were no command-line
// args, use the default if it is anything other than None
} else if (argStrings.length === 0 &amp;&amp; action.nargs === $$.ZERO_OR_MORE &amp;&amp;
  action.optionStrings.length === 0) {

  value = (action.defaultValue || argStrings);
  this._checkValue(action, value);

// single argument or optional argument produces a single value
} else if (argStrings.length === 1 &amp;&amp;
      (!action.nargs || action.nargs === $$.OPTIONAL)) {

  argString = argStrings[0];
  value = this._getValue(action, argString);
  this._checkValue(action, value);

// REMAINDER arguments convert all values, checking none
} else if (action.nargs === $$.REMAINDER) {
  value = argStrings.map(function (v) {
    return self._getValue(action, v);
  });

// PARSER arguments convert all values, but check only the first
} else if (action.nargs === $$.PARSER) {
  value = argStrings.map(function (v) {
    return self._getValue(action, v);
  });
  this._checkValue(action, value[0]);

// all other types of nargs produce a list
} else {
  value = argStrings.map(function (v) {
    return self._getValue(action, v);
  });
  value.forEach(function (v) {
    self._checkValue(action, v);
  });
}

// return the converted value
return value;</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._getValue = function (action, argString) {</p>

<pre><code>var result;

var typeFunction = this._registryGet(&#39;type&#39;, action.type, action.type);
if (!_.isFunction(typeFunction)) {
  var message = format(&#39;%s is not callable&#39;, typeFunction);
  throw argumentErrorHelper(action, message);
}

// convert the value to the appropriate type
try {
  result = typeFunction(argString);

  // ArgumentTypeErrors indicate errors
  // If action.type is not a registered string, it is a function
  // Try to deduce its name for inclusion in the error message
  // Failing that, include the error message it raised.
} catch (e) {
  var name = null;
  if (_.isString(action.type)) {
    name = action.type;
  } else {
    name = action.type.name || action.type.displayName || &#39;&lt;function&gt;&#39;;
  }
  var msg = format(&#39;Invalid %s value: %s&#39;, name, argString);
  if (name === &#39;&lt;function&gt;&#39;) {msg += &#39;\n&#39; + e.message; }
  throw argumentErrorHelper(action, msg);
}
// return the converted value
return result;</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._checkValue = function (action, value) {</p>

<pre><code>// converted value must be one of the choices (if specified)
var choices = action.choices;
if (!!choices) {
  // choise for argument can by array or string
  if ((_.isString(choices) || _.isArray(choices)) &amp;&amp;
      choices.indexOf(value) !== -1) {
    return;
  }
  // choise for subparsers can by only hash
  if (_.isObject(choices) &amp;&amp; !_.isArray(choices) &amp;&amp; choices[value]) {
    return;
  }

  if (_.isString(choices)) {
    choices = choices.split(&#39;&#39;).join(&#39;, &#39;);
  }
  else if (_.isArray(choices)) {
    choices =  choices.join(&#39;, &#39;);
  }
  else {
    choices =  _.keys(choices).join(&#39;, &#39;);
  }
  var message = format(&#39;Invalid choice: %s (choose from [%s])&#39;, value, choices);
  throw argumentErrorHelper(action, message);
}</code></pre>

<p>};</p>

<p>// // Help formatting methods //</p>

<p>/**</p>

<pre><code>ArgumentParser#formatUsage -&gt; string

Return usage string

See also [original guide][1]

[1]:http://docs.python.org/dev/library/argparse.html#printing-help
/</code></pre>

<p>ArgumentParser.prototype.formatUsage = function () {</p>

<pre><code>var formatter = this._getFormatter();
formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);
return formatter.formatHelp();
</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>ArgumentParser#formatHelp -&gt; string

Return help

See also [original guide][1]

[1]:http://docs.python.org/dev/library/argparse.html#printing-help
/</code></pre>

<p>ArgumentParser.prototype.formatHelp = function () {</p>

<pre><code>var formatter = this._getFormatter();

// usage
formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);

// description
formatter.addText(this.description);

// positionals, optionals and user-defined groups
this._actionGroups.forEach(function (actionGroup) {
  formatter.startSection(actionGroup.title);
  formatter.addText(actionGroup.description);
  formatter.addArguments(actionGroup._groupActions);
  formatter.endSection();
});

// epilog
formatter.addText(this.epilog);

// determine help from format above
return formatter.formatHelp();</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._getFormatter = function () {</p>

<pre><code>var FormatterClass = this.formatterClass;
var formatter = new FormatterClass({prog: this.prog});
return formatter;</code></pre>

<p>};</p>

<p>// //  Print functions //</p>

<p>/**</p>

<pre><code>ArgumentParser#printUsage() -&gt; Void

Print usage

See also [original guide][1]

[1]:http://docs.python.org/dev/library/argparse.html#printing-help
/</code></pre>

<p>ArgumentParser.prototype.printUsage = function () {</p>

<pre><code>this._printMessage(this.formatUsage());
</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>ArgumentParser#printHelp() -&gt; Void

Print help

See also [original guide][1]

[1]:http://docs.python.org/dev/library/argparse.html#printing-help
/</code></pre>

<p>ArgumentParser.prototype.printHelp = function () {</p>

<pre><code>this._printMessage(this.formatHelp());
</code></pre>

<p>};</p>

<p>ArgumentParser.prototype._printMessage = function (message, stream) {</p>

<pre><code>if (!stream) {
  stream = process.stdout;
}
if (message) {
  stream.write(&#39;&#39; + message);
}</code></pre>

<p>};</p>

<p>// //  Exit functions //</p>

<p>/**</p>

<pre><code>ArgumentParser#exit(status=0, message) -&gt; Void
- status (int): exit status
- message (string): message

Print message in stderr/stdout and exit program
/</code></pre>

<p>ArgumentParser.prototype.exit = function (status, message) {</p>

<pre><code>if (!!message) {
  if (status === 0) {
    this._printMessage(message);
  }
  else {
    this._printMessage(message, process.stderr);
  }
}

process.exit(status);</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>ArgumentParser#error(message) -&gt; Void
- err (Error|string): message

Error method Prints a usage message incorporating the message to stderr and
exits. If you override this in a subclass,
it should not return -- it should
either exit or throw an exception.

/</code></pre>

<p>ArgumentParser.prototype.error = function (err) {</p>

<pre><code>var message;
if (err instanceof Error) {
  if (this.debug === true) {
    throw err;
  }
  message = err.message;
}
else {
  message = err;
}
var msg = format(&#39;%s: error: %s&#39;, this.prog, message) + $$.EOL;

if (this.debug === true) {
  throw new Error(msg);
}

this.printUsage(process.stderr);

return this.exit(2, msg);</code></pre>

<p>};</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
