<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>formatter.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            formatter.js
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/js-yaml/node_modules/argparse/lib/help/formatter.js</li>
            <li>Last modified: 2015-08-29 16:13:52 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<pre><code>class HelpFormatter

Formatter for generating usage messages and argument help strings. Only the
name of this class is considered a public API. All the methods provided by
the class are considered an implementation detail.

Do not call in your code, use this class only for inherits your own forvatter

ToDo add [additonal formatters][1]

[1]:http://docs.python.org/dev/library/argparse.html#formatter-class</code></pre>

<p>&#39;use strict&#39;;</p>

<p>var _ = require(&#39;underscore&#39;); _.str =
require(&#39;underscore.string&#39;);</p>

<p>// Constants var $$ = require(&#39;../const&#39;);</p>

<pre><code>new Support(parent, heding)
- parent (object): parent section
- heading (string): header string</code></pre>

<p>function Section(parent, heading) {</p>

<pre><code>this._parent = parent;
this._heading = heading;
this._items = [];
</code></pre>

<p>}</p>

<p>/*</p>

<pre><code>Section#addItem(callback) -&gt; Void
- callback (array): tuple with function and args

Add function for single element
/</code></pre>

<p>Section.prototype.addItem = function (callback) {</p>

<pre><code>this._items.push(callback);
</code></pre>

<p>};</p>

<p>/*</p>

<pre><code>Section#formatHelp(formatter) -&gt; string
- formatter (HelpFormatter): current formatter

Form help section string

/</code></pre>

<p>Section.prototype.formatHelp = function (formatter) {</p>

<pre><code>var itemHelp, heading;

// format the indented section
if (!!this._parent) {
  formatter._indent();
}

itemHelp = this._items.map(function (item) {
  var obj, func, args;

  obj = formatter;
  func = item[0];
  args = item[1];
  return func.apply(obj, args);
});
itemHelp = formatter._joinParts(itemHelp);

if (!!this._parent) {
  formatter._dedent();
}

// return nothing if the section was empty
if (!itemHelp) {
  return &#39;&#39;;
}

// add the heading if the section was non-empty
heading = &#39;&#39;;
if (!!this._heading &amp;&amp; this._heading !== $$.SUPPRESS) {
  var currentIndent = formatter.currentIndent;
  heading = _.str.repeat(&#39; &#39;, currentIndent) + this._heading + &#39;:&#39; + $$.EOL;
}

// join the section-initialize newline, the heading and the help
return formatter._joinParts([$$.EOL, heading, itemHelp, $$.EOL]);</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>new HelpFormatter(options)

#### Options:
- `prog`: program name
- `indentIncriment`: indent step, default value 2
- `maxHelpPosition`: max help position, default value = 24
- `width`: line width

/</code></pre>

<p>var HelpFormatter = module.exports = function HelpFormatter(options) {</p>

<pre><code>options = options || {};

this._prog = options.prog;

this._maxHelpPosition = options.maxHelpPosition || 24;
this._width = (options.width || ((process.env.COLUMNS || 80) - 2));

this._currentIndent = 0;
this._indentIncriment = options.indentIncriment || 2;
this._level = 0;
this._actionMaxLength = 0;

this._rootSection = new Section(null);
this._currentSection = this._rootSection;

this._whitespaceMatcher = new RegExp(&#39;\\s+&#39;, &#39;g&#39;);
this._longBreakMatcher = new RegExp($$.EOL + $$.EOL + $$.EOL + &#39;+&#39;, &#39;g&#39;);
</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._indent = function () {</p>

<pre><code>this._currentIndent += this._indentIncriment;
this._level += 1;
</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._dedent = function () {</p>

<pre><code>this._currentIndent -= this._indentIncriment;
this._level -= 1;
if (this._currentIndent &lt; 0) {
  throw new Error(&#39;Indent decreased below 0.&#39;);
}</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._addItem = function (func, args) {</p>

<pre><code>this._currentSection.addItem([func, args]);
</code></pre>

<p>};</p>

<p>// // Message building methods //</p>

<p>/**</p>

<pre><code>HelpFormatter#startSection(heading) -&gt; Void
- heading (string): header string

Start new help section

See alse [code example][1]

##### Example

     formatter.startSection(actionGroup.title);
     formatter.addText(actionGroup.description);
     formatter.addArguments(actionGroup._groupActions);
     formatter.endSection();

/</code></pre>

<p>HelpFormatter.prototype.startSection = function (heading) {</p>

<pre><code>this._indent();
var section = new Section(this._currentSection, heading);
var func = section.formatHelp.bind(section);
this._addItem(func, [this]);
this._currentSection = section;</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>HelpFormatter#endSection -&gt; Void

End help section

##### Example

     formatter.startSection(actionGroup.title);
     formatter.addText(actionGroup.description);
     formatter.addArguments(actionGroup._groupActions);
     formatter.endSection();
/</code></pre>

<p>HelpFormatter.prototype.endSection = function () {</p>

<pre><code>this._currentSection = this._currentSection._parent;
this._dedent();
</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>HelpFormatter#addText(text) -&gt; Void
- text (string): plain text

Add plain text into current section

##### Example

     formatter.startSection(actionGroup.title);
     formatter.addText(actionGroup.description);
     formatter.addArguments(actionGroup._groupActions);
     formatter.endSection();

/</code></pre>

<p>HelpFormatter.prototype.addText = function (text) {</p>

<pre><code>if (!!text &amp;&amp; text !== $$.SUPPRESS) {
  this._addItem(this._formatText, [text]);
}</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>HelpFormatter#addUsage(usage, actions, groups, prefix) -&gt; Void
- usage (string): usage text
- actions (array): actions list
- groups (array): groups list
- prefix (string): usage prefix

Add usage data into current section

##### Example

     formatter.addUsage(this.usage, this._actions, []);
     return formatter.formatHelp();

/</code></pre>

<p>HelpFormatter.prototype.addUsage = function (usage, actions, groups,
prefix) {</p>

<pre><code>if (usage !== $$.SUPPRESS) {
  this._addItem(this._formatUsage, [usage, actions, groups, prefix]);
}</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>HelpFormatter#addArgument(action) -&gt; Void
- action (object): action

Add argument into current section

Single variant of [[HelpFormatter#addArguments]]
/</code></pre>

<p>HelpFormatter.prototype.addArgument = function (action) {</p>

<pre><code>if (action.help !== $$.SUPPRESS) {
  var self = this;

  // find all invocations
  var invocations = [this._formatActionInvocation(action)];
  var invocationLength = invocations[0].length;

  var actionLength;

  if (!!action._getSubactions) {
    this._indent();
    action._getSubactions().forEach(function (subaction) {

      var invocationNew = self._formatActionInvocation(subaction);
      invocations.push(invocationNew);
      invocationLength = Math.max(invocationLength, invocationNew.length);

    });
    this._dedent();
  }

  // update the maximum item length
  actionLength = invocationLength + this._currentIndent;
  this._actionMaxLength = Math.max(this._actionMaxLength, actionLength);

  // add the item to the list
  this._addItem(this._formatAction, [action]);
}</code></pre>

<p>};</p>

<p>/**</p>

<pre><code>HelpFormatter#addArguments(actions) -&gt; Void
- actions (array): actions list

Mass add arguments into current section

##### Example

     formatter.startSection(actionGroup.title);
     formatter.addText(actionGroup.description);
     formatter.addArguments(actionGroup._groupActions);
     formatter.endSection();

/</code></pre>

<p>HelpFormatter.prototype.addArguments = function (actions) {</p>

<pre><code>var self = this;
actions.forEach(function (action) {
  self.addArgument(action);
});</code></pre>

<p>};</p>

<p>// // Help-formatting methods //</p>

<p>/**</p>

<pre><code>HelpFormatter#formatHelp -&gt; string

Format help

##### Example

     formatter.addText(this.epilog);
     return formatter.formatHelp();

/</code></pre>

<p>HelpFormatter.prototype.formatHelp = function () {</p>

<pre><code>var help = this._rootSection.formatHelp(this);
if (help) {
  help = help.replace(this._longBreakMatcher, $$.EOL + $$.EOL);
  help = _.str.strip(help, $$.EOL) + $$.EOL;
}
return help;</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._joinParts = function (partStrings) {</p>

<pre><code>return partStrings.filter(function (part) {
  return (!!part &amp;&amp; part !== $$.SUPPRESS);
}).join(&#39;&#39;);</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._formatUsage = function (usage, actions, groups,
prefix) {</p>

<pre><code>if (!prefix &amp;&amp; !_.isString(prefix)) {
  prefix = &#39;usage: &#39;;
}

actions = actions || [];
groups = groups || [];

// if usage is specified, use that
if (usage) {
  usage = _.str.sprintf(usage, {prog: this._prog});

  // if no optionals or positionals are available, usage is just prog
} else if (!usage &amp;&amp; actions.length === 0) {
  usage = this._prog;

  // if optionals and positionals are available, calculate usage
} else if (!usage) {
  var prog = this._prog;
  var optionals = [];
  var positionals = [];
  var actionUsage;
  var textWidth;

  // split optionals from positionals
  actions.forEach(function (action) {
    if (action.isOptional()) {
      optionals.push(action);
    } else {
      positionals.push(action);
    }
  });

  // build full usage string
  actionUsage = this._formatActionsUsage([].concat(optionals, positionals), groups);
  usage = [prog, actionUsage].join(&#39; &#39;);

  // wrap the usage parts if it&#39;s too long
  textWidth = this._width - this._currentIndent;
  if ((prefix.length + usage.length) &gt; textWidth) {

    // break usage into wrappable parts
    var regexpPart = new RegExp(&#39;\\(.*?\\)+|\\[.*?\\]+|\\S+&#39;, &#39;g&#39;);
    var optionalUsage = this._formatActionsUsage(optionals, groups);
    var positionalUsage = this._formatActionsUsage(positionals, groups);

    var optionalParts = optionalUsage.match(regexpPart);
    var positionalParts = positionalUsage.match(regexpPart) || [];

    if (optionalParts.join(&#39; &#39;) !== optionalUsage) {
      throw new Error(&#39;assert &quot;optionalParts.join(\&#39; \&#39;) === optionalUsage&quot;&#39;);
    }
    if (positionalParts.join(&#39; &#39;) !== positionalUsage) {
      throw new Error(&#39;assert &quot;positionalParts.join(\&#39; \&#39;) === positionalUsage&quot;&#39;);
    }

    // helper for wrapping lines
    var _getLines = function (parts, indent, prefix) {
      var lines = [];
      var line = [];

      var lineLength = !!prefix ? prefix.length - 1: indent.length - 1;

      parts.forEach(function (part) {
        if (lineLength + 1 + part.length &gt; textWidth) {
          lines.push(indent + line.join(&#39; &#39;));
          line = [];
          lineLength = indent.length - 1;
        }
        line.push(part);
        lineLength += part.length + 1;
      });

      if (line) {
        lines.push(indent + line.join(&#39; &#39;));
      }
      if (prefix) {
        lines[0] = lines[0].substr(indent.length);
      }
      return lines;
    };

    var lines, indent, parts;
    // if prog is short, follow it with optionals or positionals
    if (prefix.length + prog.length &lt;= 0.75 * textWidth) {
      indent = _.str.repeat(&#39; &#39;, (prefix.length + prog.length + 1));
      if (optionalParts) {
        lines = [].concat(
          _getLines([prog].concat(optionalParts), indent, prefix),
          _getLines(positionalParts, indent)
        );
      } else if (positionalParts) {
        lines = _getLines([prog].concat(positionalParts), indent, prefix);
      } else {
        lines = [prog];
      }

      // if prog is long, put it on its own line
    } else {
      indent = _.str.repeat(&#39; &#39;, prefix.length);
      parts = optionalParts + positionalParts;
      lines = _getLines(parts, indent);
      if (lines.length &gt; 1) {
        lines = [].concat(
          _getLines(optionalParts, indent),
          _getLines(positionalParts, indent)
        );
      }
      lines = [prog] + lines;
    }
    // join lines into usage
    usage = lines.join($$.EOL);
  }
}

// prefix with &#39;usage:&#39;
return prefix + usage + $$.EOL + $$.EOL;</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._formatActionsUsage = function (actions, groups) {</p>

<pre><code>// find group indices and identify actions in groups
var groupActions = [];
var inserts = [];
var self = this;

groups.forEach(function (group) {
  var end;
  var i;

  var start = actions.indexOf(group._groupActions[0]);
  if (start &gt;= 0) {
    end = start + group._groupActions.length;

    //if (actions.slice(start, end) === group._groupActions) {
    if (_.isEqual(actions.slice(start, end), group._groupActions)) {
      group._groupActions.forEach(function (action) {
        groupActions.push(action);
      });

      if (!group.required) {
        if (!!inserts[start]) {
          inserts[start] += &#39; [&#39;;
        }
        else {
          inserts[start] = &#39;[&#39;;
        }
        inserts[end] = &#39;]&#39;;
      } else {
        if (!!inserts[start]) {
          inserts[start] += &#39; (&#39;;
        }
        else {
          inserts[start] = &#39;(&#39;;
        }
        inserts[end] = &#39;)&#39;;
      }
      for (i = start + 1; i &lt; end; i += 1) {
        inserts[i] = &#39;|&#39;;
      }
    }
  }
});

// collect all actions format strings
var parts = [];

actions.forEach(function (action, actionIndex) {
  var part;
  var optionString;
  var argsDefault;
  var argsString;

  // suppressed arguments are marked with None
  // remove | separators for suppressed arguments
  if (action.help === $$.SUPPRESS) {
    parts.push(null);
    if (inserts[actionIndex] === &#39;|&#39;) {
      inserts.splice(actionIndex, actionIndex);
    } else if (inserts[actionIndex + 1] === &#39;|&#39;) {
      inserts.splice(actionIndex + 1, actionIndex + 1);
    }

    // produce all arg strings
  } else if (!action.isOptional()) {
    part = self._formatArgs(action, action.dest);

    // if it&#39;s in a group, strip the outer []
    if (groupActions.indexOf(action) &gt;= 0) {
      if (part[0] === &#39;[&#39; &amp;&amp; part[part.length - 1] === &#39;]&#39;) {
        part = part.slice(1, -1);
      }
    }
    // add the action string to the list
    parts.push(part);

  // produce the first way to invoke the option in brackets
  } else {
    optionString = action.optionStrings[0];

    // if the Optional doesn&#39;t take a value, format is: -s or --long
    if (action.nargs === 0) {
      part = &#39;&#39; + optionString;

    // if the Optional takes a value, format is: -s ARGS or --long ARGS
    } else {
      argsDefault = action.dest.toUpperCase();
      argsString = self._formatArgs(action, argsDefault);
      part = optionString + &#39; &#39; + argsString;
    }
    // make it look optional if it&#39;s not required or in a group
    if (!action.required &amp;&amp; groupActions.indexOf(action) &lt; 0) {
      part = &#39;[&#39; + part + &#39;]&#39;;
    }
    // add the action string to the list
    parts.push(part);
  }
});

// insert things at the necessary indices
for (var i = inserts.length - 1; i &gt;= 0; --i) {
  if (inserts[i] !== null) {
    parts.splice(i, 0, inserts[i]);
  }
}

// join all the action items with spaces
var text = parts.filter(function (part) {
  return !!part;
}).join(&#39; &#39;);

// clean up separators for mutually exclusive groups
text = text.replace(/([\[(]) /g, &#39;$1&#39;); // remove spaces
text = text.replace(/ ([\])])/g, &#39;$1&#39;);
text = text.replace(/\[ *\]/g, &#39;&#39;); // remove empty groups
text = text.replace(/\( *\)/g, &#39;&#39;);
text = text.replace(/\(([^|]*)\)/g, &#39;$1&#39;); // remove () from single action groups

text = _.str.strip(text);

// return the text
return text;</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._formatText = function (text) {</p>

<pre><code>text = _.str.sprintf(text, {prog: this._prog});
var textWidth = this._width - this._currentIndent;
var indentIncriment = _.str.repeat(&#39; &#39;, this._currentIndent);
return this._fillText(text, textWidth, indentIncriment) + $$.EOL + $$.EOL;
</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._formatAction = function (action) {</p>

<pre><code>var self = this;

var helpText;
var helpLines;
var parts;
var indentFirst;

// determine the required width and the entry label
var helpPosition = Math.min(this._actionMaxLength + 2, this._maxHelpPosition);
var helpWidth = this._width - helpPosition;
var actionWidth = helpPosition - this._currentIndent - 2;
var actionHeader = this._formatActionInvocation(action);

// no help; start on same line and add a final newline
if (!action.help) {
  actionHeader = _.str.repeat(&#39; &#39;, this._currentIndent) + actionHeader + $$.EOL;

// short action name; start on the same line and pad two spaces
} else if (actionHeader.length &lt;= actionWidth) {
  actionHeader = _.str.repeat(&#39; &#39;, this._currentIndent) +
      actionHeader +
      &#39;  &#39; +
      _.str.repeat(&#39; &#39;, actionWidth - actionHeader.length);
  indentFirst = 0;

// long action name; start on the next line
} else {
  actionHeader = _.str.repeat(&#39; &#39;, this._currentIndent) + actionHeader + $$.EOL;
  indentFirst = helpPosition;
}

// collect the pieces of the action help
parts = [actionHeader];

// if there was help for the action, add lines of help text
if (!!action.help) {
  helpText = this._expandHelp(action);
  helpLines = this._splitLines(helpText, helpWidth);
  parts.push(_.str.repeat(&#39; &#39;, indentFirst) + helpLines[0] + $$.EOL);
  helpLines.slice(1).forEach(function (line) {
    parts.push(_.str.repeat(&#39; &#39;, helpPosition) + line + $$.EOL);
  });

// or add a newline if the description doesn&#39;t end with one
} else if (actionHeader.charAt(actionHeader.length - 1) !== $$.EOL) {
  parts.push($$.EOL);
}
// if there are any sub-actions, add their help as well
if (!!action._getSubactions) {
  this._indent();
  action._getSubactions().forEach(function (subaction) {
    parts.push(self._formatAction(subaction));
  });
  this._dedent();
}
// return a single string
return this._joinParts(parts);</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._formatActionInvocation = function (action) {</p>

<pre><code>if (!action.isOptional()) {
  var format_func = this._metavarFormatter(action, action.dest);
  var metavars = format_func(1);
  return metavars[0];
} else {
  var parts = [];
  var argsDefault;
  var argsString;

  // if the Optional doesn&#39;t take a value, format is: -s, --long
  if (action.nargs === 0) {
    parts = parts.concat(action.optionStrings);

  // if the Optional takes a value, format is: -s ARGS, --long ARGS
  } else {
    argsDefault = action.dest.toUpperCase();
    argsString = this._formatArgs(action, argsDefault);
    action.optionStrings.forEach(function (optionString) {
      parts.push(optionString + &#39; &#39; + argsString);
    });
  }
  return parts.join(&#39;, &#39;);
}</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._metavarFormatter = function (action,
metavarDefault) {</p>

<pre><code>var result;

if (!!action.metavar || action.metavar === &#39;&#39;) {
  result = action.metavar;
} else if (!!action.choices) {
  var choices = action.choices;

  if (_.isString(choices)) {
    choices = choices.split(&#39;&#39;).join(&#39;, &#39;);
  } else if (_.isArray(choices)) {
    choices = choices.join(&#39;,&#39;);
  }
  else
  {
    choices = _.keys(choices).join(&#39;,&#39;);
  }
  result = &#39;{&#39; + choices + &#39;}&#39;;
} else {
  result = metavarDefault;
}

return function (size) {
  if (Array.isArray(result)) {
    return result;
  } else {
    var metavars = [];
    for (var i = 0; i &lt; size; i += 1) {
      metavars.push(result);
    }
    return metavars;
  }
};</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._formatArgs = function (action, metavarDefault) {</p>

<pre><code>var result;
var metavars;

var buildMetavar = this._metavarFormatter(action, metavarDefault);

switch (action.nargs) {
case undefined:
case null:
  metavars = buildMetavar(1);
  result = &#39;&#39; + metavars[0];
  break;
case $$.OPTIONAL:
  metavars = buildMetavar(1);
  result = &#39;[&#39; + metavars[0] + &#39;]&#39;;
  break;
case $$.ZERO_OR_MORE:
  metavars = buildMetavar(2);
  result = &#39;[&#39; + metavars[0] + &#39; [&#39; + metavars[1] + &#39; ...]]&#39;;
  break;
case $$.ONE_OR_MORE:
  metavars = buildMetavar(2);
  result = &#39;&#39; + metavars[0] + &#39; [&#39; + metavars[1] + &#39; ...]&#39;;
  break;
case $$.REMAINDER:
  result = &#39;...&#39;;
  break;
case $$.PARSER:
  metavars = buildMetavar(1);
  result = metavars[0] + &#39; ...&#39;;
  break;
default:
  metavars = buildMetavar(action.nargs);
  result = metavars.join(&#39; &#39;);
}
return result;</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._expandHelp = function (action) {</p>

<pre><code>var params = { prog: this._prog };

Object.keys(action).forEach(function (actionProperty) {
  var actionValue = action[actionProperty];

  if (actionValue !== $$.SUPPRESS) {
    params[actionProperty] = actionValue;
  }
});

if (!!params.choices) {
  if (_.isString(params.choices)) {
    params.choices = params.choices.split(&#39;&#39;).join(&#39;, &#39;);
  }
  else if (_.isArray(params.choices)) {
    params.choices = params.choices.join(&#39;, &#39;);
  }
  else {
    params.choices = _.keys(params.choices).join(&#39;, &#39;);
  }
}

return _.str.sprintf(this._getHelpString(action), params);</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._splitLines = function (text, width) {</p>

<pre><code>var lines = [];
var delimiters = [&quot; &quot;, &quot;.&quot;, &quot;,&quot;, &quot;!&quot;, &quot;?&quot;];
var re = new RegExp(&#39;[&#39; + delimiters.join(&#39;&#39;) + &#39;][^&#39; + delimiters.join(&#39;&#39;) + &#39;]*$&#39;);

text = text.replace(/[\n\|\t]/g, &#39; &#39;);

text = _.str.strip(text);
text = text.replace(this._whitespaceMatcher, &#39; &#39;);

// Wraps the single paragraph in text (a string) so every line
// is at most width characters long.
text.split($$.EOL).forEach(function (line) {
  if (width &gt;= line.length) {
    lines.push(line);
    return;
  }

  var wrapStart = 0;
  var wrapEnd = width;
  var delimiterIndex = 0;
  while (wrapEnd &lt;= line.length) {
    if (wrapEnd !== line.length &amp;&amp; delimiters.indexOf(line[wrapEnd] &lt; -1)) {
      delimiterIndex = (re.exec(line.substring(wrapStart, wrapEnd)) || {}).index;
      wrapEnd = wrapStart + delimiterIndex + 1;
    }
    lines.push(line.substring(wrapStart, wrapEnd));
    wrapStart = wrapEnd;
    wrapEnd += width;
  }
  if (wrapStart &lt; line.length) {
    lines.push(line.substring(wrapStart, wrapEnd));
  }
});

return lines;</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._fillText = function (text, width, indent) {</p>

<pre><code>var lines = this._splitLines(text, width);
lines = lines.map(function (line) {
  return indent + line;
});
return lines.join($$.EOL);
</code></pre>

<p>};</p>

<p>HelpFormatter.prototype._getHelpString = function (action) {</p>

<pre><code>return action.help;
</code></pre>

<p>};</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
