<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>browser.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            browser.js
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/glob/node_modules/minimatch/browser.js</li>
            <li>Last modified: 2015-08-29 16:13:52 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>(function e(t,n,r){function s(o,u){<a href="o">if(!n</a>){<a
href="o">if(!t</a>){var a=typeof
require==“function”&amp;&amp;require;if(!u&amp;&amp;a)return
a(o,!0);if(i)return i(o,!0);var f=new Error(“Cannot find module
&#39;”<code>o</code>“&#39;”);throw f.code=“MODULE_NOT_FOUND”,f}var <a
href="o">l=n</a>={exports:{}};<a
href="o">t</a>[0].call(l.exports,function(e){var <a href="o">n=t</a>[<a
href="e">1]</a>;return s(n?n:e)},l,l.exports,e,t,n,r)}return <a
href="o">n</a>.exports}var i=typeof
require==“function”&amp;&amp;require;for(var <a
href="o">o=0;o<r.length;o++)s(r</a>);return
s})({1:[function(require,module,exports){ (function (process){
module.exports = minimatch minimatch.Minimatch = Minimatch</p>

<p>var isWindows = false if (typeof process !== &#39;undefined&#39; &amp;&amp;
process.platform === &#39;win32&#39;)</p>

<pre><code>isWindows = true
</code></pre>

<p>var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}</p>

<pre><code>, expand = require(&quot;brace-expansion&quot;)

// any single thing other than /
// don&#39;t need to escape / when using new RegExp()
, qmark = &quot;[^/]&quot;

// * =&gt; any number of characters
, star = qmark + &quot;*?&quot;

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
, twoStarDot = &quot;(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?&quot;

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
, twoStarNoDot = &quot;(?:(?!(?:\\\/|^)\\.).)*?&quot;

// characters that need to be escaped in RegExp.
, reSpecials = charSet(&quot;().*{}+?[]^$\\!&quot;)</code></pre>

<p>// “abc” -&gt; { a:true, b:true, c:true } function charSet (s) {</p>

<pre><code>return s.split(&quot;&quot;).reduce(function (set, c) {
  set[c] = true
  return set
}, {})</code></pre>

<p>}</p>

<p>// normalizes slashes. var slashSplit = //+/</p>

<p>minimatch.filter = filter function filter (pattern, options) {</p>

<pre><code>options = options || {}
return function (p, i, list) {
  return minimatch(p, pattern, options)
}</code></pre>

<p>}</p>

<p>function ext (a, b) {</p>

<pre><code>a = a || {}
b = b || {}
var t = {}
Object.keys(b).forEach(function (k) {
  t[k] = b[k]
})
Object.keys(a).forEach(function (k) {
  t[k] = a[k]
})
return t
</code></pre>

<p>}</p>

<p>minimatch.defaults = function (def) {</p>

<pre><code>if (!def || !Object.keys(def).length) return minimatch

var orig = minimatch

var m = function minimatch (p, pattern, options) {
  return orig.minimatch(p, pattern, ext(def, options))
}

m.Minimatch = function Minimatch (pattern, options) {
  return new orig.Minimatch(pattern, ext(def, options))
}

return m</code></pre>

<p>}</p>

<p>Minimatch.defaults = function (def) {</p>

<pre><code>if (!def || !Object.keys(def).length) return Minimatch
return minimatch.defaults(def).Minimatch</code></pre>

<p>}</p>

<p>function minimatch (p, pattern, options) {</p>

<pre><code>if (typeof pattern !== &quot;string&quot;) {
  throw new TypeError(&quot;glob pattern string required&quot;)
}

if (!options) options = {}

// shortcut: comments match nothing.
if (!options.nocomment &amp;&amp; pattern.charAt(0) === &quot;#&quot;) {
  return false
}

// &quot;&quot; only matches &quot;&quot;
if (pattern.trim() === &quot;&quot;) return p === &quot;&quot;

return new Minimatch(pattern, options).match(p)</code></pre>

<p>}</p>

<p>function Minimatch (pattern, options) {</p>

<pre><code>if (!(this instanceof Minimatch)) {
  return new Minimatch(pattern, options)
}

if (typeof pattern !== &quot;string&quot;) {
  throw new TypeError(&quot;glob pattern string required&quot;)
}

if (!options) options = {}
pattern = pattern.trim()

// windows support: need to use /, not \
if (isWindows)
  pattern = pattern.split(&quot;\\&quot;).join(&quot;/&quot;)

this.options = options
this.set = []
this.pattern = pattern
this.regexp = null
this.negate = false
this.comment = false
this.empty = false

// make the set of regexps etc.
this.make()</code></pre>

<p>}</p>

<p>Minimatch.prototype.debug = function() {}</p>

<p>Minimatch.prototype.make = make function make () {</p>

<pre><code>// don&#39;t do it more than once.
if (this._made) return

var pattern = this.pattern
var options = this.options

// empty patterns and comments match nothing.
if (!options.nocomment &amp;&amp; pattern.charAt(0) === &quot;#&quot;) {
  this.comment = true
  return
}
if (!pattern) {
  this.empty = true
  return
}

// step 1: figure out negation, etc.
this.parseNegate()

// step 2: expand braces
var set = this.globSet = this.braceExpand()

if (options.debug) this.debug = console.error

this.debug(this.pattern, set)

// step 3: now we have a set, so turn each one into a series of path-portion
// matching patterns.
// These will be regexps, except in the case of &quot;**&quot;, which is
// set to the GLOBSTAR object for globstar behavior,
// and will not contain any / characters
set = this.globParts = set.map(function (s) {
  return s.split(slashSplit)
})

this.debug(this.pattern, set)

// glob --&gt; regexps
set = set.map(function (s, si, set) {
  return s.map(this.parse, this)
}, this)

this.debug(this.pattern, set)

// filter out everything that didn&#39;t compile properly.
set = set.filter(function (s) {
  return -1 === s.indexOf(false)
})

this.debug(this.pattern, set)

this.set = set</code></pre>

<p>}</p>

<p>Minimatch.prototype.parseNegate = parseNegate function parseNegate () {</p>

<pre><code>var pattern = this.pattern
  , negate = false
  , options = this.options
  , negateOffset = 0

if (options.nonegate) return

for ( var i = 0, l = pattern.length
    ; i &lt; l &amp;&amp; pattern.charAt(i) === &quot;!&quot;
    ; i ++) {
  negate = !negate
  negateOffset ++
}

if (negateOffset) this.pattern = pattern.substr(negateOffset)
this.negate = negate</code></pre>

<p>}</p>

<p>// Brace expansion: // a{b,c}d -&gt; abd acd // a{b,}c -&gt; abc ac //
a{0..3}d -&gt; a0d a1d a2d a3d // a{b,c{d,e}f}g -&gt; abg acdfg acefg //
a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg // // Invalid sets are not
expanded. // a{2..}b -&gt; a{2..}b // a{b}c -&gt; a{b}c
minimatch.braceExpand = function (pattern, options) {</p>

<pre><code>return braceExpand(pattern, options)
</code></pre>

<p>}</p>

<p>Minimatch.prototype.braceExpand = braceExpand</p>

<p>function braceExpand (pattern, options) {</p>

<pre><code>if (!options) {
  if (this instanceof Minimatch)
    options = this.options
  else
    options = {}
}

pattern = typeof pattern === &quot;undefined&quot;
  ? this.pattern : pattern

if (typeof pattern === &quot;undefined&quot;) {
  throw new Error(&quot;undefined pattern&quot;)
}

if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
  // shortcut. no need to expand.
  return [pattern]
}

return expand(pattern)</code></pre>

<p>}</p>

<p>// parse a component of the expanded set. // At this point, no pattern may
contain “/” in it // so we&#39;re going to return a 2d array, where each
entry is the full // pattern, split on &#39;/&#39;, and then turned into a
regular expression. // A regexp is made at the end which joins each array
with an // escaped /, and another full one which joins each regexp with |.
// // Following the lead of Bash 4.1, note that “**” only has special
meaning // when it is the <strong>only</strong> thing in a path portion. 
Otherwise, any series // of * is equivalent to a single *.  Globstar
behavior is enabled by // default, and can be disabled by setting
options.noglobstar. Minimatch.prototype.parse = parse var SUBPARSE = {}
function parse (pattern, isSub) {</p>

<pre><code>var options = this.options

// shortcuts
if (!options.noglobstar &amp;&amp; pattern === &quot;**&quot;) return GLOBSTAR
if (pattern === &quot;&quot;) return &quot;&quot;

var re = &quot;&quot;
  , hasMagic = !!options.nocase
  , escaping = false
  // ? =&gt; one single character
  , patternListStack = []
  , plType
  , stateChar
  , inClass = false
  , reClassStart = -1
  , classStart = -1
  // . and .. never match anything that doesn&#39;t start with .,
  // even when options.dot is set.
  , patternStart = pattern.charAt(0) === &quot;.&quot; ? &quot;&quot; // anything
    // not (start or / followed by . or .. followed by / or end)
    : options.dot ? &quot;(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))&quot;
    : &quot;(?!\\.)&quot;
  , self = this

function clearStateChar () {
  if (stateChar) {
    // we had some state-tracking character
    // that wasn&#39;t consumed by this pass.
    switch (stateChar) {
      case &quot;*&quot;:
        re += star
        hasMagic = true
        break
      case &quot;?&quot;:
        re += qmark
        hasMagic = true
        break
      default:
        re += &quot;\\&quot;+stateChar
        break
    }
    self.debug(&#39;clearStateChar %j %j&#39;, stateChar, re)
    stateChar = false
  }
}

for ( var i = 0, len = pattern.length, c
    ; (i &lt; len) &amp;&amp; (c = pattern.charAt(i))
    ; i ++ ) {

  this.debug(&quot;%s\t%s %s %j&quot;, pattern, i, re, c)

  // skip over any that are escaped.
  if (escaping &amp;&amp; reSpecials[c]) {
    re += &quot;\\&quot; + c
    escaping = false
    continue
  }

  SWITCH: switch (c) {
    case &quot;/&quot;:
      // completely not allowed, even escaped.
      // Should already be path-split by now.
      return false

    case &quot;\\&quot;:
      clearStateChar()
      escaping = true
      continue

    // the various stateChar values
    // for the &quot;extglob&quot; stuff.
    case &quot;?&quot;:
    case &quot;*&quot;:
    case &quot;+&quot;:
    case &quot;@&quot;:
    case &quot;!&quot;:
      this.debug(&quot;%s\t%s %s %j &lt;-- stateChar&quot;, pattern, i, re, c)

      // all of those are literals inside a class, except that
      // the glob [!a] means [^a] in regexp
      if (inClass) {
        this.debug(&#39;  in class&#39;)
        if (c === &quot;!&quot; &amp;&amp; i === classStart + 1) c = &quot;^&quot;
        re += c
        continue
      }

      // if we already have a stateChar, then it means
      // that there was something like ** or +? in there.
      // Handle the stateChar, then proceed with this one.
      self.debug(&#39;call clearStateChar %j&#39;, stateChar)
      clearStateChar()
      stateChar = c
      // if extglob is disabled, then +(asdf|foo) isn&#39;t a thing.
      // just clear the statechar *now*, rather than even diving into
      // the patternList stuff.
      if (options.noext) clearStateChar()
      continue

    case &quot;(&quot;:
      if (inClass) {
        re += &quot;(&quot;
        continue
      }

      if (!stateChar) {
        re += &quot;\\(&quot;
        continue
      }

      plType = stateChar
      patternListStack.push({ type: plType
                            , start: i - 1
                            , reStart: re.length })
      // negation is (?:(?!js)[^/]*)
      re += stateChar === &quot;!&quot; ? &quot;(?:(?!&quot; : &quot;(?:&quot;
      this.debug(&#39;plType %j %j&#39;, stateChar, re)
      stateChar = false
      continue

    case &quot;)&quot;:
      if (inClass || !patternListStack.length) {
        re += &quot;\\)&quot;
        continue
      }

      clearStateChar()
      hasMagic = true
      re += &quot;)&quot;
      plType = patternListStack.pop().type
      // negation is (?:(?!js)[^/]*)
      // The others are (?:&lt;pattern&gt;)&lt;type&gt;
      switch (plType) {
        case &quot;!&quot;:
          re += &quot;[^/]*?)&quot;
          break
        case &quot;?&quot;:
        case &quot;+&quot;:
        case &quot;*&quot;: re += plType
        case &quot;@&quot;: break // the default anyway
      }
      continue

    case &quot;|&quot;:
      if (inClass || !patternListStack.length || escaping) {
        re += &quot;\\|&quot;
        escaping = false
        continue
      }

      clearStateChar()
      re += &quot;|&quot;
      continue

    // these are mostly the same in regexp and glob
    case &quot;[&quot;:
      // swallow any state-tracking char before the [
      clearStateChar()

      if (inClass) {
        re += &quot;\\&quot; + c
        continue
      }

      inClass = true
      classStart = i
      reClassStart = re.length
      re += c
      continue

    case &quot;]&quot;:
      //  a right bracket shall lose its special
      //  meaning and represent itself in
      //  a bracket expression if it occurs
      //  first in the list.  -- POSIX.2 2.8.3.2
      if (i === classStart + 1 || !inClass) {
        re += &quot;\\&quot; + c
        escaping = false
        continue
      }

      // finish up the class.
      hasMagic = true
      inClass = false
      re += c
      continue

    default:
      // swallow any state char that wasn&#39;t consumed
      clearStateChar()

      if (escaping) {
        // no need
        escaping = false
      } else if (reSpecials[c]
                 &amp;&amp; !(c === &quot;^&quot; &amp;&amp; inClass)) {
        re += &quot;\\&quot;
      }

      re += c

  } // switch
} // for

// handle the case where we left a class open.
// &quot;[abc&quot; is valid, equivalent to &quot;\[abc&quot;
if (inClass) {
  // split where the last [ was, and escape it
  // this is a huge pita.  We now have to re-walk
  // the contents of the would-be class to re-translate
  // any characters that were passed through as-is
  var cs = pattern.substr(classStart + 1)
    , sp = this.parse(cs, SUBPARSE)
  re = re.substr(0, reClassStart) + &quot;\\[&quot; + sp[0]
  hasMagic = hasMagic || sp[1]
}

// handle the case where we had a +( thing at the *end*
// of the pattern.
// each pattern list stack adds 3 chars, and we need to go through
// and escape any | chars that were passed through as-is for the regexp.
// Go through and escape them, taking care not to double-escape any
// | chars that were already escaped.
var pl
while (pl = patternListStack.pop()) {
  var tail = re.slice(pl.reStart + 3)
  // maybe some even number of \, then maybe 1 \, followed by a |
  tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
    if (!$2) {
      // the | isn&#39;t already escaped, so escape it.
      $2 = &quot;\\&quot;
    }

    // need to escape all those slashes *again*, without escaping the
    // one that we need for escaping the | character.  As it works out,
    // escaping an even number of slashes can be done by simply repeating
    // it exactly after itself.  That&#39;s why this trick works.
    //
    // I am sorry that you have to see this.
    return $1 + $1 + $2 + &quot;|&quot;
  })

  this.debug(&quot;tail=%j\n   %s&quot;, tail, tail)
  var t = pl.type === &quot;*&quot; ? star
        : pl.type === &quot;?&quot; ? qmark
        : &quot;\\&quot; + pl.type

  hasMagic = true
  re = re.slice(0, pl.reStart)
     + t + &quot;\\(&quot;
     + tail
}

// handle trailing things that only matter at the very end.
clearStateChar()
if (escaping) {
  // trailing \\
  re += &quot;\\\\&quot;
}

// only need to apply the nodot start if the re starts with
// something that could conceivably capture a dot
var addPatternStart = false
switch (re.charAt(0)) {
  case &quot;.&quot;:
  case &quot;[&quot;:
  case &quot;(&quot;: addPatternStart = true
}

// if the re is not &quot;&quot; at this point, then we need to make sure
// it doesn&#39;t match against an empty path part.
// Otherwise a   will match a/, which it should not.
if (re !== &quot;&quot; &amp;&amp; hasMagic) re = &quot;(?=.)&quot; + re

if (addPatternStart) re = patternStart + re

// parsing just a piece of a larger pattern.
if (isSub === SUBPARSE) {
  return [ re, hasMagic ]
}

// skip the regexp for non-magical patterns
// unescape anything in it, though, so that it&#39;ll be
// an exact match against a file etc.
if (!hasMagic) {
  return globUnescape(pattern)
}

var flags = options.nocase ? &quot;i&quot; : &quot;&quot;
  , regExp = new RegExp(&quot;^&quot; + re + &quot;$&quot;, flags)

regExp._glob = pattern
regExp._src = re

return regExp</code></pre>

<p>}</p>

<p>minimatch.makeRe = function (pattern, options) {</p>

<pre><code>return new Minimatch(pattern, options || {}).makeRe()
</code></pre>

<p>}</p>

<p>Minimatch.prototype.makeRe = makeRe function makeRe () {</p>

<pre><code>if (this.regexp || this.regexp === false) return this.regexp

// at this point, this.set is a 2d array of partial
// pattern strings, or &quot;**&quot;.
//
// It&#39;s better to use .match().  This function shouldn&#39;t
// be used, really, but it&#39;s pretty convenient sometimes,
// when you just want to work with a regex.
var set = this.set

if (!set.length) return this.regexp = false
var options = this.options

var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  , flags = options.nocase ? &quot;i&quot; : &quot;&quot;

var re = set.map(function (pattern) {
  return pattern.map(function (p) {
    return (p === GLOBSTAR) ? twoStar
         : (typeof p === &quot;string&quot;) ? regExpEscape(p)
         : p._src
  }).join(&quot;\\\/&quot;)
}).join(&quot;|&quot;)

// must match entire pattern
// ending in a * or ** will make it less strict.
re = &quot;^(?:&quot; + re + &quot;)$&quot;

// can match anything, as long as it&#39;s not this.
if (this.negate) re = &quot;^(?!&quot; + re + &quot;).*$&quot;

try {
  return this.regexp = new RegExp(re, flags)
} catch (ex) {
  return this.regexp = false
}</code></pre>

<p>}</p>

<p>minimatch.match = function (list, pattern, options) {</p>

<pre><code>options = options || {}
var mm = new Minimatch(pattern, options)
list = list.filter(function (f) {
  return mm.match(f)
})
if (mm.options.nonull &amp;&amp; !list.length) {
  list.push(pattern)
}
return list</code></pre>

<p>}</p>

<p>Minimatch.prototype.match = match function match (f, partial) {</p>

<pre><code>this.debug(&quot;match&quot;, f, this.pattern)
// short-circuit in the case of busted things.
// comments, etc.
if (this.comment) return false
if (this.empty) return f === &quot;&quot;

if (f === &quot;/&quot; &amp;&amp; partial) return true

var options = this.options

// windows: need to use /, not \
if (isWindows)
  f = f.split(&quot;\\&quot;).join(&quot;/&quot;)

// treat the test path as a set of pathparts.
f = f.split(slashSplit)
this.debug(this.pattern, &quot;split&quot;, f)

// just ONE of the pattern sets in this.set needs to match
// in order for it to be valid.  If negating, then just one
// match means that we have failed.
// Either way, return on the first hit.

var set = this.set
this.debug(this.pattern, &quot;set&quot;, set)

// Find the basename of the path by looking for the last non-empty segment
var filename;
for (var i = f.length - 1; i &gt;= 0; i--) {
  filename = f[i]
  if (filename) break
}

for (var i = 0, l = set.length; i &lt; l; i ++) {
  var pattern = set[i], file = f
  if (options.matchBase &amp;&amp; pattern.length === 1) {
    file = [filename]
  }
  var hit = this.matchOne(file, pattern, partial)
  if (hit) {
    if (options.flipNegate) return true
    return !this.negate
  }
}

// didn&#39;t get any hits.  this is success if it&#39;s a negative
// pattern, failure otherwise.
if (options.flipNegate) return false
return this.negate</code></pre>

<p>}</p>

<p>// set partial to true to test if, for example, // “/a/b” matches the start
of “/  b  /d” // Partial means, if you run out of file before you run //
out of pattern, then that&#39;s fine, as long as all // the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {</p>

<pre><code>var options = this.options

this.debug(&quot;matchOne&quot;,
            { &quot;this&quot;: this
            , file: file
            , pattern: pattern })

this.debug(&quot;matchOne&quot;, file.length, pattern.length)

for ( var fi = 0
        , pi = 0
        , fl = file.length
        , pl = pattern.length
    ; (fi &lt; fl) &amp;&amp; (pi &lt; pl)
    ; fi ++, pi ++ ) {

  this.debug(&quot;matchOne loop&quot;)
  var p = pattern[pi]
    , f = file[fi]

  this.debug(pattern, p, f)

  // should be impossible.
  // some invalid regexp stuff in the set.
  if (p === false) return false

  if (p === GLOBSTAR) {
    this.debug(&#39;GLOBSTAR&#39;, [pattern, p, f])

    // &quot;**&quot;
    // a/   b/**/c would match the following:
    // a/b/x/y/z/c
    // a/x/y/z/b/c
    // a/b/x/b/x/c
    // a/b/c
    // To do this, take the rest of the pattern after
    // the **, and see if it would match the file remainder.
    // If so, return success.
    // If not, the ** &quot;swallows&quot; a segment, and try again.
    // This is recursively awful.
    //
    // a/**/b/**/c matching a/b/x/y/z/c
    // - a matches a
    // - doublestar
    //   - matchOne(b/x/y/z/c, b/**/c)
    //     - b matches b
    //     - doublestar
    //       - matchOne(x/y/z/c, c) -&gt; no
    //       - matchOne(y/z/c, c) -&gt; no
    //       - matchOne(z/c, c) -&gt; no
    //       - matchOne(c, c) yes, hit
    var fr = fi
      , pr = pi + 1
    if (pr === pl) {
      this.debug(&#39;** at the end&#39;)
      // a ** at the end will just swallow the rest.
      // We have found a match.
      // however, it will not swallow /.x, unless
      // options.dot is set.
      // . and .. are *never* matched by **, for explosively
      // exponential reasons.
      for ( ; fi &lt; fl; fi ++) {
        if (file[fi] === &quot;.&quot; || file[fi] === &quot;..&quot; ||
            (!options.dot &amp;&amp; file[fi].charAt(0) === &quot;.&quot;)) return false
      }
      return true
    }

    // ok, let&#39;s see if we can swallow whatever we can.
    WHILE: while (fr &lt; fl) {
      var swallowee = file[fr]

      this.debug(&#39;\nglobstar while&#39;,
                  file, fr, pattern, pr, swallowee)

      // XXX remove this slice.  Just pass the start index.
      if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
        this.debug(&#39;globstar found match!&#39;, fr, fl, swallowee)
        // found a match.
        return true
      } else {
        // can&#39;t swallow &quot;.&quot; or &quot;..&quot; ever.
        // can only swallow &quot;.foo&quot; when explicitly asked.
        if (swallowee === &quot;.&quot; || swallowee === &quot;..&quot; ||
            (!options.dot &amp;&amp; swallowee.charAt(0) === &quot;.&quot;)) {
          this.debug(&quot;dot detected!&quot;, file, fr, pattern, pr)
          break WHILE
        }

        // ** swallows a segment, and continue.
        this.debug(&#39;globstar swallow a segment, and continue&#39;)
        fr ++
      }
    }
    // no match was found.
    // However, in partial mode, we can&#39;t say this is necessarily over.
    // If there&#39;s more *pattern* left, then
    if (partial) {
      // ran out of file
      this.debug(&quot;\n&gt;&gt;&gt; no match, partial?&quot;, file, fr, pattern, pr)
      if (fr === fl) return true
    }
    return false
  }

  // something other than **
  // non-magic patterns just have to match exactly
  // patterns with magic have been turned into regexps.
  var hit
  if (typeof p === &quot;string&quot;) {
    if (options.nocase) {
      hit = f.toLowerCase() === p.toLowerCase()
    } else {
      hit = f === p
    }
    this.debug(&quot;string match&quot;, p, f, hit)
  } else {
    hit = f.match(p)
    this.debug(&quot;pattern match&quot;, p, f, hit)
  }

  if (!hit) return false
}

// Note: ending in / means that we&#39;ll get a final &quot;&quot;
// at the end of the pattern.  This can only match a
// corresponding &quot;&quot; at the end of the file.
// If the file ends in /, then it can only match a
// a pattern that ends in /, unless the pattern just
// doesn&#39;t have any more for it. But, a/b/ should *not*
// match &quot;a/b/*&quot;, even though &quot;&quot; matches against the
// [^/]*? pattern, except in partial mode, where it might
// simply not be reached yet.
// However, a/b/ should still satisfy a/*

// now either we fell off the end of the pattern, or we&#39;re done.
if (fi === fl &amp;&amp; pi === pl) {
  // ran out of pattern and filename at the same time.
  // an exact hit!
  return true
} else if (fi === fl) {
  // ran out of file, but still had pattern left.
  // this is ok if we&#39;re doing the match as part of
  // a glob fs traversal.
  return partial
} else if (pi === pl) {
  // ran out of pattern, still have file left.
  // this is only acceptable if we&#39;re on the very last
  // empty segment of a file with a trailing slash.
  // a/* should match a/b/
  var emptyFileEnd = (fi === fl - 1) &amp;&amp; (file[fi] === &quot;&quot;)
  return emptyFileEnd
}

// should be unreachable.
throw new Error(&quot;wtf?&quot;)</code></pre>

<p>}</p>

<p>// replace stuff like * with * function globUnescape (s) {</p>

<pre><code>return s.replace(/\\(.)/g, &quot;$1&quot;)</code></pre>

<p>}</p>

<p>function regExpEscape (s) {</p>

<pre><code>return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &quot;\\$&amp;&quot;)</code></pre>

<p>}</p>

<p>}).call(this,require(&#39;_process&#39;))
},{“_process”:5,“brace-expansion”:2}],2:[function(require,module,exports){
var concatMap = require(&#39;concat-map&#39;); var balanced =
require(&#39;balanced-match&#39;);</p>

<p>module.exports = expandTop;</p>

<p>var escSlash = &#39;0SLASH&#39;+Math.random()+&#39;0&#39;; var escOpen =
&#39;0OPEN&#39;+Math.random()+&#39;0&#39;; var escClose =
&#39;0CLOSE&#39;+Math.random()+&#39;0&#39;; var escComma =
&#39;0COMMA&#39;+Math.random()+&#39;0&#39;; var escPeriod =
&#39;0PERIOD&#39;+Math.random()+&#39;0&#39;;</p>

<p>function numeric(str) {</p>

<pre><code>return parseInt(str, 10) == str
  ? parseInt(str, 10)
  : str.charCodeAt(0);</code></pre>

<p>}</p>

<p>function escapeBraces(str) {</p>

<pre><code>return str.split(&#39;\\\\&#39;).join(escSlash)
          .split(&#39;\\{&#39;).join(escOpen)
          .split(&#39;\\}&#39;).join(escClose)
          .split(&#39;\\,&#39;).join(escComma)
          .split(&#39;\\.&#39;).join(escPeriod);
</code></pre>

<p>}</p>

<p>function unescapeBraces(str) {</p>

<pre><code>return str.split(escSlash).join(&#39;\\&#39;)
          .split(escOpen).join(&#39;{&#39;)
          .split(escClose).join(&#39;}&#39;)
          .split(escComma).join(&#39;,&#39;)
          .split(escPeriod).join(&#39;.&#39;);
</code></pre>

<p>}</p>

<p>// Basically just str.split(“,”), but handling <a
href="node_modules/brace-expansion/test/cases_txt.html">cases</a> // where
we have nested braced sections, which should be // treated as individual
members, like {a,{b,c},d} function parseCommaParts(str) {</p>

<pre><code>if (!str)
  return [&#39;&#39;];

var parts = [];
var m = balanced(&#39;{&#39;, &#39;}&#39;, str);

if (!m)
  return str.split(&#39;,&#39;);

var pre = m.pre;
var body = m.body;
var post = m.post;
var p = pre.split(&#39;,&#39;);

p[p.length-1] += &#39;{&#39; + body + &#39;}&#39;;
var postParts = parseCommaParts(post);
if (post.length) {
  p[p.length-1] += postParts.shift();
  p.push.apply(p, postParts);
}

parts.push.apply(parts, p);

return parts;</code></pre>

<p>}</p>

<p>function expandTop(str) {</p>

<pre><code>if (!str)
  return [];

var expansions = expand(escapeBraces(str));
return expansions.filter(identity).map(unescapeBraces);</code></pre>

<p>}</p>

<p>function identity(e) {</p>

<pre><code>return e;
</code></pre>

<p>}</p>

<p>function embrace(str) {</p>

<pre><code>return &#39;{&#39; + str + &#39;}&#39;;
</code></pre>

<p>} function isPadded(el) {</p>

<pre><code>return /^-?0\d/.test(el);
</code></pre>

<p>}</p>

<p>function lte(i, y) {</p>

<pre><code>return i &lt;= y;
</code></pre>

<p>} function gte(i, y) {</p>

<pre><code>return i &gt;= y;
</code></pre>

<p>}</p>

<p>function expand(str) {</p>

<pre><code>var expansions = [];

var m = balanced(&#39;{&#39;, &#39;}&#39;, str);
if (!m || /\$$/.test(m.pre)) return [str];

var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
var isSequence = isNumericSequence || isAlphaSequence;
var isOptions = /^(.*,)+(.+)?$/.test(m.body);
if (!isSequence &amp;&amp; !isOptions) {
  // {a},b}
  if (m.post.match(/,.*}/)) {
    str = m.pre + &#39;{&#39; + m.body + escClose + m.post;
    return expand(str);
  }
  return [str];
}

var n;
if (isSequence) {
  n = m.body.split(/\.\./);
} else {
  n = parseCommaParts(m.body);
  if (n.length === 1) {
    // x{{a,b}}y ==&gt; x{a}y x{b}y
    n = expand(n[0]).map(embrace);
    if (n.length === 1) {
      var post = m.post.length
        ? expand(m.post)
        : [&#39;&#39;];
      return post.map(function(p) {
        return m.pre + n[0] + p;
      });
    }
  }
}

// at this point, n is the parts, and we know it&#39;s not a comma set
// with a single entry.

// no need to expand pre, since it is guaranteed to be free of brace-sets
var pre = m.pre;
var post = m.post.length
  ? expand(m.post)
  : [&#39;&#39;];

var N;

if (isSequence) {
  var x = numeric(n[0]);
  var y = numeric(n[1]);
  var width = Math.max(n[0].length, n[1].length)
  var incr = n.length == 3
    ? Math.abs(numeric(n[2]))
    : 1;
  var test = lte;
  var reverse = y &lt; x;
  if (reverse) {
    incr *= -1;
    test = gte;
  }
  var pad = n.some(isPadded);

  N = [];

  for (var i = x; test(i, y); i += incr) {
    var c;
    if (isAlphaSequence) {
      c = String.fromCharCode(i);
      if (c === &#39;\\&#39;)
        c = &#39;&#39;;
    } else {
      c = String(i);
      if (pad) {
        var need = width - c.length;
        if (need &gt; 0) {
          var z = new Array(need + 1).join(&#39;0&#39;);
          if (i &lt; 0)
            c = &#39;-&#39; + z + c.slice(1);
          else
            c = z + c;
        }
      }
    }
    N.push(c);
  }
} else {
  N = concatMap(n, function(el) { return expand(el) });
}

for (var j = 0; j &lt; N.length; j++) {
  for (var k = 0; k &lt; post.length; k++) {
    expansions.push([pre, N[j], post[k]].join(&#39;&#39;))
  }
}

return expansions;</code></pre>

<p>}</p>

<p>},{“balanced-match”:3,“concat-map”:4}],3:[function(require,module,exports){
module.exports = balanced; function balanced(a, b, str) {</p>

<pre><code>var bal = 0;
var m = {};
var ended = false;

for (var i = 0; i &lt; str.length; i++) {
  if (a == str.substr(i, a.length)) {
    if (!(&#39;start&#39; in m)) m.start = i;
    bal++;
  }
  else if (b == str.substr(i, b.length) &amp;&amp; &#39;start&#39; in m) {
    ended = true;
    bal--;
    if (!bal) {
      m.end = i;
      m.pre = str.substr(0, m.start);
      m.body = (m.end - m.start &gt; 1)
        ? str.substring(m.start + a.length, m.end)
        : &#39;&#39;;
      m.post = str.slice(m.end + b.length);
      return m;
    }
  }
}

// if we opened more than we closed, find the one we closed
if (bal &amp;&amp; ended) {
  var start = m.start + a.length;
  m = balanced(a, b, str.substr(start));
  if (m) {
    m.start += start;
    m.end += start;
    m.pre = str.slice(0, start) + m.pre;
  }
  return m;
}</code></pre>

<p>}</p>

<p>},{}],4:[function(require,module,exports){ module.exports = function (xs,
fn) {</p>

<pre><code>var res = [];
for (var i = 0; i &lt; xs.length; i++) {
    var x = fn(xs[i], i);
    if (Array.isArray(x)) res.push.apply(res, x);
    else res.push(x);
}
return res;</code></pre>

<p>};</p>

<p>},{}],5:[function(require,module,exports){ // shim for using process in
browser</p>

<p>var process = module.exports = {};</p>

<p>process.nextTick = (function () {</p>

<pre><code>var canSetImmediate = typeof window !== &#39;undefined&#39;
&amp;&amp; window.setImmediate;
var canMutationObserver = typeof window !== &#39;undefined&#39;
&amp;&amp; window.MutationObserver;
var canPost = typeof window !== &#39;undefined&#39;
&amp;&amp; window.postMessage &amp;&amp; window.addEventListener
;

if (canSetImmediate) {
    return function (f) { return window.setImmediate(f) };
}

var queue = [];

if (canMutationObserver) {
    var hiddenDiv = document.createElement(&quot;div&quot;);
    var observer = new MutationObserver(function () {
        var queueList = queue.slice();
        queue.length = 0;
        queueList.forEach(function (fn) {
            fn();
        });
    });

    observer.observe(hiddenDiv, { attributes: true });

    return function nextTick(fn) {
        if (!queue.length) {
            hiddenDiv.setAttribute(&#39;yes&#39;, &#39;no&#39;);
        }
        queue.push(fn);
    };
}

if (canPost) {
    window.addEventListener(&#39;message&#39;, function (ev) {
        var source = ev.source;
        if ((source === window || source === null) &amp;&amp; ev.data === &#39;process-tick&#39;) {
            ev.stopPropagation();
            if (queue.length &gt; 0) {
                var fn = queue.shift();
                fn();
            }
        }
    }, true);

    return function nextTick(fn) {
        queue.push(fn);
        window.postMessage(&#39;process-tick&#39;, &#39;*&#39;);
    };
}

return function nextTick(fn) {
    setTimeout(fn, 0);
};</code></pre>

<p>})();</p>

<p>process.title = &#39;browser&#39;; process.browser = true; process.env =
{}; process.argv = [];</p>

<p>function noop() {}</p>

<p>process.on = noop; process.addListener = noop; process.once = noop;
process.off = noop; process.removeListener = noop;
process.removeAllListeners = noop; process.emit = noop;</p>

<p>process.binding = function (name) {</p>

<pre><code>throw new Error(&#39;process.binding is not supported&#39;);
</code></pre>

<p>};</p>

<p>// TODO(shtylman) process.cwd = function () { return &#39;/&#39; };
process.chdir = function (dir) {</p>

<pre><code>throw new Error(&#39;process.chdir is not supported&#39;);
</code></pre>

<p>};</p>

<p>},{}]},{},[1]);</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
