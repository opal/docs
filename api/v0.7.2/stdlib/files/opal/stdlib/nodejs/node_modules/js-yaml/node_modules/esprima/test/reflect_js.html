<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>reflect.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            reflect.js
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/js-yaml/node_modules/esprima/test/reflect.js</li>
            <li>Last modified: 2015-08-29 16:13:52 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>// This is modified from Mozilla Reflect.parse test suite (the file is
located // at js/src/tests/js1_8_5/extensions/reflect-parse.js in the
source tree). // // Some notable changes: //   * Removed unsupported
features (destructuring, let, comprehensions…). //   * Removed tests for
E4X (ECMAScript for XML). //   * Removed everything related to builder. // 
* Enclosed every &#39;Pattern&#39; construct with a scope. //   * Tweaked
some expected tree to remove generator field. //   * Removed the test for
bug 632030 and bug 632024.</p>

<pre><code>-*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</code></pre>

<p>/*</p>

<pre><code> Any copyright is dedicated to the Public Domain.
 http://creativecommons.org/licenses/publicdomain/
/</code></pre>

<p>(function (exports) {</p>

<p>function testReflect(Reflect, Pattern) {</p>

<p>function program(elts) { return Pattern({ type: “Program”, body: elts }) }
function exprStmt(expr) { return Pattern({ type: “ExpressionStatement”,
expression: expr }) } function throwStmt(expr) { return Pattern({ type:
“ThrowStatement”, argument: expr }) } function returnStmt(expr) { return
Pattern({ type: “ReturnStatement”, argument: expr }) } function
yieldExpr(expr) { return Pattern({ type: “YieldExpression”, argument: expr
}) } function lit(val) { return Pattern({ type: “Literal”, value: val }) }
var thisExpr = Pattern({ type: “ThisExpression” }); function funDecl(id,
params, body) { return Pattern({ type: “FunctionDeclaration”,</p>

<pre><code>id: id,
params: params,
defaults: [],
body: body,
rest: null,
generator: false,
expression: false
}) }</code></pre>

<p>function genFunDecl(id, params, body) { return Pattern({ type:
“FunctionDeclaration”,</p>

<pre><code>id: id,
params: params,
defaults: [],
body: body,
rest: null,
generator: false,
expression: false
}) }</code></pre>

<p>function declarator(id, init) { return Pattern({ type:
“VariableDeclarator”, id: id, init: init }) } function varDecl(decls) {
return Pattern({ type: “VariableDeclaration”, declarations: decls, kind:
“var” }) } function letDecl(decls) { return Pattern({ type:
“VariableDeclaration”, declarations: decls, kind: “let” }) } function
constDecl(decls) { return Pattern({ type: “VariableDeclaration”,
declarations: decls, kind: “const” }) } function ident(name) { return
Pattern({ type: “Identifier”, name: name }) } function dotExpr(obj, id) {
return Pattern({ type: “MemberExpression”, computed: false, object: obj,
property: id }) } function memExpr(obj, id) { return Pattern({ type:
“MemberExpression”, computed: true, object: obj, property: id }) } function
forStmt(init, test, update, body) { return Pattern({ type: “ForStatement”,
init: init, test: test, update: update, body: body }) } function
forInStmt(lhs, rhs, body) { return Pattern({ type: “ForInStatement”, left:
lhs, right: rhs, body: body, each: false }) } function forEachInStmt(lhs,
rhs, body) { return Pattern({ type: “ForInStatement”, left: lhs, right:
rhs, body: body, each: true }) } function breakStmt(lab) { return Pattern({
type: “BreakStatement”, label: lab }) } function continueStmt(lab) { return
Pattern({ type: “ContinueStatement”, label: lab }) } function
blockStmt(body) { return Pattern({ type: “BlockStatement”, body: body }) }
var emptyStmt = Pattern({ type: “EmptyStatement” }); function ifStmt(test,
cons, alt) { return Pattern({ type: “IfStatement”, test: test, alternate:
alt, consequent: cons }) } function labStmt(lab, stmt) { return Pattern({
type: “LabeledStatement”, label: lab, body: stmt }) } function
withStmt(obj, stmt) { return Pattern({ type: “WithStatement”, object: obj,
body: stmt }) } function whileStmt(test, stmt) { return Pattern({ type:
“WhileStatement”, test: test, body: stmt }) } function doStmt(stmt, test) {
return Pattern({ type: “DoWhileStatement”, test: test, body: stmt }) }
function switchStmt(disc, <a
href="../../../../glob/node_modules/minimatch/node_modules/brace-expansion/test/cases_txt.html">cases</a>)
{ return Pattern({ type: “SwitchStatement”, discriminant: disc, <a
href="../../../../glob/node_modules/minimatch/node_modules/brace-expansion/test/cases_txt.html">cases</a>:
<a
href="../../../../glob/node_modules/minimatch/node_modules/brace-expansion/test/cases_txt.html">cases</a>
}) } function caseClause(test, stmts) { return Pattern({ type:
“SwitchCase”, test: test, consequent: stmts }) } function
defaultClause(stmts) { return Pattern({ type: “SwitchCase”, test: null,
consequent: stmts }) } function catchClause(id, guard, body) { if (guard) {
return Pattern({ type: “GuardedCatchClause”, param: id, guard: guard, body:
body }) } else { return Pattern({ type: “CatchClause”, param: id, body:
body }) } } function tryStmt(body, guarded, catches, fin) { return
Pattern({ type: “TryStatement”, block: body, guardedHandlers: guarded,
handlers: catches, finalizer: fin }) } function letStmt(head, body) {
return Pattern({ type: “LetStatement”, head: head, body: body }) } function
funExpr(id, args, body, gen) { return Pattern({ type: “FunctionExpression”,</p>

<pre><code>id: id,
params: args,
defaults: [],
body: body,
rest: null,
generator: false,
expression: false
}) }</code></pre>

<p>function genFunExpr(id, args, body) { return Pattern({ type:
“FunctionExpression”,</p>

<pre><code>id: id,
params: args,
defaults: [],
body: body,
rest: null,
generator: false,
expression: false
}) }</code></pre>

<p>function unExpr(op, arg) { return Pattern({ type: “UnaryExpression”,
operator: op, argument: arg, prefix: true }) } function binExpr(op, left,
right) { return Pattern({ type: “BinaryExpression”, operator: op, left:
left, right: right }) } function aExpr(op, left, right) { return Pattern({
type: “AssignmentExpression”, operator: op, left: left, right: right }) }
function updExpr(op, arg, prefix) { return Pattern({ type:
“UpdateExpression”, operator: op, argument: arg, prefix: prefix }) }
function logExpr(op, left, right) { return Pattern({ type:
“LogicalExpression”, operator: op, left: left, right: right }) }</p>

<p>function condExpr(test, cons, alt) { return Pattern({ type:
“ConditionalExpression”, test: test, consequent: cons, alternate: alt }) }
function seqExpr(exprs) { return Pattern({ type: “SequenceExpression”,
expressions: exprs }) } function newExpr(callee, args) { return Pattern({
type: “NewExpression”, callee: callee, arguments: args }) } function
callExpr(callee, args) { return Pattern({ type: “CallExpression”, callee:
callee, arguments: args }) } function arrExpr(elts) { return Pattern({
type: “ArrayExpression”, elements: elts }) } function objExpr(elts) {
return Pattern({ type: “ObjectExpression”, properties: elts }) } function
objProp(key, value, kind) { return Pattern({ type: “Property”, key: key,
value: value, kind: kind }) }</p>

<p>function arrPatt(elts) { return Pattern({ type: “ArrayPattern”, elements:
elts }) } function objPatt(elts) { return Pattern({ type: “ObjectPattern”,
properties: elts }) }</p>

<p>function localSrc(src) { return “(function(){ ” + src + “ })” } function
localPatt(patt) { return program([exprStmt(funExpr(null, [], <a
href="patt">blockStmt(</a>)))]) } function blockSrc(src) { return
“(function(){ { ” + src + “ } })” } function blockPatt(patt) { return
program([exprStmt(funExpr(null, [], <a
href="patt">blockStmt([blockStmt(</a>)])))]) }</p>

<p>function assertBlockStmt(src, patt) {</p>

<pre><code>blockPatt(patt).assert(Reflect.parse(blockSrc(src)));
</code></pre>

<p>}</p>

<p>function assertBlockExpr(src, patt) {</p>

<pre><code>assertBlockStmt(src, exprStmt(patt));
</code></pre>

<p>}</p>

<p>function assertBlockDecl(src, patt, builder) {</p>

<pre><code>blockPatt(patt).assert(Reflect.parse(blockSrc(src), {builder: builder}));
</code></pre>

<p>}</p>

<p>function assertLocalStmt(src, patt) {</p>

<pre><code>localPatt(patt).assert(Reflect.parse(localSrc(src)));
</code></pre>

<p>}</p>

<p>function assertLocalExpr(src, patt) {</p>

<pre><code>assertLocalStmt(src, exprStmt(patt));
</code></pre>

<p>}</p>

<p>function assertLocalDecl(src, patt) {</p>

<pre><code>localPatt(patt).assert(Reflect.parse(localSrc(src)));
</code></pre>

<p>}</p>

<p>function assertGlobalStmt(src, patt, builder) {</p>

<pre><code>program([patt]).assert(Reflect.parse(src, {builder: builder}));
</code></pre>

<p>}</p>

<p>function assertGlobalExpr(src, patt, builder) {</p>

<pre><code>program([exprStmt(patt)]).assert(Reflect.parse(src, {builder: builder}));
//assertStmt(src, exprStmt(patt));</code></pre>

<p>}</p>

<p>function assertGlobalDecl(src, patt) {</p>

<pre><code>program([patt]).assert(Reflect.parse(src));
</code></pre>

<p>}</p>

<p>function assertProg(src, patt) {</p>

<pre><code>program(patt).assert(Reflect.parse(src));
</code></pre>

<p>}</p>

<p>function assertStmt(src, patt) {</p>

<pre><code>assertLocalStmt(src, patt);
assertGlobalStmt(src, patt);
assertBlockStmt(src, patt);
</code></pre>

<p>}</p>

<p>function assertExpr(src, patt) {</p>

<pre><code>assertLocalExpr(src, patt);
assertGlobalExpr(src, patt);
assertBlockExpr(src, patt);
</code></pre>

<p>}</p>

<p>function assertDecl(src, patt) {</p>

<pre><code>assertLocalDecl(src, patt);
assertGlobalDecl(src, patt);
assertBlockDecl(src, patt);
</code></pre>

<p>}</p>

<p>function assertError(src, errorType) {</p>

<pre><code>try {
    Reflect.parse(src);
} catch (e) {
    return;
}
throw new Error(&quot;expected &quot; + errorType.name + &quot; for &quot; + uneval(src));</code></pre>

<p>}</p>

<p>// general tests</p>

<p>// NB: These are useful but for now jit-test doesn&#39;t do I/O reliably.</p>

<p>//program(_).assert(Reflect.parse(snarf(&#39;data/flapjax.txt&#39;)));
//program(_).assert(Reflect.parse(snarf(&#39;data/jquery-1.4.2.txt&#39;)));
//program(_).assert(Reflect.parse(snarf(&#39;data/prototype.js&#39;)));
//program(_).assert(Reflect.parse(snarf(&#39;data/dojo.js.uncompressed.js&#39;)));
//program(_).assert(Reflect.parse(snarf(&#39;data/mootools-1.2.4-core-nc.js&#39;)));</p>

<p>// declarations</p>

<p>assertDecl(“var x = 1, y = 2, z = 3”,</p>

<pre><code>varDecl([declarator(ident(&quot;x&quot;), lit(1)),
         declarator(ident(&quot;y&quot;), lit(2)),
         declarator(ident(&quot;z&quot;), lit(3))]));</code></pre>

<p>assertDecl(“var x, y, z”,</p>

<pre><code>varDecl([declarator(ident(&quot;x&quot;), null),
         declarator(ident(&quot;y&quot;), null),
         declarator(ident(&quot;z&quot;), null)]));</code></pre>

<p>assertDecl(“function foo() { }”,</p>

<pre><code>funDecl(ident(&quot;foo&quot;), [], blockStmt([])));</code></pre>

<p>assertDecl(“function foo() { return 42 }”,</p>

<pre><code>funDecl(ident(&quot;foo&quot;), [], blockStmt([returnStmt(lit(42))])));</code></pre>

<p>// Bug 591437: rebound args have their defs turned into uses
assertDecl(“function f(a) { function a() { } }”,</p>

<pre><code>funDecl(ident(&quot;f&quot;), [ident(&quot;a&quot;)], blockStmt([funDecl(ident(&quot;a&quot;), [], blockStmt([]))])));</code></pre>

<p>assertDecl(“function f(a,b,c) { function b() { } }”,</p>

<pre><code>funDecl(ident(&quot;f&quot;), [ident(&quot;a&quot;),ident(&quot;b&quot;),ident(&quot;c&quot;)], blockStmt([funDecl(ident(&quot;b&quot;), [], blockStmt([]))])));</code></pre>

<p>// expressions</p>

<p>assertExpr(“true”, lit(true)); assertExpr(“false”, lit(false));
assertExpr(“42”, lit(42)); assertExpr(“(/asdf/)”, lit(/asdf/));
assertExpr(“this”, thisExpr); assertExpr(“foo”, ident(“foo”));
assertExpr(“foo.bar”, dotExpr(ident(“foo”), ident(“bar”))); <a
href="bar">assertExpr(“foo</a>”, memExpr(ident(“foo”), ident(“bar”)));
assertExpr(“(function(){})”, funExpr(null, [], blockStmt([])));
assertExpr(“(function f() {})”, funExpr(ident(“f”), [], blockStmt([])));
assertExpr(“(function f(x,y,z) {})”, funExpr(ident(“f”),
[ident(“x”),ident(“y”),ident(“z”)], blockStmt([]))); assertExpr(“(++x)”,
updExpr(“++”, ident(“x”), true)); assertExpr(“(x++)”, updExpr(“++”,
ident(“x”), false)); assertExpr(“(+x)”, unExpr(“+”, ident(“x”)));
assertExpr(“(-x)”, unExpr(“-”, ident(“x”))); assertExpr(“(!x)”, unExpr(“!”,
ident(“x”))); assertExpr(“(~x)”, unExpr(“~”, ident(“x”)));
assertExpr(“(delete x)”, unExpr(“delete”, ident(“x”))); assertExpr(“(typeof
x)”, unExpr(“typeof”, ident(“x”))); assertExpr(“(void x)”, unExpr(“void”,
ident(“x”))); assertExpr(“(x == y)”, binExpr(“==”, ident(“x”),
ident(“y”))); assertExpr(“(x != y)”, binExpr(“!=”, ident(“x”),
ident(“y”))); assertExpr(“(x === y)”, binExpr(“===”, ident(“x”),
ident(“y”))); assertExpr(“(x !== y)”, binExpr(“!==”, ident(“x”),
ident(“y”))); assertExpr(“(x &lt; y)”, binExpr(“&lt;”, ident(“x”),
ident(“y”))); assertExpr(“(x &lt;= y)”, binExpr(“&lt;=”, ident(“x”),
ident(“y”))); assertExpr(“(x &gt; y)”, binExpr(“&gt;”, ident(“x”),
ident(“y”))); assertExpr(“(x &gt;= y)”, binExpr(“&gt;=”, ident(“x”),
ident(“y”))); assertExpr(“(x << y)&quot;, binExpr(&quot;&lt;&lt;&quot;,
ident(&quot;x&quot;), ident(&quot;y&quot;))); assertExpr(&quot;(x >> y)”,
binExpr(“&gt;&gt;”, ident(“x”), ident(“y”))); assertExpr(“(x >>&gt; y)”,
binExpr(“&gt;&gt;&gt;”, ident(“x”), ident(“y”))); assertExpr(“(x + y)”,
binExpr(“+”, ident(“x”), ident(“y”))); assertExpr(“(w + x + y + z)”,
binExpr(“+”, binExpr(“+”, binExpr(“+”, ident(“w”), ident(“x”)),
ident(“y”)), ident(“z”))); assertExpr(“(x - y)”, binExpr(“-”, ident(“x”),
ident(“y”))); assertExpr(“(w - x - y - z)”, binExpr(“-”, binExpr(“-”,
binExpr(“-”, ident(“w”), ident(“x”)), ident(“y”)), ident(“z”)));
assertExpr(“(x * y)”, binExpr(“*”, ident(“x”), ident(“y”))); assertExpr(“(x
/ y)”, binExpr(“/”, ident(“x”), ident(“y”))); assertExpr(“(x % y)”,
binExpr(“%”, ident(“x”), ident(“y”))); assertExpr(“(x | y)”, binExpr(“|”,
ident(“x”), ident(“y”))); assertExpr(“(x ^ y)”, binExpr(“^”, ident(“x”),
ident(“y”))); assertExpr(“(x &amp; y)”, binExpr(“&amp;”, ident(“x”),
ident(“y”))); assertExpr(“(x in y)”, binExpr(“in”, ident(“x”),
ident(“y”))); assertExpr(“(x instanceof y)”, binExpr(“instanceof”,
ident(“x”), ident(“y”))); assertExpr(“(x = y)”, aExpr(“=”, ident(“x”),
ident(“y”))); assertExpr(“(x += y)”, aExpr(“+=”, ident(“x”), ident(“y”)));
assertExpr(“(x -= y)”, aExpr(“-=”, ident(“x”), ident(“y”))); assertExpr(“(x
*= y)”, aExpr(“*=”, ident(“x”), ident(“y”))); assertExpr(“(x /= y)”,
aExpr(“/=”, ident(“x”), ident(“y”))); assertExpr(“(x %= y)”, aExpr(“%=”,
ident(“x”), ident(“y”))); assertExpr(“(x <<= y)&quot;,
aExpr(&quot;&lt;&lt;=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x >>= y)”, aExpr(“&gt;&gt;=”, ident(“x”), ident(“y”)));
assertExpr(“(x >>&gt;= y)”, aExpr(“&gt;&gt;&gt;=”, ident(“x”),
ident(“y”))); assertExpr(“(x |= y)”, aExpr(“|=”, ident(“x”), ident(“y”)));
assertExpr(“(x ^= y)”, aExpr(“^=”, ident(“x”), ident(“y”))); assertExpr(“(x
&amp;= y)”, aExpr(“&amp;=”, ident(“x”), ident(“y”))); assertExpr(“(x ||
y)”, logExpr(“||”, ident(“x”), ident(“y”))); assertExpr(“(x &amp;&amp; y)”,
logExpr(“&amp;&amp;”, ident(“x”), ident(“y”))); assertExpr(“(w || x || y ||
z)”, logExpr(“||”, logExpr(“||”, logExpr(“||”, ident(“w”), ident(“x”)),
ident(“y”)), ident(“z”))) assertExpr(“(x ? y : z)”, condExpr(ident(“x”),
ident(“y”), ident(“z”))); assertExpr(“(x,y)”, <a
href="ident("x"),ident("y")">seqExpr(</a>)) assertExpr(“(x,y,z)”, <a
href="ident("x"),ident("y"),ident("z")">seqExpr(</a>))
assertExpr(“(a,b,c,d,e,f,g)”, <a
href="ident("a"),ident("b"),ident("c"),ident("d"),ident("e"),ident("f"),ident("g")">seqExpr(</a>));
assertExpr(“(new <a
href="../../../../../../../../../classes/Object.html">Object</a>)”,
newExpr(ident(“Object”), [])); assertExpr(“(new Object())”,
newExpr(ident(“Object”), [])); assertExpr(“(new Object(42))”,
newExpr(ident(“Object”), [lit(42)])); assertExpr(“(new Object(1,2,3))”,
newExpr(ident(“Object”), [lit(1),lit(2),lit(3)])); assertExpr(“(String())”,
callExpr(ident(“String”), [])); assertExpr(“(String(42))”,
callExpr(ident(“String”), [lit(42)])); assertExpr(“(String(1,2,3))”,
callExpr(ident(“String”), [lit(1),lit(2),lit(3)])); assertExpr(“[]”,
arrExpr([])); <a href="1">assertExpr(“</a>”, <a
href="lit(1)">arrExpr(</a>)); <a href="1,2">assertExpr(“</a>”, <a
href="lit(1),lit(2)">arrExpr(</a>)); <a href="1,2,3">assertExpr(“</a>”, <a
href="lit(1),lit(2),lit(3)">arrExpr(</a>)); <a
href="1,,2,3">assertExpr(“</a>”, <a
href="lit(1),,lit(2),lit(3)">arrExpr(</a>)); <a
href="1,,,2,3">assertExpr(“</a>”, <a
href="lit(1),,,lit(2),lit(3)">arrExpr(</a>)); <a
href="1,,,2,,3">assertExpr(“</a>”, <a
href="lit(1),,,lit(2),,lit(3)">arrExpr(</a>)); <a
href="1,,,2,,,3">assertExpr(“</a>”, <a
href="lit(1),,,lit(2),,,lit(3)">arrExpr(</a>)); <a
href=",1,2,3">assertExpr(“</a>”, <a
href=",lit(1),lit(2),lit(3)">arrExpr(</a>)); <a
href=",,1,2,3">assertExpr(“</a>”, <a
href=",,lit(1),lit(2),lit(3)">arrExpr(</a>)); <a
href=",,,1,2,3">assertExpr(“</a>”, <a
href=",,,lit(1),lit(2),lit(3)">arrExpr(</a>)); <a
href=",,,1,2,3,">assertExpr(“</a>”, <a
href=",,,lit(1),lit(2),lit(3)">arrExpr(</a>)); <a
href=",,,1,2,3,,">assertExpr(“</a>”, <a
href=",,,lit(1),lit(2),lit(3),undefined">arrExpr(</a>)); <a
href=",,,1,2,3,,,">assertExpr(“</a>”, <a
href=",,,lit(1),lit(2),lit(3),undefined,undefined">arrExpr(</a>)); <a
href=",,,,,">assertExpr(“</a>”, <a
href="undefined,undefined,undefined,undefined,undefined">arrExpr(</a>));
assertExpr(“({})”, objExpr([])); assertExpr(“({x:1})”,
objExpr([objProp(ident(“x”), lit(1), “init”)])); assertExpr(“({x:1, y:2})”,
objExpr([objProp(ident(“x”), lit(1), “init”),</p>

<pre><code>objProp(ident(&quot;y&quot;), lit(2), &quot;init&quot;)]));</code></pre>

<p>assertExpr(“({x:1, y:2, z:3})”, objExpr([objProp(ident(“x”), lit(1),
“init”),</p>

<pre><code>objProp(ident(&quot;y&quot;), lit(2), &quot;init&quot;),
objProp(ident(&quot;z&quot;), lit(3), &quot;init&quot;) ]));</code></pre>

<p>assertExpr(“({x:1, &#39;y&#39;:2, z:3})”, objExpr([objProp(ident(“x”),
lit(1), “init”),</p>

<pre><code>objProp(lit(&quot;y&quot;), lit(2), &quot;init&quot;),
objProp(ident(&quot;z&quot;), lit(3), &quot;init&quot;) ]));</code></pre>

<p>assertExpr(“({&#39;x&#39;:1, &#39;y&#39;:2, z:3})”,
objExpr([objProp(lit(“x”), lit(1), “init”),</p>

<pre><code>objProp(lit(&quot;y&quot;), lit(2), &quot;init&quot;),
objProp(ident(&quot;z&quot;), lit(3), &quot;init&quot;) ]));</code></pre>

<p>assertExpr(“({&#39;x&#39;:1, &#39;y&#39;:2, 3:3})”,
objExpr([objProp(lit(“x”), lit(1), “init”),</p>

<pre><code>objProp(lit(&quot;y&quot;), lit(2), &quot;init&quot;),
objProp(lit(3), lit(3), &quot;init&quot;) ]));</code></pre>

<p>// Bug 571617: eliminate constant-folding assertExpr(“2 + 3”, binExpr(“+”,
lit(2), lit(3)));</p>

<p>// Bug 632026: constant-folding assertExpr(“typeof(0?0:a)”,
unExpr(“typeof”, condExpr(lit(0), lit(0), ident(“a”))));</p>

<p>// Bug 632056: constant-folding program([exprStmt(ident(“f”)),</p>

<pre><code>ifStmt(lit(1),
       funDecl(ident(&quot;f&quot;), [], blockStmt([])),
       null)]).assert(Reflect.parse(&quot;f; if (1) function f(){}&quot;));</code></pre>

<p>// statements</p>

<p>assertStmt(“throw 42”, throwStmt(lit(42))); assertStmt(“for (;;) break”,
forStmt(null, null, null, breakStmt(null))); assertStmt(“for (x; y; z)
break”, forStmt(ident(“x”), ident(“y”), ident(“z”), breakStmt(null)));
assertStmt(“for (var x; y; z) break”,
forStmt(varDecl([declarator(ident(“x”), null)]), ident(“y”), ident(“z”),
breakStmt(null))); assertStmt(“for (var x = 42; y; z) break”,
forStmt(varDecl([declarator(ident(“x”), lit(42))]), ident(“y”), ident(“z”),
breakStmt(null))); assertStmt(“for (x; ; z) break”, forStmt(ident(“x”),
null, ident(“z”), breakStmt(null))); assertStmt(“for (var x; ; z) break”,
forStmt(varDecl([declarator(ident(“x”), null)]), null, ident(“z”),
breakStmt(null))); assertStmt(“for (var x = 42; ; z) break”,
forStmt(varDecl([declarator(ident(“x”), lit(42))]), null, ident(“z”),
breakStmt(null))); assertStmt(“for (x; y; ) break”, forStmt(ident(“x”),
ident(“y”), null, breakStmt(null))); assertStmt(“for (var x; y; ) break”,
forStmt(varDecl([declarator(ident(“x”), null)]), ident(“y”), null,
breakStmt(null))); assertStmt(“for (var x = 42; y; ) break”, <a
href="declarator(ident("x"),lit(42))">forStmt(varDecl(</a>), ident(“y”),
null, breakStmt(null))); assertStmt(“for (var x in y) break”, <a
href="declarator(ident("x"),null)">forInStmt(varDecl(</a>), ident(“y”),
breakStmt(null))); assertStmt(“for (x in y) break”, forInStmt(ident(“x”),
ident(“y”), breakStmt(null))); assertStmt(“{ }”, blockStmt([]));
assertStmt(“{ throw 1; throw 2; throw 3; }”, blockStmt([ throwStmt(lit(1)),
throwStmt(lit(2)), throwStmt(lit(3))])); assertStmt(“;”, emptyStmt);
assertStmt(“if (foo) throw 42;”, ifStmt(ident(“foo”), throwStmt(lit(42)),
null)); assertStmt(“if (foo) throw 42; else true;”, ifStmt(ident(“foo”),
throwStmt(lit(42)), exprStmt(lit(true)))); assertStmt(“if (foo) { throw 1;
throw 2; throw 3; }”,</p>

<pre><code>ifStmt(ident(&quot;foo&quot;),
       blockStmt([throwStmt(lit(1)), throwStmt(lit(2)), throwStmt(lit(3))]),
       null));</code></pre>

<p>assertStmt(“if (foo) { throw 1; throw 2; throw 3; } else true;”,</p>

<pre><code>ifStmt(ident(&quot;foo&quot;),
       blockStmt([throwStmt(lit(1)), throwStmt(lit(2)), throwStmt(lit(3))]),
       exprStmt(lit(true))));</code></pre>

<p>assertStmt(“foo: for(;;) break foo;”, labStmt(ident(“foo”), forStmt(null,
null, null, breakStmt(ident(“foo”))))); assertStmt(“foo: for(;;) continue
foo;”, labStmt(ident(“foo”), forStmt(null, null, null,
continueStmt(ident(“foo”))))); assertStmt(“with (obj) { }”,
withStmt(ident(“obj”), blockStmt([]))); assertStmt(“with (obj) { obj; }”,
withStmt(ident(“obj”), <a href="exprStmt(ident("obj"))">blockStmt(</a>)));
assertStmt(“while (foo) { }”, whileStmt(ident(“foo”), blockStmt([])));
assertStmt(“while (foo) { foo; }”, whileStmt(ident(“foo”), <a
href="exprStmt(ident("foo"))">blockStmt(</a>))); assertStmt(“do { } while
(foo);”, doStmt(blockStmt([]), ident(“foo”))); assertStmt(“do { foo; }
while (foo)”, <a href="exprStmt(ident("foo"))">doStmt(blockStmt(</a>),
ident(“foo”))); assertStmt(“switch (foo) { case 1: 1; break; case 2: 2;
break; default: 3; }”,</p>

<pre><code>switchStmt(ident(&quot;foo&quot;),
           [ caseClause(lit(1), [ exprStmt(lit(1)), breakStmt(null) ]),
             caseClause(lit(2), [ exprStmt(lit(2)), breakStmt(null) ]),
             defaultClause([ exprStmt(lit(3)) ]) ]));</code></pre>

<p>assertStmt(“switch (foo) { case 1: 1; break; case 2: 2; break; default: 3;
case 42: 42; }”,</p>

<pre><code>switchStmt(ident(&quot;foo&quot;),
           [ caseClause(lit(1), [ exprStmt(lit(1)), breakStmt(null) ]),
             caseClause(lit(2), [ exprStmt(lit(2)), breakStmt(null) ]),
             defaultClause([ exprStmt(lit(3)) ]),
             caseClause(lit(42), [ exprStmt(lit(42)) ]) ]));</code></pre>

<p>assertStmt(“try { } catch (e) { }”,</p>

<pre><code>tryStmt(blockStmt([]),
        [],
        [ catchClause(ident(&quot;e&quot;), null, blockStmt([])) ],
        null));</code></pre>

<p>assertStmt(“try { } catch (e) { } finally { }”,</p>

<pre><code>tryStmt(blockStmt([]),
        [],
        [ catchClause(ident(&quot;e&quot;), null, blockStmt([])) ],
        blockStmt([])));</code></pre>

<p>assertStmt(“try { } finally { }”,</p>

<pre><code>tryStmt(blockStmt([]),
        [],
        [],
        blockStmt([])));</code></pre>

<p>// redeclarations (TOK_NAME nodes with lexdef)</p>

<p>assertStmt(“function f() { function g() { } function g() { } }”,</p>

<pre><code>funDecl(ident(&quot;f&quot;), [], blockStmt([funDecl(ident(&quot;g&quot;), [], blockStmt([])),
                                   funDecl(ident(&quot;g&quot;), [], blockStmt([]))])));</code></pre>

<p>assertStmt(“function f() { function g() { } function g() { return 42 } }”,</p>

<pre><code>funDecl(ident(&quot;f&quot;), [], blockStmt([funDecl(ident(&quot;g&quot;), [], blockStmt([])),
                                   funDecl(ident(&quot;g&quot;), [], blockStmt([returnStmt(lit(42))]))])));</code></pre>

<p>assertStmt(“function f() { var x = 42; var x = 43; }”,</p>

<pre><code>funDecl(ident(&quot;f&quot;), [], blockStmt([varDecl([declarator(ident(&quot;x&quot;),lit(42))]),
                                   varDecl([declarator(ident(&quot;x&quot;),lit(43))])])));</code></pre>

<p>// getters and setters</p>

<pre><code>assertExpr(&quot;({ get x() { return 42 } })&quot;,
           objExpr([ objProp(ident(&quot;x&quot;),
                             funExpr(null, [], blockStmt([returnStmt(lit(42))])),
                             &quot;get&quot; ) ]));
assertExpr(&quot;({ set x(v) { return 42 } })&quot;,
           objExpr([ objProp(ident(&quot;x&quot;),
                             funExpr(null, [ident(&quot;v&quot;)], blockStmt([returnStmt(lit(42))])),
                             &quot;set&quot; ) ]));
</code></pre>

<p>}</p>

<p>exports.testReflect = testReflect;</p>

<p>}(typeof exports === &#39;undefined&#39; ? this : exports));</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
