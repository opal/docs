<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: kernel
  
    &mdash; corelib (Opal v0.8.1)
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "kernel";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: kernel</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <iframe id="search_frame" src="file_list.html"></iframe>

      <div id="content"><div id='filecontents'><pre class="code ruby"><span class='kw'>module</span> <span class='const'>Kernel</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_method_missing'>method_missing</span><span class='lparen'>(</span><span class='id identifier rubyid_symbol'>symbol</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>NoMethodError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>undefined method `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_symbol'>symbol</span><span class='embexpr_end'>}</span><span class='tstring_content'>&#39; for </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_inspect'>inspect</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>=~</span><span class='lparen'>(</span><span class='id identifier rubyid_obj'>obj</span><span class='rparen'>)</span>
    <span class='kw'>false</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>===</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_object_id'>object_id</span> <span class='op'>==</span> <span class='id identifier rubyid_other'>other</span><span class='period'>.</span><span class='id identifier rubyid_object_id'>object_id</span> <span class='op'>||</span> <span class='kw'>self</span> <span class='op'>==</span> <span class='id identifier rubyid_other'>other</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>&lt;=&gt;</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var x = </span><span class='embexpr_beg'>#{</span><span class='kw'>self</span> <span class='op'>==</span> <span class='id identifier rubyid_other'>other</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

      if (x &amp;&amp; x !== nil) {
        return 0;
      }

      return nil;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_method'>method</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var meth = self[&#39;$&#39; + name];

      if (!meth || meth.$$stub) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>NameError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>undefined method `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>&#39; for class `</span><span class='embexpr_beg'>#{</span><span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='embexpr_end'>}</span><span class='tstring_content'>&#39;</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }

      return </span><span class='embexpr_beg'>#{</span><span class='const'>Method</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='kw'>self</span><span class='comma'>,</span> <span class='backtick'>`</span><span class='tstring_content'>meth</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_methods'>methods</span><span class='lparen'>(</span><span class='id identifier rubyid_all'>all</span> <span class='op'>=</span> <span class='kw'>true</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var methods = [];

      for (var key in self) {
        if (key[0] == &quot;$&quot; &amp;&amp; typeof(self[key]) === &quot;function&quot;) {
          if (all == false || all === nil) {
            if (!Opal.hasOwnProperty.call(self, key)) {
              continue;
            }
          }
          if (self[key].$$stub === undefined) {
            methods.push(key.substr(1));
          }
        }
      }

      return methods;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='const'>Array</span><span class='lparen'>(</span><span class='id identifier rubyid_object'>object</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to?'>coerce_to?</span><span class='lparen'>(</span><span class='id identifier rubyid_object'>object</span><span class='comma'>,</span> <span class='const'>Array</span><span class='comma'>,</span> <span class='symbol'>:to_ary</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      if (coerced !== nil) { return coerced; }

      coerced = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to?'>coerce_to?</span><span class='lparen'>(</span><span class='id identifier rubyid_object'>object</span><span class='comma'>,</span> <span class='const'>Array</span><span class='comma'>,</span> <span class='symbol'>:to_a</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      if (coerced !== nil) { return coerced; }

      return [object];
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_at_exit'>at_exit</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='gvar'>$__at_exit__</span> <span class='op'>||=</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>
    <span class='gvar'>$__at_exit__</span> <span class='op'>&lt;&lt;</span> <span class='id identifier rubyid_block'>block</span>
  <span class='kw'>end</span>

  <span class='comment'># Opal does not support #caller, but we stub it as an empty array to not
</span>  <span class='comment'># break dependant libs
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_caller'>caller</span>
    <span class='lbracket'>[</span><span class='rbracket'>]</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='kw'>class</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.$$class</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_copy_instance_variables'>copy_instance_variables</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      for (var name in other) {
        if (name.charAt(0) !== &#39;$&#39;) {
          self[name] = other[name];
        }
      }
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_clone'>clone</span>
    <span class='id identifier rubyid_copy'>copy</span> <span class='op'>=</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='period'>.</span><span class='id identifier rubyid_allocate'>allocate</span>

    <span class='id identifier rubyid_copy'>copy</span><span class='period'>.</span><span class='id identifier rubyid_copy_instance_variables'>copy_instance_variables</span><span class='lparen'>(</span><span class='kw'>self</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_copy'>copy</span><span class='period'>.</span><span class='id identifier rubyid_initialize_clone'>initialize_clone</span><span class='lparen'>(</span><span class='kw'>self</span><span class='rparen'>)</span>

    <span class='id identifier rubyid_copy'>copy</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_initialize_clone'>initialize_clone</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_initialize_copy'>initialize_copy</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_define_singleton_method'>define_singleton_method</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_body'>body</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_body'>body</span> <span class='op'>||=</span> <span class='id identifier rubyid_block'>block</span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_body'>body</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>tried to create Proc object without a block</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      var jsid   = &#39;$&#39; + name;
      body.$$jsid = name;
      body.$$s    = null;
      body.$$def  = body;

      </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_singleton_class'>singleton_class</span><span class='embexpr_end'>}</span><span class='tstring_content'>.$$proto[jsid] = body;

      return self;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_dup'>dup</span>
    <span class='id identifier rubyid_copy'>copy</span> <span class='op'>=</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='period'>.</span><span class='id identifier rubyid_allocate'>allocate</span>

    <span class='id identifier rubyid_copy'>copy</span><span class='period'>.</span><span class='id identifier rubyid_copy_instance_variables'>copy_instance_variables</span><span class='lparen'>(</span><span class='kw'>self</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_copy'>copy</span><span class='period'>.</span><span class='id identifier rubyid_initialize_dup'>initialize_dup</span><span class='lparen'>(</span><span class='kw'>self</span><span class='rparen'>)</span>

    <span class='id identifier rubyid_copy'>copy</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_initialize_dup'>initialize_dup</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_initialize_copy'>initialize_copy</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_enum_for'>enum_for</span><span class='lparen'>(</span><span class='id identifier rubyid_method'>method</span> <span class='op'>=</span> <span class='symbol'>:each</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='const'>Enumerator</span><span class='period'>.</span><span class='id identifier rubyid_for'>for</span><span class='lparen'>(</span><span class='kw'>self</span><span class='comma'>,</span> <span class='id identifier rubyid_method'>method</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_to_enum'>to_enum</span> <span class='id identifier rubyid_enum_for'>enum_for</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_equal?'>equal?</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>self === other</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_exit'>exit</span><span class='lparen'>(</span><span class='id identifier rubyid_status'>status</span> <span class='op'>=</span> <span class='kw'>true</span><span class='rparen'>)</span>
    <span class='gvar'>$__at_exit__</span><span class='period'>.</span><span class='id identifier rubyid_reverse'>reverse</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='symbol'>:call</span><span class='rparen'>)</span> <span class='kw'>if</span> <span class='gvar'>$__at_exit__</span>
    <span class='id identifier rubyid_status'>status</span> <span class='op'>=</span> <span class='int'>0</span> <span class='kw'>if</span> <span class='backtick'>`</span><span class='tstring_content'>status === true</span><span class='tstring_end'>`</span></span> <span class='comment'># it&#39;s in JS because it can be null/undef
</span>    <span class='backtick'>`</span><span class='tstring_content'>Opal.exit(status);</span><span class='tstring_end'>`</span></span>
    <span class='kw'>nil</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_extend'>extend</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_mods'>mods</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var singleton = </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_singleton_class'>singleton_class</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

      for (var i = mods.length - 1; i &gt;= 0; i--) {
        var mod = mods[i];

        </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>mod</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_append_features'>append_features</span> <span class='backtick'>`</span><span class='tstring_content'>singleton</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>mod</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_extended'>extended</span> <span class='kw'>self</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_format'>format</span><span class='lparen'>(</span><span class='id identifier rubyid_format_string'>format_string</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_args'>args</span><span class='period'>.</span><span class='id identifier rubyid_length'>length</span> <span class='op'>==</span> <span class='int'>1</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_args'>args</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_respond_to?'>respond_to?</span><span class='lparen'>(</span><span class='symbol'>:to_ary</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_ary'>ary</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to?'>coerce_to?</span><span class='lparen'>(</span><span class='id identifier rubyid_args'>args</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='comma'>,</span> <span class='const'>Array</span><span class='comma'>,</span> <span class='symbol'>:to_ary</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_args'>args</span> <span class='op'>=</span> <span class='id identifier rubyid_ary'>ary</span><span class='period'>.</span><span class='id identifier rubyid_to_a'>to_a</span> <span class='kw'>unless</span> <span class='id identifier rubyid_ary'>ary</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>
    <span class='kw'>end</span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      var result = &#39;&#39;,
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %&lt;&gt; fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&amp;FWIDTH) { </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>flag after width</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'> }
        if (flags&amp;FPREC0) { </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>flag after precision</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'> }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&amp;FWIDTH) { </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>width given twice</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'> }
        if (flags&amp;FPREC0) { </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>width after precision</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'> }
      }

      function GET_NTH_ARG(num) {
        if (num &gt;= args.length) { </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>too few arguments</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'> }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>unnumbered(</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>seq_arg_num</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>) mixed with numbered</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        case -2: </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>unnumbered(</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>seq_arg_num</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>) mixed with named</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num &gt; 0) {
          </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>numbered(</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>num</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>) after unnumbered(</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>pos_arg_num</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>)</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }
        if (pos_arg_num === -2) {
          </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>numbered(</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>num</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>) after named</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }
        if (num &lt; 1) {
          </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid index - </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>num</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>$</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = &#39;&#39;;
        for (;; i++) {
          if (i === len) {
            </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>malformed format string - %*[0-9]</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
          }
          if (format_string.charCodeAt(i) &lt; 48 || format_string.charCodeAt(i) &gt; 57) {
            i--;
            num = parseInt(str) || 0;
            if (num &gt; 2147483647) {
              </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>label</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'> too big</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === &#39;$&#39;) {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>arg</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_to_int'>to_int</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }

      for (i = format_string.indexOf(&#39;%&#39;); i !== -1; i = format_string.indexOf(&#39;%&#39;, i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case &#39;%&#39;:
          begin_slice = i;
        case &#39;&#39;:
        case &#39;\n&#39;:
        case &#39;\0&#39;:
          i++;
          continue;
        }

        format_sequence: for (; i &lt; len; i++) {
          switch (format_string.charAt(i)) {

          case &#39; &#39;:
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case &#39;#&#39;:
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case &#39;+&#39;:
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case &#39;-&#39;:
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case &#39;0&#39;:
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case &#39;1&#39;:
          case &#39;2&#39;:
          case &#39;3&#39;:
          case &#39;4&#39;:
          case &#39;5&#39;:
          case &#39;6&#39;:
          case &#39;7&#39;:
          case &#39;8&#39;:
          case &#39;9&#39;:
            tmp_num = READ_NUM(&#39;width&#39;);
            if (format_string.charAt(i + 1) === &#39;$&#39;) {
              if (i + 2 === len) {
                str = &#39;%&#39;;
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>value given twice - %</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>tmp_num</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>$</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case &#39;&lt;&#39;:
          case &#39;\{&#39;:
            closing_brace_char = (format_string.charAt(i) === &#39;&lt;&#39; ? &#39;&gt;&#39; : &#39;\}&#39;);
            hash_parameter_key = &#39;&#39;;

            i++;

            for (;; i++) {
              if (i === len) {
                </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>malformed name - unmatched parenthesis</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num &gt; 0) {
                  </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>named </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>hash_parameter_key</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'> after unnumbered(</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>pos_arg_num</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>)</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
                }
                if (pos_arg_num === -1) {
                  </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>named </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>hash_parameter_key</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'> after numbered</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>one hash required</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
                }

                next_arg = </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>args[0]</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_fetch'>fetch</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>hash_parameter_key</span><span class='tstring_end'>`</span></span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

                if (closing_brace_char === &#39;&gt;&#39;) {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&amp;FMINUS) {
                    while (str.length &lt; width) { str = str + &#39; &#39;; }
                  } else {
                    while (str.length &lt; width) { str = &#39; &#39; + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }

          case &#39;*&#39;:
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER(&#39;width&#39;);
            if (width &lt; 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case &#39;.&#39;:
            if (flags&amp;FPREC0) {
              </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>precision given twice</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === &#39;*&#39;) {
              i++;
              precision = READ_NUM_AFTER_ASTER(&#39;precision&#39;);
              if (precision &lt; 0) {
                flags &amp;= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM(&#39;precision&#39;);
            continue format_sequence;

          case &#39;d&#39;:
          case &#39;i&#39;:
          case &#39;u&#39;:
            arg = </span><span class='embexpr_beg'>#{</span><span class='const'>Integer</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>GET_ARG()</span><span class='tstring_end'>`</span></span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
            if (arg &gt;= 0) {
              str = arg.toString();
              while (str.length &lt; precision) { str = &#39;0&#39; + str; }
              if (flags&amp;FMINUS) {
                if (flags&amp;FPLUS || flags&amp;FSPACE) { str = (flags&amp;FPLUS ? &#39;+&#39; : &#39; &#39;) + str; }
                while (str.length &lt; width) { str = str + &#39; &#39;; }
              } else {
                if (flags&amp;FZERO &amp;&amp; precision === -1) {
                  while (str.length &lt; width - ((flags&amp;FPLUS || flags&amp;FSPACE) ? 1 : 0)) { str = &#39;0&#39; + str; }
                  if (flags&amp;FPLUS || flags&amp;FSPACE) { str = (flags&amp;FPLUS ? &#39;+&#39; : &#39; &#39;) + str; }
                } else {
                  if (flags&amp;FPLUS || flags&amp;FSPACE) { str = (flags&amp;FPLUS ? &#39;+&#39; : &#39; &#39;) + str; }
                  while (str.length &lt; width) { str = &#39; &#39; + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length &lt; precision) { str = &#39;0&#39; + str; }
              if (flags&amp;FMINUS) {
                str = &#39;-&#39; + str;
                while (str.length &lt; width) { str = str + &#39; &#39;; }
              } else {
                if (flags&amp;FZERO &amp;&amp; precision === -1) {
                  while (str.length &lt; width - 1) { str = &#39;0&#39; + str; }
                  str = &#39;-&#39; + str;
                } else {
                  str = &#39;-&#39; + str;
                  while (str.length &lt; width) { str = &#39; &#39; + str; }
                }
              }
            }
            break format_sequence;

          case &#39;b&#39;:
          case &#39;B&#39;:
          case &#39;o&#39;:
          case &#39;x&#39;:
          case &#39;X&#39;:
            switch (format_string.charAt(i)) {
            case &#39;b&#39;:
            case &#39;B&#39;:
              base_number = 2;
              base_prefix = &#39;0b&#39;;
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = &#39;1&#39;;
              break;
            case &#39;o&#39;:
              base_number = 8;
              base_prefix = &#39;0&#39;;
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = &#39;7&#39;;
              break;
            case &#39;x&#39;:
            case &#39;X&#39;:
              base_number = 16;
              base_prefix = &#39;0x&#39;;
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = &#39;f&#39;;
              break;
            }
            arg = </span><span class='embexpr_beg'>#{</span><span class='const'>Integer</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>GET_ARG()</span><span class='tstring_end'>`</span></span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
            if (arg &gt;= 0) {
              str = arg.toString(base_number);
              while (str.length &lt; precision) { str = &#39;0&#39; + str; }
              if (flags&amp;FMINUS) {
                if (flags&amp;FPLUS || flags&amp;FSPACE) { str = (flags&amp;FPLUS ? &#39;+&#39; : &#39; &#39;) + str; }
                if (flags&amp;FSHARP &amp;&amp; arg !== 0) { str = base_prefix + str; }
                while (str.length &lt; width) { str = str + &#39; &#39;; }
              } else {
                if (flags&amp;FZERO &amp;&amp; precision === -1) {
                  while (str.length &lt; width - ((flags&amp;FPLUS || flags&amp;FSPACE) ? 1 : 0) - ((flags&amp;FSHARP &amp;&amp; arg !== 0) ? base_prefix.length : 0)) { str = &#39;0&#39; + str; }
                  if (flags&amp;FSHARP &amp;&amp; arg !== 0) { str = base_prefix + str; }
                  if (flags&amp;FPLUS || flags&amp;FSPACE) { str = (flags&amp;FPLUS ? &#39;+&#39; : &#39; &#39;) + str; }
                } else {
                  if (flags&amp;FSHARP &amp;&amp; arg !== 0) { str = base_prefix + str; }
                  if (flags&amp;FPLUS || flags&amp;FSPACE) { str = (flags&amp;FPLUS ? &#39;+&#39; : &#39; &#39;) + str; }
                  while (str.length &lt; width) { str = &#39; &#39; + str; }
                }
              }
            } else {
              if (flags&amp;FPLUS || flags&amp;FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length &lt; precision) { str = &#39;0&#39; + str; }
                if (flags&amp;FMINUS) {
                  if (flags&amp;FSHARP) { str = base_prefix + str; }
                  str = &#39;-&#39; + str;
                  while (str.length &lt; width) { str = str + &#39; &#39;; }
                } else {
                  if (flags&amp;FZERO &amp;&amp; precision === -1) {
                    while (str.length &lt; width - 1 - (flags&amp;FSHARP ? 2 : 0)) { str = &#39;0&#39; + str; }
                    if (flags&amp;FSHARP) { str = base_prefix + str; }
                    str = &#39;-&#39; + str;
                  } else {
                    if (flags&amp;FSHARP) { str = base_prefix + str; }
                    str = &#39;-&#39; + str;
                    while (str.length &lt; width) { str = &#39; &#39; + str; }
                  }
                }
              } else {
                str = (arg &gt;&gt;&gt; 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length &lt; precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&amp;FMINUS) {
                  str = &#39;..&#39; + str;
                  if (flags&amp;FSHARP) { str = base_prefix + str; }
                  while (str.length &lt; width) { str = str + &#39; &#39;; }
                } else {
                  if (flags&amp;FZERO &amp;&amp; precision === -1) {
                    while (str.length &lt; width - 2 - (flags&amp;FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = &#39;..&#39; + str;
                    if (flags&amp;FSHARP) { str = base_prefix + str; }
                  } else {
                    str = &#39;..&#39; + str;
                    if (flags&amp;FSHARP) { str = base_prefix + str; }
                    while (str.length &lt; width) { str = &#39; &#39; + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case &#39;f&#39;:
          case &#39;e&#39;:
          case &#39;E&#39;:
          case &#39;g&#39;:
          case &#39;G&#39;:
            arg = </span><span class='embexpr_beg'>#{</span><span class='const'>Float</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>GET_ARG()</span><span class='tstring_end'>`</span></span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
            if (arg &gt;= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = &#39;Inf&#39;;
              } else {
                switch (format_string.charAt(i)) {
                case &#39;f&#39;:
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case &#39;e&#39;:
                case &#39;E&#39;:
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case &#39;g&#39;:
                case &#39;G&#39;:
                  str = arg.toExponential();
                  exponent = parseInt(str.split(&#39;e&#39;)[1]);
                  if (!(exponent &lt; -4 || exponent &gt;= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&amp;FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&amp;FMINUS) {
                if (flags&amp;FPLUS || flags&amp;FSPACE) { str = (flags&amp;FPLUS ? &#39;+&#39; : &#39; &#39;) + str; }
                while (str.length &lt; width) { str = str + &#39; &#39;; }
              } else {
                if (flags&amp;FZERO &amp;&amp; arg !== Infinity &amp;&amp; !isNaN(arg)) {
                  while (str.length &lt; width - ((flags&amp;FPLUS || flags&amp;FSPACE) ? 1 : 0)) { str = &#39;0&#39; + str; }
                  if (flags&amp;FPLUS || flags&amp;FSPACE) { str = (flags&amp;FPLUS ? &#39;+&#39; : &#39; &#39;) + str; }
                } else {
                  if (flags&amp;FPLUS || flags&amp;FSPACE) { str = (flags&amp;FPLUS ? &#39;+&#39; : &#39; &#39;) + str; }
                  while (str.length &lt; width) { str = &#39; &#39; + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = &#39;Inf&#39;;
              } else {
                switch (format_string.charAt(i)) {
                case &#39;f&#39;:
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case &#39;e&#39;:
                case &#39;E&#39;:
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case &#39;g&#39;:
                case &#39;G&#39;:
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split(&#39;e&#39;)[1]);
                  if (!(exponent &lt; -4 || exponent &gt;= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&amp;FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&amp;FMINUS) {
                str = &#39;-&#39; + str;
                while (str.length &lt; width) { str = str + &#39; &#39;; }
              } else {
                if (flags&amp;FZERO &amp;&amp; arg !== -Infinity) {
                  while (str.length &lt; width - 1) { str = &#39;0&#39; + str; }
                  str = &#39;-&#39; + str;
                } else {
                  str = &#39;-&#39; + str;
                  while (str.length &lt; width) { str = &#39; &#39; + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() &amp;&amp; arg !== Infinity &amp;&amp; arg !== -Infinity &amp;&amp; !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, &#39;$10$2&#39;);
            break format_sequence;

          case &#39;a&#39;:
          case &#39;A&#39;:
            // Not implemented because there are no specs for this field type.
            </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>NotImplementedError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>`A` and `a` format field types are not implemented in Opal yet</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>

          case &#39;c&#39;:
            arg = GET_ARG();
            if (</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>arg</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_respond_to?'>respond_to?</span><span class='lparen'>(</span><span class='symbol'>:to_ary</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>) { arg = </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>arg</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_to_ary'>to_ary</span><span class='embexpr_end'>}</span><span class='tstring_content'>[0]; }
            if (</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>arg</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_respond_to?'>respond_to?</span><span class='lparen'>(</span><span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>) {
              str = </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>arg</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_to_str'>to_str</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
            } else {
              str = String.fromCharCode(</span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>arg</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>);
            }
            if (str.length !== 1) {
              </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>%c requires a character</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
            }
            if (flags&amp;FMINUS) {
              while (str.length &lt; width) { str = str + &#39; &#39;; }
            } else {
              while (str.length &lt; width) { str = &#39; &#39; + str; }
            }
            break format_sequence;

          case &#39;p&#39;:
            str = </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>GET_ARG()</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_inspect'>inspect</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&amp;FMINUS) {
              while (str.length &lt; width) { str = str + &#39; &#39;; }
            } else {
              while (str.length &lt; width) { str = &#39; &#39; + str; }
            }
            break format_sequence;

          case &#39;s&#39;:
            str = </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>GET_ARG()</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&amp;FMINUS) {
              while (str.length &lt; width) { str = str + &#39; &#39;; }
            } else {
              while (str.length &lt; width) { str = &#39; &#39; + str; }
            }
            break format_sequence;

          default:
            </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>malformed format string - %</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>format_string.charAt(i)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
          }
        }

        if (str === undefined) {
          </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>malformed format string - %</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if (</span><span class='embexpr_beg'>#{</span><span class='gvar'>$DEBUG</span><span class='embexpr_end'>}</span><span class='tstring_content'> &amp;&amp; pos_arg_num &gt;= 0 &amp;&amp; seq_arg_num &lt; args.length) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>too many arguments for format string</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      }

      return result + format_string.slice(begin_slice);
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_freeze'>freeze</span>
    <span class='ivar'>@___frozen___</span> <span class='op'>=</span> <span class='kw'>true</span>
    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_frozen?'>frozen?</span>
    <span class='ivar'>@___frozen___</span> <span class='op'>||</span> <span class='kw'>false</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_hash'>hash</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='embexpr_beg'>#{</span><span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='embexpr_end'>}</span><span class='tstring_content'>:</span><span class='embexpr_beg'>#{</span><span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='period'>.</span><span class='id identifier rubyid___id__'>__id__</span><span class='embexpr_end'>}</span><span class='tstring_content'>:</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid___id__'>__id__</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_initialize_copy'>initialize_copy</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_inspect'>inspect</span>
    <span class='id identifier rubyid_to_s'>to_s</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_instance_of?'>instance_of?</span><span class='lparen'>(</span><span class='id identifier rubyid_klass'>klass</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.$$class === klass</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_instance_variable_defined?'>instance_variable_defined?</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>Opal.hasOwnProperty.call(self, name.substr(1))</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_instance_variable_get'>instance_variable_get</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var ivar = self[name.substr(1)];

      return ivar == null ? nil : ivar;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_instance_variable_set'>instance_variable_set</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>self[name.substr(1)] = value</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_instance_variables'>instance_variables</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var result = [];

      for (var name in self) {
        if (name.charAt(0) !== &#39;$&#39;) {
          if (name !== &#39;$$class&#39; &amp;&amp; name !== &#39;$$id&#39;) {
            result.push(&#39;@&#39; + name);
          }
        }
      }

      return result;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='const'>Integer</span><span class='lparen'>(</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='id identifier rubyid_base'>base</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>base specified for non string value</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }
        if (value === nil) {
          </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>TypeError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>can&#39;t convert nil into Integer</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>FloatDomainError</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_content'>
          }
          return Math.floor(value);
        }
        if (</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='period'>.</span><span class='id identifier rubyid_respond_to?'>respond_to?</span><span class='lparen'>(</span><span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>) {
          i = </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='period'>.</span><span class='id identifier rubyid_to_int'>to_int</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
          if (i !== nil) {
            return i;
          }
        }
        return </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to!'>coerce_to!</span><span class='lparen'>(</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_i</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>base</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        if (base === 1 || base &lt; 0 || base &gt; 36) {
          </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid radix </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_base'>base</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, &#39;$1&#39;);

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case &#39;0b&#39;:
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
        case &#39;0&#39;:
        case &#39;0o&#39;:
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
        case &#39;0d&#39;:
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
        case &#39;0x&#39;:
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
        }
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid value for Integer(): \&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot;</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      });

      base = (base === 0 ? 10 : base);

      base_digits = &#39;0-&#39; + (base &lt;= 10 ? base - 1 : &#39;9a-&#39; + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp(&#39;^\\s*[+-]?[&#39; + base_digits + &#39;]+\\s*$&#39;)).test(str)) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid value for Integer(): \&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot;</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid value for Integer(): \&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot;</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      }

      return i;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='const'>Float</span><span class='lparen'>(</span><span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var str;

      if (value === nil) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>TypeError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>can&#39;t convert nil into Float</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, &#39;$1&#39;);

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return </span><span class='embexpr_beg'>#{</span><span class='const'>Integer</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>str</span><span class='tstring_end'>`</span></span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid value for Float(): \&quot;</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_value'>value</span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot;</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }

        return parseFloat(str);
      }

      return </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to!'>coerce_to!</span><span class='lparen'>(</span><span class='id identifier rubyid_value'>value</span><span class='comma'>,</span> <span class='const'>Float</span><span class='comma'>,</span> <span class='symbol'>:to_f</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='const'>Hash</span><span class='lparen'>(</span><span class='id identifier rubyid_arg'>arg</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='lbrace'>{</span><span class='rbrace'>}</span> <span class='kw'>if</span> <span class='id identifier rubyid_arg'>arg</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span> <span class='op'>||</span> <span class='id identifier rubyid_arg'>arg</span> <span class='op'>==</span> <span class='lbracket'>[</span><span class='rbracket'>]</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_arg'>arg</span> <span class='kw'>if</span> <span class='const'>Hash</span> <span class='op'>===</span> <span class='id identifier rubyid_arg'>arg</span>
    <span class='kw'>return</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to!'>coerce_to!</span><span class='lparen'>(</span><span class='id identifier rubyid_arg'>arg</span><span class='comma'>,</span> <span class='const'>Hash</span><span class='comma'>,</span> <span class='symbol'>:to_hash</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_is_a?'>is_a?</span><span class='lparen'>(</span><span class='id identifier rubyid_klass'>klass</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>Opal.is_a(self, klass)</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_kind_of?'>kind_of?</span> <span class='id identifier rubyid_is_a?'>is_a?</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_lambda'>lambda</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>block.$$is_lambda = true</span><span class='tstring_end'>`</span></span>

    <span class='id identifier rubyid_block'>block</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_load'>load</span><span class='lparen'>(</span><span class='id identifier rubyid_file'>file</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_file'>file</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to!'>coerce_to!</span><span class='lparen'>(</span><span class='id identifier rubyid_file'>file</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>Opal.load(Opal.normalize_loadable_path(</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_file'>file</span><span class='embexpr_end'>}</span><span class='tstring_content'>))</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_loop'>loop</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      while (true) {
        if (block() === $breaker) {
          return $breaker.$v;
        }
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_nil?'>nil?</span>
    <span class='kw'>false</span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_object_id'>object_id</span> <span class='id identifier rubyid___id__'>__id__</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_printf'>printf</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_args'>args</span><span class='period'>.</span><span class='id identifier rubyid_length'>length</span> <span class='op'>&gt;</span> <span class='int'>0</span>
      <span class='id identifier rubyid_print'>print</span> <span class='id identifier rubyid_format'>format</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='rparen'>)</span>
    <span class='kw'>end</span>

    <span class='kw'>nil</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_private_methods'>private_methods</span><span class='lparen'>(</span><span class='op'>*</span><span class='rparen'>)</span>
    <span class='lbracket'>[</span><span class='rbracket'>]</span>
  <span class='kw'>end</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_private_instance_methods'>private_instance_methods</span> <span class='id identifier rubyid_private_methods'>private_methods</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_proc'>proc</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='kw'>unless</span> <span class='id identifier rubyid_block'>block</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>tried to create Proc object without a block</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='backtick'>`</span><span class='tstring_content'>block.$$is_lambda = false</span><span class='tstring_end'>`</span></span>
    <span class='id identifier rubyid_block'>block</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_puts'>puts</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_strs'>strs</span><span class='rparen'>)</span>
    <span class='gvar'>$stdout</span><span class='period'>.</span><span class='id identifier rubyid_puts'>puts</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_strs'>strs</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_p'>p</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_args'>args</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_obj'>obj</span><span class='op'>|</span> <span class='gvar'>$stdout</span><span class='period'>.</span><span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_obj'>obj</span><span class='period'>.</span><span class='id identifier rubyid_inspect'>inspect</span> <span class='rbrace'>}</span>

    <span class='id identifier rubyid_args'>args</span><span class='period'>.</span><span class='id identifier rubyid_length'>length</span> <span class='op'>&lt;=</span> <span class='int'>1</span> <span class='op'>?</span> <span class='id identifier rubyid_args'>args</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span> <span class='op'>:</span> <span class='id identifier rubyid_args'>args</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_print'>print</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_strs'>strs</span><span class='rparen'>)</span>
    <span class='gvar'>$stdout</span><span class='period'>.</span><span class='id identifier rubyid_print'>print</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_strs'>strs</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_warn'>warn</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_strs'>strs</span><span class='rparen'>)</span>
    <span class='gvar'>$stderr</span><span class='period'>.</span><span class='id identifier rubyid_puts'>puts</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_strs'>strs</span><span class='rparen'>)</span> <span class='kw'>unless</span> <span class='gvar'>$VERBOSE</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span> <span class='op'>||</span> <span class='id identifier rubyid_strs'>strs</span><span class='period'>.</span><span class='id identifier rubyid_empty?'>empty?</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_raise'>raise</span><span class='lparen'>(</span><span class='id identifier rubyid_exception'>exception</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='comma'>,</span> <span class='id identifier rubyid_string'>string</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (exception == null &amp;&amp; </span><span class='embvar'>#</span><span class='gvar'>$!</span><span class='tstring_content'>) {
        throw </span><span class='embvar'>#</span><span class='gvar'>$!</span><span class='tstring_content'>;
      }

      if (exception == null) {
        exception = </span><span class='embexpr_beg'>#{</span><span class='const'>RuntimeError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }
      else if (exception.$$is_string) {
        exception = </span><span class='embexpr_beg'>#{</span><span class='const'>RuntimeError</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='id identifier rubyid_exception'>exception</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }
      else if (exception.$$is_class) {
        exception = </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_exception'>exception</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='id identifier rubyid_string'>string</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }

      </span><span class='embvar'>#</span><span class='gvar'>$!</span><span class='tstring_content'> = exception;

      throw exception;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_fail'>fail</span> <span class='id identifier rubyid_raise'>raise</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_rand'>rand</span><span class='lparen'>(</span><span class='id identifier rubyid_max'>max</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (max === undefined) {
        return Math.random();
      }
      else if (max.$$is_range) {
        var arr = </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_max'>max</span><span class='period'>.</span><span class='id identifier rubyid_to_a'>to_a</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

        return arr[</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_rand'>rand</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>arr.length</span><span class='tstring_end'>`</span></span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>];
      }
      else {
        return Math.floor(Math.random() *
          Math.abs(</span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span> <span class='id identifier rubyid_max'>max</span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='embexpr_end'>}</span><span class='tstring_content'>));
      }
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_respond_to?'>respond_to?</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_include_all'>include_all</span> <span class='op'>=</span> <span class='kw'>false</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='kw'>true</span> <span class='kw'>if</span> <span class='id identifier rubyid_respond_to_missing?'>respond_to_missing?</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      var body = self[&#39;$&#39; + name];

      if (typeof(body) === &quot;function&quot; &amp;&amp; !body.$$stub) {
        return true;
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>false</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_respond_to_missing?'>respond_to_missing?</span><span class='lparen'>(</span><span class='id identifier rubyid_method_name'>method_name</span><span class='rparen'>)</span>
    <span class='kw'>false</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_require'>require</span><span class='lparen'>(</span><span class='id identifier rubyid_file'>file</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_file'>file</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to!'>coerce_to!</span><span class='lparen'>(</span><span class='id identifier rubyid_file'>file</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>Opal.require(Opal.normalize_loadable_path(</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_file'>file</span><span class='embexpr_end'>}</span><span class='tstring_content'>))</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_require_relative'>require_relative</span><span class='lparen'>(</span><span class='id identifier rubyid_file'>file</span><span class='rparen'>)</span>
    <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_try_convert!'>try_convert!</span><span class='lparen'>(</span><span class='id identifier rubyid_file'>file</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_file'>file</span> <span class='op'>=</span> <span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_expand_path'>expand_path</span> <span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_join'>join</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>Opal.current_file</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>..</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='id identifier rubyid_file'>file</span><span class='rparen'>)</span>

    <span class='backtick'>`</span><span class='tstring_content'>Opal.require(Opal.normalize_loadable_path(</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_file'>file</span><span class='embexpr_end'>}</span><span class='tstring_content'>))</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='comment'># `path` should be the full path to be found in registered modules (`Opal.modules`)
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_require_tree'>require_tree</span><span class='lparen'>(</span><span class='id identifier rubyid_path'>path</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_path'>path</span> <span class='op'>=</span> <span class='const'>File</span><span class='period'>.</span><span class='id identifier rubyid_expand_path'>expand_path</span><span class='lparen'>(</span><span class='id identifier rubyid_path'>path</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_path'>path</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_path'>path</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>.</span><span class='tstring_end'>&#39;</span></span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      for (var name in Opal.modules) {
        if (</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>name</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_start_with?'>start_with?</span><span class='lparen'>(</span><span class='id identifier rubyid_path'>path</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>) {
          Opal.require(name);
        }
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>nil</span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_send'>send</span>        <span class='id identifier rubyid___send__'>__send__</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_public_send'>public_send</span> <span class='id identifier rubyid___send__'>__send__</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_singleton_class'>singleton_class</span>
    <span class='backtick'>`</span><span class='tstring_content'>Opal.get_singleton_class(self)</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_sprintf'>sprintf</span> <span class='id identifier rubyid_format'>format</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_srand'>srand</span> <span class='id identifier rubyid_rand'>rand</span>

  <span class='kw'>def</span> <span class='const'>String</span><span class='lparen'>(</span><span class='id identifier rubyid_str'>str</span><span class='rparen'>)</span>
    <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to?'>coerce_to?</span><span class='lparen'>(</span><span class='id identifier rubyid_str'>str</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span> <span class='op'>||</span>
      <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to!'>coerce_to!</span><span class='lparen'>(</span><span class='id identifier rubyid_str'>str</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_s</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_taint'>taint</span>
    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_tainted?'>tainted?</span>
    <span class='kw'>false</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_tap'>tap</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='kw'>yield</span> <span class='kw'>self</span>
    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_proc'>to_proc</span>
    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_s'>to_s</span>
    <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>#&lt;</span><span class='embexpr_beg'>#{</span><span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='embexpr_end'>}</span><span class='tstring_content'>:0x</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid___id__'>__id__</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span><span class='lparen'>(</span><span class='int'>16</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>&gt;</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_untaint'>untaint</span> <span class='id identifier rubyid_taint'>taint</span>
<span class='kw'>end</span></pre></div></div>

      <div id="footer">
  Generated on Fri Nov 27 11:10:08 2015 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.6 (ruby-2.2.3).
</div>

    </div>
  </body>
</html>