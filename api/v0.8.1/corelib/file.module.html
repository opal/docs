<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: module
  
    &mdash; corelib (Opal v0.8.1)
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "module";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: module</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <iframe id="search_frame" src="file_list.html"></iframe>

      <div id="content"><div id='filecontents'><pre class="code ruby"><span class='kw'>class</span> <span class='const'>Module</span>
  <span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      function AnonModule(){}
      var klass      = Opal.boot(Opal.Module, AnonModule);
      klass.$$name   = nil;
      klass.$$class  = Opal.Module;
      klass.$$dep    = []
      klass.$$is_mod = true;
      klass.$$proto  = {};

      // inherit scope from parent
      Opal.create_scope(Opal.Module.$$scope, klass);

      if (block !== nil) {
        var block_self = block.$$s;
        block.$$s = null;
        block.call(klass);
        block.$$s = block_self;
      }

      return klass;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>===</span><span class='lparen'>(</span><span class='id identifier rubyid_object'>object</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='kw'>false</span> <span class='kw'>if</span> <span class='backtick'>`</span><span class='tstring_content'>object == null</span><span class='tstring_end'>`</span></span>

    <span class='backtick'>`</span><span class='tstring_content'>Opal.is_a(object, self)</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>&lt;</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var working = self;

      while (working) {
        if (working === other) {
          return true;
        }

        working = working.$$parent;
      }

      return false;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_alias_method'>alias_method</span><span class='lparen'>(</span><span class='id identifier rubyid_newname'>newname</span><span class='comma'>,</span> <span class='id identifier rubyid_oldname'>oldname</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var newjsid = &#39;$&#39; + newname,
          body    = self.$$proto[&#39;$&#39; + oldname];

      if (self.$$is_singleton) {
        self.$$proto[newjsid] = body;
      }
      else {
        Opal.defn(self, newjsid, body);
      }

      return self;
    </span><span class='tstring_end'>}</span></span>
    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_alias_native'>alias_native</span><span class='lparen'>(</span><span class='id identifier rubyid_mid'>mid</span><span class='comma'>,</span> <span class='id identifier rubyid_jsid'>jsid</span> <span class='op'>=</span> <span class='id identifier rubyid_mid'>mid</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.$$proto[&#39;$&#39; + mid] = self.$$proto[jsid]</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_ancestors'>ancestors</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var parent = self,
          result = [];

      while (parent) {
        result.push(parent);
        result = result.concat(parent.$$inc);

        parent = parent.$$super;
      }

      return result;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_append_features'>append_features</span><span class='lparen'>(</span><span class='id identifier rubyid_klass'>klass</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>Opal.append_features(self, klass)</span><span class='tstring_end'>`</span></span>
    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_attr_accessor'>attr_accessor</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_names'>names</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_attr_reader'>attr_reader</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_names'>names</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_attr_writer'>attr_writer</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_names'>names</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_attr'>attr</span> <span class='id identifier rubyid_attr_accessor'>attr_accessor</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_attr_reader'>attr_reader</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_names'>names</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var proto = self.$$proto;

      for (var i = names.length - 1; i &gt;= 0; i--) {
        var name = names[i],
            id   = &#39;$&#39; + name;

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(name) {
          return function() {
            return this[name];
          };
        })(name);

        // initialize the instance variable as nil
        proto[name] = nil;

        if (self.$$is_singleton) {
          proto.constructor.prototype[id] = body;
        }
        else {
          Opal.defn(self, id, body);
        }
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>nil</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_attr_writer'>attr_writer</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_names'>names</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var proto = self.$$proto;

      for (var i = names.length - 1; i &gt;= 0; i--) {
        var name = names[i],
            id   = &#39;$&#39; + name + &#39;=&#39;;

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(name){
          return function(value) {
            return this[name] = value;
          }
        })(name);

        // initialize the instance variable as nil
        proto[name] = nil;

        if (self.$$is_singleton) {
          proto.constructor.prototype[id] = body;
        }
        else {
          Opal.defn(self, id, body);
        }
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>nil</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_autoload'>autoload</span><span class='lparen'>(</span><span class='id identifier rubyid_const'>const</span><span class='comma'>,</span> <span class='id identifier rubyid_path'>path</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var autoloaders;

      if (!(autoloaders = self.$$autoload)) {
        autoloaders = self.$$autoload = {};
      }

      autoloaders[</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_const'>const</span><span class='embexpr_end'>}</span><span class='tstring_content'>] = </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_path'>path</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      return nil;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_class_variable_get'>class_variable_get</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to!'>coerce_to!</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>NameError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>class vars should start with @@</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>if</span> <span class='backtick'>`</span><span class='tstring_content'>name.length &lt; 3 || name.slice(0,2) !== &#39;@@&#39;</span><span class='tstring_end'>`</span></span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var value = Opal.cvars[name.slice(2)];
      </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>NameError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>uninitialized class variable @@a in</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>if</span> <span class='backtick'>`</span><span class='tstring_content'>value == null</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      return value;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_class_variable_set'>class_variable_set</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to!'>coerce_to!</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>NameError</span> <span class='kw'>if</span> <span class='backtick'>`</span><span class='tstring_content'>name.length &lt; 3 || name.slice(0,2) !== &#39;@@&#39;</span><span class='tstring_end'>`</span></span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      Opal.cvars[name.slice(2)] = value;
      return value;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_constants'>constants</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.$$scope.constants</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='comment'># check for constant within current scope
</span>  <span class='comment'># if inherit is true or self is Object, will also check ancestors
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_const_defined?'>const_defined?</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_inherit'>inherit</span> <span class='op'>=</span> <span class='kw'>true</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>NameError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>wrong constant name </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_name'>name</span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[A-Z]\w*$</span><span class='regexp_end'>/</span></span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      var scopes = [self.$$scope];

      if (inherit || self === Opal.Object) {
        var parent = self.$$super;

        while (parent !== Opal.BasicObject) {
          scopes.push(parent.$$scope);

          parent = parent.$$super;
        }
      }

      for (var i = 0, length = scopes.length; i &lt; length; i++) {
        if (scopes[i].hasOwnProperty(name)) {
          return true;
        }
      }

      return false;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_const_get'>const_get</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_inherit'>inherit</span> <span class='op'>=</span> <span class='kw'>true</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_name'>name</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>::</span><span class='tstring_end'>&#39;</span></span><span class='rbracket'>]</span> <span class='op'>&amp;&amp;</span> <span class='id identifier rubyid_name'>name</span> <span class='op'>!=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>::</span><span class='tstring_end'>&#39;</span></span>
      <span class='kw'>return</span> <span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_split'>split</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>::</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_inject'>inject</span><span class='lparen'>(</span><span class='kw'>self</span><span class='rparen'>)</span><span class='lbrace'>{</span><span class='op'>|</span><span class='id identifier rubyid_o'>o</span><span class='comma'>,</span> <span class='id identifier rubyid_c'>c</span><span class='op'>|</span> <span class='id identifier rubyid_o'>o</span><span class='period'>.</span><span class='id identifier rubyid_const_get'>const_get</span><span class='lparen'>(</span><span class='id identifier rubyid_c'>c</span><span class='rparen'>)</span><span class='rbrace'>}</span>
    <span class='kw'>end</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>NameError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>wrong constant name </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_name'>name</span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[A-Z]\w*$</span><span class='regexp_end'>/</span></span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var scopes = [self.$$scope];

      if (inherit || self == Opal.Object) {
        var parent = self.$$super;

        while (parent !== Opal.BasicObject) {
          scopes.push(parent.$$scope);

          parent = parent.$$super;
        }
      }

      for (var i = 0, length = scopes.length; i &lt; length; i++) {
        if (scopes[i].hasOwnProperty(name)) {
          return scopes[i][name];
        }
      }

      return </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_const_missing'>const_missing</span> <span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_const_missing'>const_missing</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (self.$$autoload) {
        var file = self.$$autoload[name];

        if (file) {
          self.$require(file);

          return </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_const_get'>const_get</span> <span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        }
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>NameError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>uninitialized constant </span><span class='embexpr_beg'>#{</span><span class='kw'>self</span><span class='embexpr_end'>}</span><span class='tstring_content'>::</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_const_set'>const_set</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_value'>value</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>NameError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>wrong constant name </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_name'>name</span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[A-Z]\w*$</span><span class='regexp_end'>/</span></span>

    <span class='kw'>begin</span>
      <span class='id identifier rubyid_name'>name</span> <span class='op'>=</span> <span class='id identifier rubyid_name'>name</span><span class='period'>.</span><span class='id identifier rubyid_to_str'>to_str</span>
    <span class='kw'>rescue</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>TypeError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>conversion with #to_str failed</span><span class='tstring_end'>&#39;</span></span>
    <span class='kw'>end</span>

    <span class='backtick'>`</span><span class='tstring_content'>Opal.casgn(self, name, value)</span><span class='tstring_end'>`</span></span>

    <span class='id identifier rubyid_value'>value</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_define_method'>define_method</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='comma'>,</span> <span class='id identifier rubyid_method'>method</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='backtick'>`</span><span class='tstring_content'>method === undefined &amp;&amp; !</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_block_given?'>block_given?</span><span class='embexpr_end'>}</span><span class='tstring_end'>`</span></span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>tried to create a Proc object without a block</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_block'>block</span> <span class='op'>||=</span> <span class='kw'>case</span> <span class='id identifier rubyid_method'>method</span>
              <span class='kw'>when</span> <span class='const'>Proc</span>
                <span class='id identifier rubyid_method'>method</span>
              <span class='kw'>when</span> <span class='const'>Method</span>
                <span class='id identifier rubyid_method'>method</span><span class='period'>.</span><span class='id identifier rubyid_to_proc'>to_proc</span>
              <span class='kw'>when</span> <span class='const'>UnboundMethod</span>
                <span class='id identifier rubyid_lambda'>lambda</span> <span class='kw'>do</span> <span class='op'>|</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='op'>|</span>
                  <span class='id identifier rubyid_bound'>bound</span> <span class='op'>=</span> <span class='id identifier rubyid_method'>method</span><span class='period'>.</span><span class='id identifier rubyid_bind'>bind</span><span class='lparen'>(</span><span class='kw'>self</span><span class='rparen'>)</span>
                  <span class='id identifier rubyid_bound'>bound</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span>
                <span class='kw'>end</span>
              <span class='kw'>else</span>
                <span class='id identifier rubyid_raise'>raise</span> <span class='const'>TypeError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>wrong argument type </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_block'>block</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='embexpr_end'>}</span><span class='tstring_content'> (expected Proc/Method)</span><span class='tstring_end'>&quot;</span></span>
              <span class='kw'>end</span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      var id = &#39;$&#39; + name;

      block.$$jsid = name;
      block.$$s    = null;
      block.$$def  = block;

      if (self.$$is_singleton) {
        self.$$proto[id] = block;
      }
      else {
        Opal.defn(self, id, block);
      }

      return name;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_remove_method'>remove_method</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>Opal.undef(self, &#39;$&#39; + name)</span><span class='tstring_end'>`</span></span>

    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_include'>include</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_mods'>mods</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      for (var i = mods.length - 1; i &gt;= 0; i--) {
        var mod = mods[i];

        if (mod === self) {
          continue;
        }

        </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>mod</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_append_features'>append_features</span> <span class='kw'>self</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>mod</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_included'>included</span> <span class='kw'>self</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='id identifier rubyid_mod'>mod</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      for (var cls = self; cls; cls = cls.$$super) {
        for (var i = 0; i != cls.$$inc.length; i++) {
          var mod2 = cls.$$inc[i];
          if (mod === mod2) {
            return true;
          }
        }
      }
      return false;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_instance_method'>instance_method</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var meth = self.$$proto[&#39;$&#39; + name];

      if (!meth || meth.$$stub) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>NameError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>undefined method `</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>&#39; for class `</span><span class='embexpr_beg'>#{</span><span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_name'>name</span><span class='embexpr_end'>}</span><span class='tstring_content'>&#39;</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }

      return </span><span class='embexpr_beg'>#{</span><span class='const'>UnboundMethod</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='kw'>self</span><span class='comma'>,</span> <span class='backtick'>`</span><span class='tstring_content'>meth</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_instance_methods'>instance_methods</span><span class='lparen'>(</span><span class='id identifier rubyid_include_super'>include_super</span> <span class='op'>=</span> <span class='kw'>true</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var methods = [],
          proto   = self.$$proto;

      for (var prop in proto) {
        if (!(prop.charAt(0) === &#39;$&#39;)) {
          continue;
        }

        if (!(typeof(proto[prop]) === &quot;function&quot;)) {
          continue;
        }

        if (proto[prop].$$stub) {
          continue;
        }

        if (!self.$$is_mod) {
          if (self !== Opal.BasicObject &amp;&amp; proto[prop] === Opal.BasicObject.$$proto[prop]) {
            continue;
          }

          if (!include_super &amp;&amp; !proto.hasOwnProperty(prop)) {
            continue;
          }

          if (!include_super &amp;&amp; proto[prop].$$donated) {
            continue;
          }
        }

        methods.push(prop.substr(1));
      }

      return methods;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_included'>included</span><span class='lparen'>(</span><span class='id identifier rubyid_mod'>mod</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_extended'>extended</span><span class='lparen'>(</span><span class='id identifier rubyid_mod'>mod</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_module_eval'>module_eval</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>no block given</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>unless</span> <span class='id identifier rubyid_block'>block</span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.call(self);
      block.$$s = old;

      return result;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_class_eval'>class_eval</span> <span class='id identifier rubyid_module_eval'>module_eval</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_module_exec'>module_exec</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (block === nil) {
        throw new Error(&quot;no block given&quot;);
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, $slice.call(arguments));
      block.$$s = block_self;

      return result;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_class_exec'>class_exec</span> <span class='id identifier rubyid_module_exec'>module_exec</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_method_defined?'>method_defined?</span><span class='lparen'>(</span><span class='id identifier rubyid_method'>method</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var body = self.$$proto[&#39;$&#39; + method];
      return (!!body) &amp;&amp; !body.$$stub;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_module_function'>module_function</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_methods'>methods</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (methods.length === 0) {
        self.$$module_function = true;
      }
      else {
        for (var i = 0, length = methods.length; i &lt; length; i++) {
          var meth = methods[i], func = self.$$proto[&#39;$&#39; + meth];

          self.constructor.prototype[&#39;$&#39; + meth] = func;
        }
      }

      return self;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_name'>name</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        if (base.$$name === nil) {
          return result.length === 0 ? nil : result.join(&#39;::&#39;);
        }

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === Opal.Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join(&#39;::&#39;);
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_public'>public</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_methods'>methods</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (methods.length === 0) {
        self.$$module_function = false;
      }

      return nil;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_private'>private</span> <span class='id identifier rubyid_public'>public</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_protected'>protected</span> <span class='id identifier rubyid_public'>public</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_nesting'>nesting</span> <span class='id identifier rubyid_public'>public</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_private_class_method'>private_class_method</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>self[&#39;$&#39; + name] || nil</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_public_class_method'>public_class_method</span> <span class='id identifier rubyid_private_class_method'>private_class_method</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_private_method_defined?'>private_method_defined?</span><span class='lparen'>(</span><span class='id identifier rubyid_obj'>obj</span><span class='rparen'>)</span>
    <span class='kw'>false</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_private_constant'>private_constant</span><span class='lparen'>(</span><span class='op'>*</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_protected_method_defined?'>protected_method_defined?</span> <span class='id identifier rubyid_private_method_defined?'>private_method_defined?</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_public_instance_methods'>public_instance_methods</span> <span class='id identifier rubyid_instance_methods'>instance_methods</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_public_method_defined?'>public_method_defined?</span> <span class='id identifier rubyid_method_defined?'>method_defined?</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_remove_class_variable'>remove_class_variable</span><span class='lparen'>(</span><span class='op'>*</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_remove_const'>remove_const</span><span class='lparen'>(</span><span class='id identifier rubyid_name'>name</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var old = self.$$scope[name];
      delete self.$$scope[name];
      return old;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_s'>to_s</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.$$name</span><span class='tstring_end'>`</span></span> <span class='op'>||</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>#&lt;</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>self.$$is_mod ? &#39;Module&#39; : &#39;Class&#39;</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>:0x</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid___id__'>__id__</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span><span class='lparen'>(</span><span class='int'>16</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>&gt;</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_undef_method'>undef_method</span><span class='lparen'>(</span><span class='id identifier rubyid_symbol'>symbol</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>Opal.add_stub_for(self.$$proto, &quot;$&quot; + symbol)</span><span class='tstring_end'>`</span></span>

    <span class='kw'>self</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre></div></div>

      <div id="footer">
  Generated on Fri Nov 27 11:10:08 2015 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.6 (ruby-2.2.3).
</div>

    </div>
  </body>
</html>