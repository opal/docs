<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: string
  
    &mdash; corelib (Opal v0.8.1)
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "string";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: string</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <iframe id="search_frame" src="file_list.html"></iframe>

      <div id="content"><div id='filecontents'><pre class="code ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>corelib/comparable</span><span class='tstring_end'>&#39;</span></span>

<span class='kw'>class</span> <span class='const'>String</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'>Comparable</span>

  <span class='backtick'>`</span><span class='tstring_content'>def.$$is_string = true</span><span class='tstring_end'>`</span></span>

  <span class='kw'>def</span> <span class='id identifier rubyid___id__'>__id__</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.toString()</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_object_id'>object_id</span> <span class='id identifier rubyid___id__'>__id__</span>

  <span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_try_convert'>try_convert</span><span class='lparen'>(</span><span class='id identifier rubyid_what'>what</span><span class='rparen'>)</span>
    <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to?'>coerce_to?</span><span class='lparen'>(</span><span class='id identifier rubyid_what'>what</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_str'>str</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span>
    <span class='backtick'>`</span><span class='tstring_content'>new String(str)</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_initialize'>initialize</span><span class='lparen'>(</span><span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (str === undefined) {
        return self;
      }
    </span><span class='tstring_end'>}</span></span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>NotImplementedError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Mutable strings are not supported in Opal.</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>%</span><span class='lparen'>(</span><span class='id identifier rubyid_data'>data</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='const'>Array</span> <span class='op'>===</span> <span class='id identifier rubyid_data'>data</span>
      <span class='id identifier rubyid_format'>format</span><span class='lparen'>(</span><span class='kw'>self</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_data'>data</span><span class='rparen'>)</span>
    <span class='kw'>else</span>
      <span class='id identifier rubyid_format'>format</span><span class='lparen'>(</span><span class='kw'>self</span><span class='comma'>,</span> <span class='id identifier rubyid_data'>data</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>*</span><span class='lparen'>(</span><span class='id identifier rubyid_count'>count</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      count = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>count</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

      if (count &lt; 0) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>negative argument</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      }

      if (count === 0) {
        return &#39;&#39;;
      }

      var result = &#39;&#39;,
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count &gt;= 1 &lt;&lt; 28) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>RangeError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>multiply count must not overflow maximum string size</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      }

      for (;;) {
        if ((count &amp; 1) === 1) {
          result += string;
        }
        count &gt;&gt;&gt;= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return result;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>+</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_other'>other</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span> <span class='id identifier rubyid_other'>other</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span>

    <span class='backtick'>`</span><span class='tstring_content'>self + </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_other'>other</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span><span class='embexpr_end'>}</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>&lt;=&gt;</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='id identifier rubyid_other'>other</span><span class='period'>.</span><span class='id identifier rubyid_respond_to?'>respond_to?</span> <span class='symbol'>:to_str</span>
      <span class='id identifier rubyid_other'>other</span> <span class='op'>=</span> <span class='id identifier rubyid_other'>other</span><span class='period'>.</span><span class='id identifier rubyid_to_str'>to_str</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>

      <span class='backtick'>`</span><span class='tstring_content'>self &gt; other ? 1 : (self &lt; other ? -1 : 0)</span><span class='tstring_end'>`</span></span>
    <span class='kw'>else</span>
      <span class='backtick'>%x{</span><span class='tstring_content'>
        var cmp = </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_other'>other</span> <span class='op'>&lt;=&gt;</span> <span class='kw'>self</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp &gt; 0 ? -1 : (cmp &lt; 0 ? 1 : 0);
        }
      </span><span class='tstring_end'>}</span></span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>&lt;&lt;</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_raise'>raise</span> <span class='const'>NotImplementedError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>#&lt;&lt; not supported. Mutable String methods are not supported in Opal.</span><span class='tstring_end'>&#39;</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>==</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if (</span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_respond_to?'>respond_to?</span> <span class='backtick'>`</span><span class='tstring_content'>other</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='embexpr_end'>}</span><span class='tstring_content'>) {
        return </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_other'>other</span> <span class='op'>==</span> <span class='kw'>self</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }
      return false;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_eql?'>eql?</span> <span class='op'>==</span>
  <span class='kw'>alias</span> <span class='op'>===</span> <span class='op'>==</span>

  <span class='kw'>def</span> <span class='op'>=~</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (other.$$is_string) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>TypeError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>type mismatch: String given</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }

      return </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_other'>other</span> <span class='op'>=~</span> <span class='kw'>self</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='op'>[]</span><span class='lparen'>(</span><span class='id identifier rubyid_index'>index</span><span class='comma'>,</span> <span class='id identifier rubyid_length'>length</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var size = self.length;

      if (index.$$is_range) {
        var exclude = index.exclude,
            length  = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>index.end</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>,
            index   = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>index.begin</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

        if (Math.abs(index) &gt; size) {
          return nil;
        }

        if (index &lt; 0) {
          index += size;
        }

        if (length &lt; 0) {
          length += size;
        }

        if (!exclude) {
          length += 1;
        }

        length = length - index;

        if (length &lt; 0) {
          length = 0;
        }

        return self.substr(index, length);
      }


      if (index.$$is_string) {
        if (length != null) {
          </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>TypeError</span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }
        return self.indexOf(index) !== -1 ? index : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          </span><span class='embexpr_beg'>#{</span><span class='gvar'>$~</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='embexpr_end'>}</span><span class='tstring_content'>
          return nil;
        }

        </span><span class='embexpr_beg'>#{</span><span class='gvar'>$~</span> <span class='op'>=</span> <span class='const'>MatchData</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>index</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='backtick'>`</span><span class='tstring_content'>match</span><span class='tstring_end'>`</span></span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>

        if (length == null) {
          return match[0];
        }

        length = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>length</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

        if (length &lt; 0 &amp;&amp; -length &lt; match.length) {
          return match[length += match.length];
        }

        if (length &gt;= 0 &amp;&amp; length &lt; match.length) {
          return match[length];
        }

        return nil;
      }


      index = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>index</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

      if (index &lt; 0) {
        index += size;
      }

      if (length == null) {
        if (index &gt;= size || index &lt; 0) {
          return nil;
        }
        return self.substr(index, 1);
      }

      length = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>length</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

      if (length &lt; 0) {
        return nil;
      }

      if (index &gt; size || index &lt; 0) {
        return nil;
      }

      return self.substr(index, length);
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_capitalize'>capitalize</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.charAt(0).toUpperCase() + self.substr(1).toLowerCase()</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_capitalize!'>capitalize!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_casecmp'>casecmp</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_other'>other</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) &amp;&amp; ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    </span><span class='tstring_end'>}</span></span>
    <span class='kw'>self</span> <span class='op'>&lt;=&gt;</span> <span class='id identifier rubyid_other'>other</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_center'>center</span><span class='lparen'>(</span><span class='id identifier rubyid_width'>width</span><span class='comma'>,</span> <span class='id identifier rubyid_padstr'>padstr</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'> </span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_width'>width</span>  <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_width'>width</span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_padstr'>padstr</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_padstr'>padstr</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_padstr'>padstr</span><span class='period'>.</span><span class='id identifier rubyid_empty?'>empty?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>zero width padding</span><span class='tstring_end'>&#39;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>return</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='backtick'>`</span><span class='tstring_content'>width &lt;= self.length</span><span class='tstring_end'>`</span></span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      var ljustified = </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_ljust'>ljust</span> <span class='lparen'>(</span><span class='lparen'>(</span><span class='id identifier rubyid_width'>width</span> <span class='op'>+</span> <span class='ivar'>@length</span><span class='rparen'>)</span> <span class='op'>/</span> <span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_ceil'>ceil</span><span class='comma'>,</span> <span class='id identifier rubyid_padstr'>padstr</span><span class='embexpr_end'>}</span><span class='tstring_content'>,
          rjustified = </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_rjust'>rjust</span> <span class='lparen'>(</span><span class='lparen'>(</span><span class='id identifier rubyid_width'>width</span> <span class='op'>+</span> <span class='ivar'>@length</span><span class='rparen'>)</span> <span class='op'>/</span> <span class='int'>2</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_floor'>floor</span><span class='comma'>,</span> <span class='id identifier rubyid_padstr'>padstr</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

      return rjustified + ljustified.slice(self.length);
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_chars'>chars</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_each_char'>each_char</span><span class='period'>.</span><span class='id identifier rubyid_to_a'>to_a</span> <span class='kw'>unless</span> <span class='id identifier rubyid_block'>block</span>

    <span class='id identifier rubyid_each_char'>each_char</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_chomp'>chomp</span><span class='lparen'>(</span><span class='id identifier rubyid_separator'>separator</span> <span class='op'>=</span> <span class='gvar'>$/</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='backtick'>`</span><span class='tstring_content'>separator === nil || self.length === 0</span><span class='tstring_end'>`</span></span>

    <span class='id identifier rubyid_separator'>separator</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to!'>coerce_to!</span><span class='lparen'>(</span><span class='id identifier rubyid_separator'>separator</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (separator === &quot;\n&quot;) {
        return self.replace(/\r?\n?$/, &#39;&#39;);
      }
      else if (separator === &quot;&quot;) {
        return self.replace(/(\r?\n)+$/, &#39;&#39;);
      }
      else if (self.length &gt; separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          return self.substr(0, self.length - separator.length);
        }
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_chomp!'>chomp!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_chop'>chop</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var length = self.length;

      if (length &lt;= 1) {
        return &quot;&quot;;
      }

      if (self.charAt(length - 1) === &quot;\n&quot; &amp;&amp; self.charAt(length - 2) === &quot;\r&quot;) {
        return self.substr(0, length - 2);
      }
      else {
        return self.substr(0, length - 1);
      }
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_chop!'>chop!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_chr'>chr</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.charAt(0)</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_clone'>clone</span>
    <span class='id identifier rubyid_copy'>copy</span> <span class='op'>=</span> <span class='backtick'>`</span><span class='tstring_content'>self.slice()</span><span class='tstring_end'>`</span></span>
    <span class='id identifier rubyid_copy'>copy</span><span class='period'>.</span><span class='id identifier rubyid_initialize_clone'>initialize_clone</span><span class='lparen'>(</span><span class='kw'>self</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_copy'>copy</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_dup'>dup</span>
    <span class='id identifier rubyid_copy'>copy</span> <span class='op'>=</span> <span class='backtick'>`</span><span class='tstring_content'>self.slice()</span><span class='tstring_end'>`</span></span>
    <span class='id identifier rubyid_copy'>copy</span><span class='period'>.</span><span class='id identifier rubyid_initialize_dup'>initialize_dup</span><span class='lparen'>(</span><span class='kw'>self</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_copy'>copy</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_count'>count</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_sets'>sets</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (sets.length === 0) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ArgumentError: wrong number of arguments (0 for 1+)</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, &#39;g&#39;), &#39;&#39;).length;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_delete'>delete</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_sets'>sets</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (sets.length === 0) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ArgumentError: wrong number of arguments (0 for 1+)</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp(char_class, &#39;g&#39;), &#39;&#39;);
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_dup'>dup</span> <span class='id identifier rubyid_clone'>clone</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_downcase'>downcase</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.toLowerCase()</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_downcase!'>downcase!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_each_char'>each_char</span><span class='lparen'>(</span><span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_enum_for'>enum_for</span> <span class='symbol'>:each_char</span> <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      for (var i = 0, length = self.length; i &lt; length; i++) {
        </span><span class='embexpr_beg'>#{</span><span class='kw'>yield</span> <span class='backtick'>`</span><span class='tstring_content'>self.charAt(i)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_each_line'>each_line</span><span class='lparen'>(</span><span class='id identifier rubyid_separator'>separator</span> <span class='op'>=</span> <span class='gvar'>$/</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_enum_for'>enum_for</span> <span class='symbol'>:each_line</span><span class='comma'>,</span> <span class='id identifier rubyid_separator'>separator</span> <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (separator === nil) {
        </span><span class='embexpr_beg'>#{</span><span class='kw'>yield</span> <span class='kw'>self</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        return self;
      }

      separator = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>separator</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>

      if (separator.length === 0) {
        for (var a = self.split(/(\n{2,})/), i = 0, n = a.length; i &lt; n; i += 2) {
          if (a[i] || a[i + 1]) {
            </span><span class='embexpr_beg'>#{</span><span class='kw'>yield</span> <span class='backtick'>`</span><span class='tstring_content'>(a[i] || &quot;&quot;) + (a[i + 1] || &quot;&quot;)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
          }
        }
        return self;
      }

      var chomped  = </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_chomp'>chomp</span><span class='lparen'>(</span><span class='id identifier rubyid_separator'>separator</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>,
          trailing = self.length != chomped.length,
          splitted = chomped.split(separator);

      for (var i = 0, length = splitted.length; i &lt; length; i++) {
        if (i &lt; length - 1 || trailing) {
          </span><span class='embexpr_beg'>#{</span><span class='kw'>yield</span> <span class='backtick'>`</span><span class='tstring_content'>splitted[i] + separator</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        }
        else {
          </span><span class='embexpr_beg'>#{</span><span class='kw'>yield</span> <span class='backtick'>`</span><span class='tstring_content'>splitted[i]</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        }
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_empty?'>empty?</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.length === 0</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_end_with?'>end_with?</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_suffixes'>suffixes</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      for (var i = 0, length = suffixes.length; i &lt; length; i++) {
        var suffix = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>suffixes[i]</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

        if (self.length &gt;= suffix.length &amp;&amp;
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>false</span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_eql?'>eql?</span> <span class='op'>==</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_equal?'>equal?</span> <span class='op'>===</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_gsub'>gsub</span><span class='lparen'>(</span><span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='id identifier rubyid_replacement'>replacement</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var result = &#39;&#39;, match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = new RegExp(pattern.source, &#39;gm&#39; + (pattern.ignoreCase ? &#39;i&#39; : &#39;&#39;));
      } else {
        pattern = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>pattern</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, &#39;\\$&amp;&#39;), &#39;gm&#39;);
      }

      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          </span><span class='embexpr_beg'>#{</span><span class='gvar'>$~</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='embexpr_end'>}</span><span class='tstring_content'>
          result += self.slice(index);
          break;
        }

        match_data = </span><span class='embexpr_beg'>#{</span><span class='const'>MatchData</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='backtick'>`</span><span class='tstring_content'>pattern</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='backtick'>`</span><span class='tstring_content'>match</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;

        if (replacement === undefined) {
          if (block === nil) {
            </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>wrong number of arguments (1 for 2)</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
          }
          _replacement = block(match[0]);
        }
        else if (replacement.$$is_hash) {
          _replacement = </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>replacement</span><span class='tstring_end'>`</span></span><span class='lbracket'>[</span><span class='backtick'>`</span><span class='tstring_content'>match[0]</span><span class='tstring_end'>`</span></span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        }
        else {
          if (!replacement.$$is_string) {
            replacement = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>replacement</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&amp;`&#39;])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case &quot;+&quot;:
              for (var i = match.length - 1; i &gt; 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return &#39;&#39;;
            case &quot;&amp;&quot;: return slashes.slice(1) + match[0];
            case &quot;`&quot;: return slashes.slice(1) + self.slice(0, match.index);
            case &quot;&#39;&quot;: return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || &#39;&#39;);
            }
          }).replace(/\\\\/g, &#39;\\&#39;);
        }

        if (pattern.lastIndex === match.index) {
          result += (_replacement + self.slice(index, match.index + 1))
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      </span><span class='embexpr_beg'>#{</span><span class='gvar'>$~</span> <span class='op'>=</span> <span class='backtick'>`</span><span class='tstring_content'>match_data</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      return result;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_gsub!'>gsub!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_hash'>hash</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.toString()</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_hex'>hex</span>
    <span class='id identifier rubyid_to_i'>to_i</span> <span class='int'>16</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (other.$$is_string) {
        return self.indexOf(other) !== -1;
      }
    </span><span class='tstring_end'>}</span></span>

    <span class='kw'>unless</span> <span class='id identifier rubyid_other'>other</span><span class='period'>.</span><span class='id identifier rubyid_respond_to?'>respond_to?</span> <span class='symbol'>:to_str</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>TypeError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>no implicit conversion of </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_other'>other</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='embexpr_end'>}</span><span class='tstring_content'> into String</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='backtick'>`</span><span class='tstring_content'>self.indexOf(</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_other'>other</span><span class='period'>.</span><span class='id identifier rubyid_to_str'>to_str</span><span class='embexpr_end'>}</span><span class='tstring_content'>) !== -1</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_index'>index</span><span class='lparen'>(</span><span class='id identifier rubyid_search'>search</span><span class='comma'>,</span> <span class='id identifier rubyid_offset'>offset</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>offset</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        if (offset &lt; 0) {
          offset += self.length;
          if (offset &lt; 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = new RegExp(search.source, &#39;gm&#39; + (search.ignoreCase ? &#39;i&#39; : &#39;&#39;));
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            </span><span class='embexpr_beg'>#{</span><span class='gvar'>$~</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
            index = -1;
            break;
          }
          if (match.index &gt;= offset) {
            </span><span class='embexpr_beg'>#{</span><span class='gvar'>$~</span> <span class='op'>=</span> <span class='const'>MatchData</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>regex</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='backtick'>`</span><span class='tstring_content'>match</span><span class='tstring_end'>`</span></span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>search</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        if (search.length === 0 &amp;&amp; offset &gt; self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_inspect'>inspect</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var escapable = /[\\\&quot;\x00-\x1f\x7f-\x9f\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            &#39;\u0007&#39;: &#39;\\a&#39;,
            &#39;\u001b&#39;: &#39;\\e&#39;,
            &#39;\b&#39;: &#39;\\b&#39;,
            &#39;\t&#39;: &#39;\\t&#39;,
            &#39;\n&#39;: &#39;\\n&#39;,
            &#39;\f&#39;: &#39;\\f&#39;,
            &#39;\r&#39;: &#39;\\r&#39;,
            &#39;\v&#39;: &#39;\\v&#39;,
            &#39;&quot;&#39; : &#39;\\&quot;&#39;,
            &#39;\\&#39;: &#39;\\\\&#39;
          },
          escaped = self.replace(escapable, function (chr) {
            return meta[chr] || &#39;\\u&#39; + (&#39;0000&#39; + chr.charCodeAt(0).toString(16).toUpperCase()).slice(-4);
          });
      return &#39;&quot;&#39; + escaped.replace(/\#[\$\@\{]/g, &#39;\\$&amp;&#39;) + &#39;&quot;&#39;;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_intern'>intern</span>
    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_lines'>lines</span><span class='lparen'>(</span><span class='id identifier rubyid_separator'>separator</span> <span class='op'>=</span> <span class='gvar'>$/</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_e'>e</span> <span class='op'>=</span> <span class='id identifier rubyid_each_line'>each_line</span><span class='lparen'>(</span><span class='id identifier rubyid_separator'>separator</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_block'>block</span> <span class='op'>?</span> <span class='kw'>self</span> <span class='op'>:</span> <span class='id identifier rubyid_e'>e</span><span class='period'>.</span><span class='id identifier rubyid_to_a'>to_a</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_length'>length</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.length</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_ljust'>ljust</span><span class='lparen'>(</span><span class='id identifier rubyid_width'>width</span><span class='comma'>,</span> <span class='id identifier rubyid_padstr'>padstr</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'> </span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_width'>width</span>  <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_width'>width</span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_padstr'>padstr</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_padstr'>padstr</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_padstr'>padstr</span><span class='period'>.</span><span class='id identifier rubyid_empty?'>empty?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>zero width padding</span><span class='tstring_end'>&#39;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>return</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='backtick'>`</span><span class='tstring_content'>width &lt;= self.length</span><span class='tstring_end'>`</span></span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      var index  = -1,
          result = &quot;&quot;;

      width -= self.length;

      while (++index &lt; width) {
        result += padstr;
      }

      return self + result.slice(0, width);
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_lstrip'>lstrip</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.replace(/^\s*/, &#39;&#39;)</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_lstrip!'>lstrip!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='id identifier rubyid_pos'>pos</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='kw'>if</span> <span class='const'>String</span> <span class='op'>===</span> <span class='id identifier rubyid_pattern'>pattern</span> <span class='op'>||</span> <span class='id identifier rubyid_pattern'>pattern</span><span class='period'>.</span><span class='id identifier rubyid_respond_to?'>respond_to?</span><span class='lparen'>(</span><span class='symbol'>:to_str</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_pattern'>pattern</span> <span class='op'>=</span> <span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_pattern'>pattern</span><span class='period'>.</span><span class='id identifier rubyid_to_str'>to_str</span><span class='rparen'>)</span>
    <span class='kw'>end</span>

    <span class='kw'>unless</span> <span class='const'>Regexp</span> <span class='op'>===</span> <span class='id identifier rubyid_pattern'>pattern</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>TypeError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>wrong argument type </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_pattern'>pattern</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='embexpr_end'>}</span><span class='tstring_content'> (expected Regexp)</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_pattern'>pattern</span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='kw'>self</span><span class='comma'>,</span> <span class='id identifier rubyid_pos'>pos</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='kw'>next</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var i = self.length;
      if (i === 0) {
        return &#39;&#39;;
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code &gt;= 48 &amp;&amp; code &lt;= 57) ||
          (code &gt;= 65 &amp;&amp; code &lt;= 90) ||
          (code &gt;= 97 &amp;&amp; code &lt;= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry &amp;&amp; (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return result;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_next!'>next!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_oct'>oct</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case &#39;+&#39;:
        case &#39;-&#39;:
          return original;
        case &#39;0&#39;:
          if (tail.charAt(1) === &#39;x&#39; &amp;&amp; flag === &#39;0x&#39;) {
            return original;
          }
        }
        switch (flag) {
        case &#39;0b&#39;:
          radix = 2;
          break;
        case &#39;0&#39;:
        case &#39;0o&#39;:
          radix = 8;
          break;
        case &#39;0d&#39;:
          radix = 10;
          break;
        case &#39;0x&#39;:
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, &#39;&#39;), radix);
      return isNaN(result) ? 0 : result;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_ord'>ord</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.charCodeAt(0)</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_partition'>partition</span><span class='lparen'>(</span><span class='id identifier rubyid_sep'>sep</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          </span><span class='embexpr_beg'>#{</span><span class='const'>MatchData</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='backtick'>`</span><span class='tstring_content'>sep</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='backtick'>`</span><span class='tstring_content'>m</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>sep</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, &#39;&#39;, &#39;&#39;];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_reverse'>reverse</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_reverse!'>reverse!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_rindex'>rindex</span><span class='lparen'>(</span><span class='id identifier rubyid_search'>search</span><span class='comma'>,</span> <span class='id identifier rubyid_offset'>offset</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>offset</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        if (offset &lt; 0) {
          offset += self.length;
          if (offset &lt; 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = new RegExp(search.source, &#39;gm&#39; + (search.ignoreCase ? &#39;i&#39; : &#39;&#39;));
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index &gt; offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          </span><span class='embexpr_beg'>#{</span><span class='gvar'>$~</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='embexpr_end'>}</span><span class='tstring_content'>
          i = -1;
        } else {
          </span><span class='embexpr_beg'>#{</span><span class='const'>MatchData</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='backtick'>`</span><span class='tstring_content'>r</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='backtick'>`</span><span class='tstring_content'>m</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
          i = m.index;
        }
      } else {
        search = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>search</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_rjust'>rjust</span><span class='lparen'>(</span><span class='id identifier rubyid_width'>width</span><span class='comma'>,</span> <span class='id identifier rubyid_padstr'>padstr</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'> </span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
    <span class='id identifier rubyid_width'>width</span>  <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_width'>width</span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_padstr'>padstr</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_padstr'>padstr</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_padstr'>padstr</span><span class='period'>.</span><span class='id identifier rubyid_empty?'>empty?</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>zero width padding</span><span class='tstring_end'>&#39;</span></span>
    <span class='kw'>end</span>

    <span class='kw'>return</span> <span class='kw'>self</span> <span class='kw'>if</span> <span class='backtick'>`</span><span class='tstring_content'>width &lt;= self.length</span><span class='tstring_end'>`</span></span>

    <span class='backtick'>%x{</span><span class='tstring_content'>
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return result + padstr.slice(0, remaining) + self;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_rpartition'>rpartition</span><span class='lparen'>(</span><span class='id identifier rubyid_sep'>sep</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = new RegExp(sep.source, &#39;gm&#39; + (sep.ignoreCase ? &#39;i&#39; : &#39;&#39;));

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          </span><span class='embexpr_beg'>#{</span><span class='const'>MatchData</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='backtick'>`</span><span class='tstring_content'>r</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='backtick'>`</span><span class='tstring_content'>m</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>sep</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return [&#39;&#39;, &#39;&#39;, self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_rstrip'>rstrip</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.replace(/[\s\u0000]*$/, &#39;&#39;)</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_scan'>scan</span><span class='lparen'>(</span><span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = new RegExp(pattern.source, &#39;gm&#39; + (pattern.ignoreCase ? &#39;i&#39; : &#39;&#39;));
      } else {
        pattern = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>pattern</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, &#39;\\$&amp;&#39;), &#39;gm&#39;);
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = </span><span class='embexpr_beg'>#{</span><span class='const'>MatchData</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='backtick'>`</span><span class='tstring_content'>pattern</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='backtick'>`</span><span class='tstring_content'>match</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push(</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>match_data</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_captures'>captures</span><span class='embexpr_end'>}</span><span class='tstring_content'>);
        } else {
          match.length == 1 ? block(match[0]) : block.call(self, </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>match_data</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_captures'>captures</span><span class='embexpr_end'>}</span><span class='tstring_content'>);
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      </span><span class='embexpr_beg'>#{</span><span class='gvar'>$~</span> <span class='op'>=</span> <span class='backtick'>`</span><span class='tstring_content'>match_data</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>

      return (block !== nil ? self : result);
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_size'>size</span> <span class='id identifier rubyid_length'>length</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_slice'>slice</span> <span class='op'>[]</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_slice!'>slice!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_split'>split</span><span class='lparen'>(</span><span class='id identifier rubyid_pattern'>pattern</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='comma'>,</span> <span class='id identifier rubyid_limit'>limit</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to!'>coerce_to!</span><span class='lparen'>(</span><span class='id identifier rubyid_limit'>limit</span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = </span><span class='embexpr_beg'>#{</span><span class='gvar'>$;</span> <span class='op'>||</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'> </span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i;

      if (pattern.$$is_regexp) {
        pattern = new RegExp(pattern.source, &#39;gm&#39; + (pattern.ignoreCase ? &#39;i&#39; : &#39;&#39;));
      } else {
        pattern = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        if (pattern === &#39; &#39;) {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, &#39;&#39;);
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, &#39;\\$&amp;&#39;), &#39;gm&#39;);
        }
      }

      result = string.split(pattern);

      if (result.length === 1 &amp;&amp; result[0] === string) {
        return result;
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      if (limit === 0) {
        while (result[result.length - 1] === &#39;&#39;) {
          result.length -= 1;
        }
        return result;
      }

      match = pattern.exec(string);

      if (limit &lt; 0) {
        if (match !== null &amp;&amp; match[0] === &#39;&#39; &amp;&amp; pattern.source.indexOf(&#39;(?=&#39;) === -1) {
          for (i = 0; i &lt; match.length; i++) {
            result.push(&#39;&#39;);
          }
        }
        return result;
      }

      if (match !== null &amp;&amp; match[0] === &#39;&#39;) {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(&#39;&#39;));
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }

      result.splice(limit - 1, result.length - 1, string.slice(index));
      return result;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_squeeze'>squeeze</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_sets'>sets</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (sets.length === 0) {
        return self.replace(/(.)\1+/g, &#39;$1&#39;);
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp(&#39;(&#39; + char_class + &#39;)\\1+&#39;, &#39;g&#39;), &#39;$1&#39;);
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_squeeze!'>squeeze!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_start_with?'>start_with?</span><span class='lparen'>(</span><span class='op'>*</span><span class='id identifier rubyid_prefixes'>prefixes</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      for (var i = 0, length = prefixes.length; i &lt; length; i++) {
        var prefix = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>prefixes[i]</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

        if (self.indexOf(prefix) === 0) {
          return true;
        }
      }

      return false;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_strip'>strip</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.replace(/^\s*/, &#39;&#39;).replace(/[\s\u0000]*$/, &#39;&#39;)</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_strip!'>strip!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_sub'>sub</span><span class='lparen'>(</span><span class='id identifier rubyid_pattern'>pattern</span><span class='comma'>,</span> <span class='id identifier rubyid_replacement'>replacement</span> <span class='op'>=</span> <span class='id identifier rubyid_undefined'>undefined</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (!pattern.$$is_regexp) {
        pattern = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>pattern</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, &#39;\\$&amp;&#39;));
      }

      var result = pattern.exec(self);

      if (result === null) {
        </span><span class='embexpr_beg'>#{</span><span class='gvar'>$~</span> <span class='op'>=</span> <span class='kw'>nil</span><span class='embexpr_end'>}</span><span class='tstring_content'>
        return self.toString();
      }

      </span><span class='embexpr_beg'>#{</span><span class='const'>MatchData</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='backtick'>`</span><span class='tstring_content'>pattern</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='backtick'>`</span><span class='tstring_content'>result</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>

      if (replacement === undefined) {
        if (block === nil) {
          </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>wrong number of arguments (1 for 2)</span><span class='tstring_end'>&#39;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
        }
        return self.slice(0, result.index) + block(result[0]) + self.slice(result.index + result[0].length);
      }

      if (replacement.$$is_hash) {
        return self.slice(0, result.index) + </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>replacement</span><span class='tstring_end'>`</span></span><span class='lbracket'>[</span><span class='backtick'>`</span><span class='tstring_content'>result[0]</span><span class='tstring_end'>`</span></span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span><span class='embexpr_end'>}</span><span class='tstring_content'> + self.slice(result.index + result[0].length);
      }

      replacement = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>replacement</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

      replacement = replacement.replace(/([\\]+)([0-9+&amp;`&#39;])/g, function (original, slashes, command) {
        if (slashes.length % 2 === 0) {
          return original;
        }
        switch (command) {
        case &quot;+&quot;:
          for (var i = result.length - 1; i &gt; 0; i--) {
            if (result[i] !== undefined) {
              return slashes.slice(1) + result[i];
            }
          }
          return &#39;&#39;;
        case &quot;&amp;&quot;: return slashes.slice(1) + result[0];
        case &quot;`&quot;: return slashes.slice(1) + self.slice(0, result.index);
        case &quot;&#39;&quot;: return slashes.slice(1) + self.slice(result.index + result[0].length);
        default:  return slashes.slice(1) + (result[command] || &#39;&#39;);
        }
      }).replace(/\\\\/g, &#39;\\&#39;);

      return self.slice(0, result.index) + replacement + self.slice(result.index + result[0].length);
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_sub!'>sub!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_succ'>succ</span> <span class='kw'>next</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_succ!'>succ!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_sum'>sum</span><span class='lparen'>(</span><span class='id identifier rubyid_n'>n</span> <span class='op'>=</span> <span class='int'>16</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      n = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>n</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

      var result = 0,
          length = self.length,
          i = 0;

      for (; i &lt; length; i++) {
        result += self.charCodeAt(i);
      }

      if (n &lt;= 0) {
        return result;
      }

      return result &amp; (Math.pow(2, n) - 1);
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_swapcase'>swapcase</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      if (self.constructor === String) {
        return str;
      }

      return </span><span class='embexpr_beg'>#{</span><span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='backtick'>`</span><span class='tstring_content'>str</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_swapcase!'>swapcase!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_f'>to_f</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (self.charAt(0) === &#39;_&#39;) {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, &#39;&#39;));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_i'>to_i</span><span class='lparen'>(</span><span class='id identifier rubyid_base'>base</span> <span class='op'>=</span> <span class='int'>10</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var result,
          string = self.toLowerCase(),
          radix = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>base</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>Integer</span><span class='comma'>,</span> <span class='symbol'>:to_int</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;

      if (radix === 1 || radix &lt; 0 || radix &gt; 36) {
        </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid radix </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>radix</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case &#39;+&#39;:
        case &#39;-&#39;:
          return original;
        case &#39;0&#39;:
          if (tail.charAt(1) === &#39;x&#39; &amp;&amp; flag === &#39;0x&#39; &amp;&amp; (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case &#39;0b&#39;:
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case &#39;0&#39;:
        case &#39;0o&#39;:
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case &#39;0d&#39;:
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case &#39;0x&#39;:
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, &#39;&#39;), radix);
      return isNaN(result) ? 0 : result;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_proc'>to_proc</span>
    <span class='comment'># Give name to self in case this proc is passed to instance_eval
</span>    <span class='id identifier rubyid_sym'>sym</span> <span class='op'>=</span> <span class='kw'>self</span>

    <span class='id identifier rubyid_proc'>proc</span> <span class='kw'>do</span> <span class='op'>|</span><span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='op'>|</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>no receiver given</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_args'>args</span><span class='period'>.</span><span class='id identifier rubyid_empty?'>empty?</span>
      <span class='id identifier rubyid_obj'>obj</span> <span class='op'>=</span> <span class='id identifier rubyid_args'>args</span><span class='period'>.</span><span class='id identifier rubyid_shift'>shift</span>
      <span class='id identifier rubyid_obj'>obj</span><span class='period'>.</span><span class='id identifier rubyid___send__'>__send__</span><span class='lparen'>(</span><span class='id identifier rubyid_sym'>sym</span><span class='comma'>,</span> <span class='op'>*</span><span class='id identifier rubyid_args'>args</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_to_s'>to_s</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.toString()</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_to_str'>to_str</span> <span class='id identifier rubyid_to_s'>to_s</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_to_sym'>to_sym</span> <span class='id identifier rubyid_intern'>intern</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_tr'>tr</span><span class='lparen'>(</span><span class='id identifier rubyid_from'>from</span><span class='comma'>,</span> <span class='id identifier rubyid_to'>to</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_from'>from</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_from'>from</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>
    <span class='id identifier rubyid_to'>to</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_to'>to</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (from.length == 0 || from === to) {
        return self;
      }

      var subs = {};
      var from_chars = from.split(&#39;&#39;);
      var from_length = from_chars.length;
      var to_chars = to.split(&#39;&#39;);
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === &#39;^&#39; &amp;&amp; from_chars.length &gt; 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      var in_range = false;
      for (var i = 0; i &lt; from_length; i++) {
        var ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === &#39;-&#39;) {
          if (last_from === &#39;-&#39;) {
            from_chars_expanded.push(&#39;-&#39;);
            from_chars_expanded.push(&#39;-&#39;);
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push(&#39;-&#39;);
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          var start = last_from.charCodeAt(0);
          var end = ch.charCodeAt(0);
          if (start &gt; end) {
            </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid range \&quot;</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>String.fromCharCode(start)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>String.fromCharCode(end)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot; in string transliteration</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
          }
          for (var c = start + 1; c &lt; end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (var i = 0; i &lt; from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length &gt; 0) {
          var to_chars_expanded = [];
          var last_to = null;
          var in_range = false;
          for (var i = 0; i &lt; to_length; i++) {
            var ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === &#39;-&#39;) {
              if (last_to === &#39;-&#39;) {
                to_chars_expanded.push(&#39;-&#39;);
                to_chars_expanded.push(&#39;-&#39;);
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push(&#39;-&#39;);
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              var start = last_from.charCodeAt(0);
              var end = ch.charCodeAt(0);
              if (start &gt; end) {
                </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid range \&quot;</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>String.fromCharCode(start)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>String.fromCharCode(end)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot; in string transliteration</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
              }
              for (var c = start + 1; c &lt; end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff &gt; 0) {
          var pad_char = (to_length &gt; 0 ? to_chars[to_length - 1] : &#39;&#39;);
          for (var i = 0; i &lt; length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (var i = 0; i &lt; from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = &#39;&#39;
      for (var i = 0, length = self.length; i &lt; length; i++) {
        var ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return new_str;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_tr!'>tr!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_tr_s'>tr_s</span><span class='lparen'>(</span><span class='id identifier rubyid_from'>from</span><span class='comma'>,</span> <span class='id identifier rubyid_to'>to</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_from'>from</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_from'>from</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>
    <span class='id identifier rubyid_to'>to</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_to'>to</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      if (from.length == 0) {
        return self;
      }

      var subs = {};
      var from_chars = from.split(&#39;&#39;);
      var from_length = from_chars.length;
      var to_chars = to.split(&#39;&#39;);
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === &#39;^&#39; &amp;&amp; from_chars.length &gt; 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      var in_range = false;
      for (var i = 0; i &lt; from_length; i++) {
        var ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === &#39;-&#39;) {
          if (last_from === &#39;-&#39;) {
            from_chars_expanded.push(&#39;-&#39;);
            from_chars_expanded.push(&#39;-&#39;);
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push(&#39;-&#39;);
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          var start = last_from.charCodeAt(0);
          var end = ch.charCodeAt(0);
          if (start &gt; end) {
            </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid range \&quot;</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>String.fromCharCode(start)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>String.fromCharCode(end)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot; in string transliteration</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
          }
          for (var c = start + 1; c &lt; end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (var i = 0; i &lt; from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length &gt; 0) {
          var to_chars_expanded = [];
          var last_to = null;
          var in_range = false;
          for (var i = 0; i &lt; to_length; i++) {
            var ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === &#39;-&#39;) {
              if (last_to === &#39;-&#39;) {
                to_chars_expanded.push(&#39;-&#39;);
                to_chars_expanded.push(&#39;-&#39;);
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push(&#39;-&#39;);
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              var start = last_from.charCodeAt(0);
              var end = ch.charCodeAt(0);
              if (start &gt; end) {
                </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid range \&quot;</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>String.fromCharCode(start)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>String.fromCharCode(end)</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot; in string transliteration</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
              }
              for (var c = start + 1; c &lt; end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff &gt; 0) {
          var pad_char = (to_length &gt; 0 ? to_chars[to_length - 1] : &#39;&#39;);
          for (var i = 0; i &lt; length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (var i = 0; i &lt; from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = &#39;&#39;
      var last_substitute = null
      for (var i = 0, length = self.length; i &lt; length; i++) {
        var ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return new_str;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_tr_s!'>tr_s!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_upcase'>upcase</span>
    <span class='backtick'>`</span><span class='tstring_content'>self.toUpperCase()</span><span class='tstring_end'>`</span></span>
  <span class='kw'>end</span>

  <span class='kw'>alias</span> <span class='id identifier rubyid_upcase!'>upcase!</span> <span class='op'>&lt;&lt;</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_freeze'>freeze</span>
    <span class='kw'>self</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_frozen?'>frozen?</span>
    <span class='kw'>true</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_upto'>upto</span><span class='lparen'>(</span><span class='id identifier rubyid_stop'>stop</span><span class='comma'>,</span> <span class='id identifier rubyid_excl'>excl</span> <span class='op'>=</span> <span class='kw'>false</span><span class='comma'>,</span> <span class='op'>&amp;</span><span class='id identifier rubyid_block'>block</span><span class='rparen'>)</span>
    <span class='kw'>return</span> <span class='id identifier rubyid_enum_for'>enum_for</span> <span class='symbol'>:upto</span><span class='comma'>,</span> <span class='id identifier rubyid_stop'>stop</span><span class='comma'>,</span> <span class='id identifier rubyid_excl'>excl</span> <span class='kw'>unless</span> <span class='id identifier rubyid_block_given?'>block_given?</span>
    <span class='id identifier rubyid_stop'>stop</span> <span class='op'>=</span> <span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='id identifier rubyid_stop'>stop</span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span>
    <span class='backtick'>%x{</span><span class='tstring_content'>
      var a, b, s = self.toString();

      if (s.length === 1 &amp;&amp; stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a &lt;= b) {
          if (excl &amp;&amp; a === b) {
            break;
          }
          block(String.fromCharCode(a));
          a += 1;
        }

      } else if (parseInt(s).toString() === s &amp;&amp; parseInt(stop).toString() === stop) {

        a = parseInt(s);
        b = parseInt(stop);

        while (a &lt;= b) {
          if (excl &amp;&amp; a === b) {
            break;
          }
          block(a.toString());
          a += 1;
        }

      } else {

        while (s.length &lt;= stop.length &amp;&amp; s &lt;= stop) {
          if (excl &amp;&amp; s === stop) {
            break;
          }
          block(s);
          s = </span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>s</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_succ'>succ</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        }

      }
      return self;
    </span><span class='tstring_end'>}</span></span>
  <span class='kw'>end</span>

  <span class='backtick'>%x{</span><span class='tstring_content'>
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = &#39;&#39;,
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i &lt; len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === &#39;-&#39; &amp;&amp; i &gt; 0 &amp;&amp; i &lt; (len - 1) &amp;&amp; !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from &gt; char_code_upto) {
              </span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_raise'>raise</span> <span class='const'>ArgumentError</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>invalid range \&quot;</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>char_code_from</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>-</span><span class='embexpr_beg'>#{</span><span class='backtick'>`</span><span class='tstring_content'>char_code_upto</span><span class='tstring_end'>`</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>\&quot; in string transliteration</span><span class='tstring_end'>&quot;</span></span><span class='embexpr_end'>}</span><span class='tstring_content'>
            }
            for (char_code = char_code_from + 1; char_code &lt; char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === &#39;\\&#39;);
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = &#39;&#39;,
            i, len = setA.length,
            chr;
        for (i = 0; i &lt; len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = &#39;&#39;,
          neg_intersection = &#39;&#39;;

      for (i = 0, len = sets.length; i &lt; len; i++) {
        set = </span><span class='embexpr_beg'>#{</span><span class='const'>Opal</span><span class='period'>.</span><span class='id identifier rubyid_coerce_to'>coerce_to</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>sets[i]</span><span class='tstring_end'>`</span></span><span class='comma'>,</span> <span class='const'>String</span><span class='comma'>,</span> <span class='symbol'>:to_str</span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'>;
        neg = (set.charAt(0) === &#39;^&#39; &amp;&amp; set.length &gt; 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length &gt; 0 &amp;&amp; neg_intersection.length &gt; 0) {
        tmp = &#39;&#39;;
        for (i = 0, len = pos_intersection.length; i &lt; len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = &#39;&#39;;
      }

      if (pos_intersection.length &gt; 0) {
        return &#39;[&#39; + </span><span class='embexpr_beg'>#{</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_escape'>escape</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>pos_intersection</span><span class='tstring_end'>`</span></span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'> + &#39;]&#39;;
      }

      if (neg_intersection.length &gt; 0) {
        return &#39;[^&#39; + </span><span class='embexpr_beg'>#{</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_escape'>escape</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>neg_intersection</span><span class='tstring_end'>`</span></span><span class='rparen'>)</span><span class='embexpr_end'>}</span><span class='tstring_content'> + &#39;]&#39;;
      }

      return null;
    }
  </span><span class='tstring_end'>}</span></span>
<span class='kw'>end</span>

<span class='const'>Symbol</span> <span class='op'>=</span> <span class='const'>String</span></pre></div></div>

      <div id="footer">
  Generated on Fri Nov 27 11:10:08 2015 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.6 (ruby-2.2.3).
</div>

    </div>
  </body>
</html>