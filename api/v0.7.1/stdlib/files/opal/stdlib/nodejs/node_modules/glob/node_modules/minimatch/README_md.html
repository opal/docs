<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            README.md
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/glob/node_modules/minimatch/README.md</li>
            <li>Last modified: 2015-08-19 03:18:33 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-minimatch">minimatch</h1>

<p>A minimal matching utility.</p>

<p><a href="http://travis-ci.org/isaacs/minimatch"><img
src="https://secure.travis-ci.org/isaacs/minimatch.png"></a></p>

<p>This is the matching library used internally by npm.</p>

<p>It works by converting glob expressions into JavaScript <code>RegExp</code>
objects.</p>

<h2 id="label-Usage">Usage</h2>

<pre><code>var minimatch = require(&quot;minimatch&quot;)

minimatch(&quot;bar.foo&quot;, &quot;*.foo&quot;) // true!
minimatch(&quot;bar.foo&quot;, &quot;*.bar&quot;) // false!
minimatch(&quot;bar.foo&quot;, &quot;*.+(bar|foo)&quot;, { debug: true }) // true, and noisy!</code></pre>

<h2 id="label-Features">Features</h2>

<p>Supports these glob features:</p>

<p>Brace Expansion  Extended glob matching  “Globstar” <code>**</code>
matching</p>

<p>See:</p>

<p><code>man sh</code>  <code>man bash</code>  <code>man 3 fnmatch</code> 
<code>man 5 gitignore</code></p>

<h2 id="label-Minimatch+Class">Minimatch <a href="../../../../../../../../classes/Class.html">Class</a></h2>

<p>Create a minimatch object by instanting the
<code>minimatch.Minimatch</code> class.</p>

<pre><code>var Minimatch = require(&quot;minimatch&quot;).Minimatch
var mm = new Minimatch(pattern, options)</code></pre>

<h3 id="label-Properties">Properties</h3>

<p><code>pattern</code> The original pattern the minimatch object represents. 
<code>options</code> The options supplied to the constructor. 
<code>set</code> A 2-dimensional array of regexp or string expressions. 
Each row in the  array corresponds to a brace-expanded pattern. Each item
in the row  corresponds to a single path-part. For example, the pattern 
<code>{a,b/c}/d</code> would expand to a set of patterns like:</p>

<pre><code>    [ [ a, d ]
    , [ b, c, d ] ]

If a portion of the pattern doesn&#39;t have any &quot;magic&quot; in it
(that is, it&#39;s something like `&quot;foo&quot;` rather than `fo*o?`), then it
will be left as a string rather than converted to a regular
expression.</code></pre>

<p><code>regexp</code> Created by the <code>makeRe</code> method. A single
regular expression  expressing the entire pattern. This is useful in <a
href="node_modules/brace-expansion/test/cases_txt.html">cases</a> where you
wish  to use the pattern somewhat like <code>fnmatch(3)</code> with
<code>FNM_PATH</code> enabled.  <code>negate</code> True if the pattern is
negated.  <code>comment</code> True if the pattern is a comment. 
<code>empty</code> True if the pattern is <code>&quot;&quot;</code>.</p>

<h3 id="label-Methods">Methods</h3>

<p><code>makeRe</code> Generate the <code>regexp</code> member if necessary,
and return it.  Will return <code>false</code> if the pattern is invalid. 
<code>match(fname)</code> Return true if the filename matches the pattern,
or  false otherwise.  <code>matchOne(fileArray, patternArray,
partial)</code> Take a <code>/</code>-split  filename, and match it against
a single row in the <code>regExpSet</code>. This  method is mainly for
internal use, but is exposed so that it can be  used by a glob-walker that
needs to avoid excessive filesystem calls.</p>

<p>All other methods are internal, and will be called as necessary.</p>

<h2 id="label-Functions">Functions</h2>

<p>The top-level exported function has a <code>cache</code> property, which is
an LRU cache set to store 100 items. So, calling these methods repeatedly
with the same pattern and options will use the same Minimatch object,
saving the cost of parsing it multiple times.</p>

<h3 id="label-minimatch-28path-2C+pattern-2C+options-29">minimatch(path, pattern, options)</h3>

<p>Main export. Tests a path against the pattern using the options.</p>

<pre><code>var isJS = minimatch(file, &quot;*.js&quot;, { matchBase: true })
</code></pre>

<h3 id="label-minimatch.filter-28pattern-2C+options-29">minimatch.filter(pattern, options)</h3>

<p>Returns a function that tests its supplied argument, suitable for use with
<code>Array.filter</code>. Example:</p>

<pre><code>var javascripts = fileList.filter(minimatch.filter(&quot;*.js&quot;, {matchBase: true}))
</code></pre>

<h3 id="label-minimatch.match-28list-2C+pattern-2C+options-29">minimatch.match(list, pattern, options)</h3>

<p>Match against the list of files, in the style of fnmatch or glob. If
nothing is matched, and options.nonull is set, then return a list
containing the pattern itself.</p>

<pre><code>var javascripts = minimatch.match(fileList, &quot;*.js&quot;, {matchBase: true}))</code></pre>

<h3 id="label-minimatch.makeRe-28pattern-2C+options-29">minimatch.makeRe(pattern, options)</h3>

<p>Make a regular expression object from the pattern.</p>

<h2 id="label-Options">Options</h2>

<p>All options are <code>false</code> by default.</p>

<h3 id="label-debug">debug</h3>

<p>Dump a ton of stuff to stderr.</p>

<h3 id="label-nobrace">nobrace</h3>

<p>Do not expand <code>{a,b}</code> and <code>{1..3}</code> brace sets.</p>

<h3 id="label-noglobstar">noglobstar</h3>

<p>Disable <code>**</code> matching against multiple folder names.</p>

<h3 id="label-dot">dot</h3>

<p>Allow patterns to match filenames starting with a period, even if the
pattern does not explicitly have a period in that spot.</p>

<p>Note that by default, <code>a   /b</code> will <strong>not</strong> match
<code>a/.d/b</code>, unless <code>dot</code> is set.</p>

<h3 id="label-noext">noext</h3>

<p>Disable “extglob” style patterns like <code>+(a|b)</code>.</p>

<h3 id="label-nocase">nocase</h3>

<p>Perform a case-insensitive match.</p>

<h3 id="label-nonull">nonull</h3>

<p>When a match is not found by <code>minimatch.match</code>, return a list
containing the pattern itself if this option is set. When not set, an empty
list is returned if there are no matches.</p>

<h3 id="label-matchBase">matchBase</h3>

<p>If set, then patterns without slashes will be matched against the basename
of the path if it contains slashes. For example, <code>a?b</code> would
match the path <code>/xyz/123/acb</code>, but not
<code>/xyz/acb/123</code>.</p>

<h3 id="label-nocomment">nocomment</h3>

<p>Suppress the behavior of treating <code>#</code> at the start of a pattern
as a comment.</p>

<h3 id="label-nonegate">nonegate</h3>

<p>Suppress the behavior of treating a leading <code>!</code> character as
negation.</p>

<h3 id="label-flipNegate">flipNegate</h3>

<p>Returns from negate expressions the same as if they were not negated. (Ie,
true on a hit, false on a miss.)</p>

<h2 id="label-Comparisons+to+other+fnmatch-2Fglob+implementations">Comparisons to other fnmatch/glob implementations</h2>

<p>While strict compliance with the existing standards is a worthwhile goal,
some discrepancies exist between minimatch and other implementations, and
are intentional.</p>

<p>If the pattern starts with a <code>!</code> character, then it is negated.
<a href="../../../../../../../../classes/Set.html">Set</a> the
<code>nonegate</code> flag to suppress this behavior, and treat leading
<code>!</code> characters normally. This is perhaps relevant if you wish to
start the pattern with a negative extglob pattern like <code>!(a|B)</code>.
Multiple <code>!</code> characters at the start of a pattern will negate
the pattern multiple times.</p>

<p>If a pattern starts with <code>#</code>, then it is treated as a comment,
and will not match anything. Use <code>\#</code> to match a literal
<code>#</code> at the start of a line, or set the <code>nocomment</code>
flag to suppress this behavior.</p>

<p>The double-star character <code>**</code> is supported by default, unless
the <code>noglobstar</code> flag is set. This is supported in the manner of
bsdglob and bash 4.1, where <code>**</code> only has special significance
if it is the only thing in a path part. That is, <code>a/   b</code> will
match <code>a/x/y/b</code>, but <code>a/**b</code> will not.</p>

<p>If an escaped pattern has no matches, and the <code>nonull</code> flag is
set, then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example, <code>minimatch.match([],
&quot;\*a\?&quot;)</code> will return <code>&quot;\*a\?&quot;</code> rather
than <code>&quot;*a?&quot;</code>. This is akin to setting the
<code>nullglob</code> option in bash, except that it does not resolve
escaped pattern characters.</p>

<p>If brace expansion is not disabled, then it is performed before any other
interpretation of the glob pattern. Thus, a pattern like
<code>+(a|{b),c)}</code>, which would not be valid in bash or zsh, is
expanded  <em>first</em>* into the set of <code>+(a|b)</code> and
<code>+(a|c)</code>, and those patterns are checked for validity. Since
those two are valid, matching proceeds.</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
