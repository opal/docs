<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>underscore.string.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            underscore.string.js
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/lib/underscore.string.js</li>
            <li>Last modified: 2015-08-19 03:18:33 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>//  Underscore.string //  Â© 2010 Esa-Matti Suuronen &lt;esa-matti aet
suuronen dot org&gt; //  Underscore.string is freely distributable under
the terms of the MIT license. //  Documentation: <a
href="https://github.com/epeli/underscore.string">github.com/epeli/underscore.string</a>
//  Some code is borrowed from MooTools and Alexandru Marasteanu. // 
Version &#39;2.4.0&#39;</p>

<p>!function(root, <a
href="../../../../../../../../../../../classes/String.html">String</a>){</p>

<pre><code>&#39;use strict&#39;;

// Defining helper functions.

var nativeTrim = String.prototype.trim;
var nativeTrimRight = String.prototype.trimRight;
var nativeTrimLeft = String.prototype.trimLeft;

var parseNumber = function(source) { return source * 1 || 0; };

var strRepeat = function(str, qty){
  if (qty &lt; 1) return &#39;&#39;;
  var result = &#39;&#39;;
  while (qty &gt; 0) {
    if (qty &amp; 1) result += str;
    qty &gt;&gt;= 1, str += str;
  }
  return result;
};

var slice = [].slice;

var defaultToWhiteSpace = function(characters) {
  if (characters == null)
    return &#39;\\s&#39;;
  else if (characters.source)
    return characters.source;
  else
    return &#39;[&#39; + _s.escapeRegExp(characters) + &#39;]&#39;;
};

// Helper for toBoolean
function boolMatch(s, matchers) {
  var i, matcher, down = s.toLowerCase();
  matchers = [].concat(matchers);
  for (i = 0; i &lt; matchers.length; i += 1) {
    matcher = matchers[i];
    if (!matcher) continue;
    if (matcher.test &amp;&amp; matcher.test(s)) return true;
    if (matcher.toLowerCase() === down) return true;
  }
}

var escapeChars = {
  lt: &#39;&lt;&#39;,
  gt: &#39;&gt;&#39;,
  quot: &#39;&quot;&#39;,
  amp: &#39;&amp;&#39;,
  apos: &quot;&#39;&quot;
};

var reversedEscapeChars = {};
for(var key in escapeChars) reversedEscapeChars[escapeChars[key]] = key;
reversedEscapeChars[&quot;&#39;&quot;] = &#39;#39&#39;;

// sprintf() for JavaScript 0.7-beta1
// http://www.diveintojavascript.com/projects/javascript-sprintf
//
// Copyright (c) Alexandru Marasteanu &lt;alexaholic [at) gmail (dot] com&gt;
// All rights reserved.

var sprintf = (function() {
  function get_type(variable) {
    return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
  }

  var str_repeat = strRepeat;

  var str_format = function() {
    if (!str_format.cache.hasOwnProperty(arguments[0])) {
      str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
    }
    return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
  };

  str_format.format = function(parse_tree, argv) {
    var cursor = 1, tree_length = parse_tree.length, node_type = &#39;&#39;, arg, output = [], i, k, match, pad, pad_character, pad_length;
    for (i = 0; i &lt; tree_length; i++) {
      node_type = get_type(parse_tree[i]);
      if (node_type === &#39;string&#39;) {
        output.push(parse_tree[i]);
      }
      else if (node_type === &#39;array&#39;) {
        match = parse_tree[i]; // convenience purposes only
        if (match[2]) { // keyword argument
          arg = argv[cursor];
          for (k = 0; k &lt; match[2].length; k++) {
            if (!arg.hasOwnProperty(match[2][k])) {
              throw new Error(sprintf(&#39;[_.sprintf] property &quot;%s&quot; does not exist&#39;, match[2][k]));
            }
            arg = arg[match[2][k]];
          }
        } else if (match[1]) { // positional argument (explicit)
          arg = argv[match[1]];
        }
        else { // positional argument (implicit)
          arg = argv[cursor++];
        }

        if (/[^s]/.test(match[8]) &amp;&amp; (get_type(arg) != &#39;number&#39;)) {
          throw new Error(sprintf(&#39;[_.sprintf] expecting number but found %s&#39;, get_type(arg)));
        }
        switch (match[8]) {
          case &#39;b&#39;: arg = arg.toString(2); break;
          case &#39;c&#39;: arg = String.fromCharCode(arg); break;
          case &#39;d&#39;: arg = parseInt(arg, 10); break;
          case &#39;e&#39;: arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
          case &#39;f&#39;: arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
          case &#39;o&#39;: arg = arg.toString(8); break;
          case &#39;s&#39;: arg = ((arg = String(arg)) &amp;&amp; match[7] ? arg.substring(0, match[7]) : arg); break;
          case &#39;u&#39;: arg = Math.abs(arg); break;
          case &#39;x&#39;: arg = arg.toString(16); break;
          case &#39;X&#39;: arg = arg.toString(16).toUpperCase(); break;
        }
        arg = (/[def]/.test(match[8]) &amp;&amp; match[3] &amp;&amp; arg &gt;= 0 ? &#39;+&#39;+ arg : arg);
        pad_character = match[4] ? match[4] == &#39;0&#39; ? &#39;0&#39; : match[4].charAt(1) : &#39; &#39;;
        pad_length = match[6] - String(arg).length;
        pad = match[6] ? str_repeat(pad_character, pad_length) : &#39;&#39;;
        output.push(match[5] ? arg + pad : pad + arg);
      }
    }
    return output.join(&#39;&#39;);
  };

  str_format.cache = {};

  str_format.parse = function(fmt) {
    var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
    while (_fmt) {
      if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
        parse_tree.push(match[0]);
      }
      else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
        parse_tree.push(&#39;%&#39;);
      }
      else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|&#39;[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
        if (match[2]) {
          arg_names |= 1;
          var field_list = [], replacement_field = match[2], field_match = [];
          if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
            field_list.push(field_match[1]);
            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== &#39;&#39;) {
              if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
              }
              else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
              }
              else {
                throw new Error(&#39;[_.sprintf] huh?&#39;);
              }
            }
          }
          else {
            throw new Error(&#39;[_.sprintf] huh?&#39;);
          }
          match[2] = field_list;
        }
        else {
          arg_names |= 2;
        }
        if (arg_names === 3) {
          throw new Error(&#39;[_.sprintf] mixing positional and named placeholders is not (yet) supported&#39;);
        }
        parse_tree.push(match);
      }
      else {
        throw new Error(&#39;[_.sprintf] huh?&#39;);
      }
      _fmt = _fmt.substring(match[0].length);
    }
    return parse_tree;
  };

  return str_format;
})();

// Defining underscore.string

var _s = {

  VERSION: &#39;2.4.0&#39;,

  isBlank: function(str){
    if (str == null) str = &#39;&#39;;
    return (/^\s*$/).test(str);
  },

  stripTags: function(str){
    if (str == null) return &#39;&#39;;
    return String(str).replace(/&lt;\/?[^&gt;]+&gt;/g, &#39;&#39;);
  },

  capitalize : function(str){
    str = str == null ? &#39;&#39; : String(str);
    return str.charAt(0).toUpperCase() + str.slice(1);
  },

  chop: function(str, step){
    if (str == null) return [];
    str = String(str);
    step = ~~step;
    return step &gt; 0 ? str.match(new RegExp(&#39;.{1,&#39; + step + &#39;}&#39;, &#39;g&#39;)) : [str];
  },

  clean: function(str){
    return _s.strip(str).replace(/\s+/g, &#39; &#39;);
  },

  count: function(str, substr){
    if (str == null || substr == null) return 0;

    str = String(str);
    substr = String(substr);

    var count = 0,
      pos = 0,
      length = substr.length;

    while (true) {
      pos = str.indexOf(substr, pos);
      if (pos === -1) break;
      count++;
      pos += length;
    }

    return count;
  },

  chars: function(str) {
    if (str == null) return [];
    return String(str).split(&#39;&#39;);
  },

  swapCase: function(str) {
    if (str == null) return &#39;&#39;;
    return String(str).replace(/\S/g, function(c){
      return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
    });
  },

  escapeHTML: function(str) {
    if (str == null) return &#39;&#39;;
    return String(str).replace(/[&amp;&lt;&gt;&quot;&#39;]/g, function(m){ return &#39;&amp;&#39; + reversedEscapeChars[m] + &#39;;&#39;; });
  },

  unescapeHTML: function(str) {
    if (str == null) return &#39;&#39;;
    return String(str).replace(/\&amp;([^;]+);/g, function(entity, entityCode){
      var match;

      if (entityCode in escapeChars) {
        return escapeChars[entityCode];
      } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
        return String.fromCharCode(parseInt(match[1], 16));
      } else if (match = entityCode.match(/^#(\d+)$/)) {
        return String.fromCharCode(~~match[1]);
      } else {
        return entity;
      }
    });
  },

  escapeRegExp: function(str){
    if (str == null) return &#39;&#39;;
    return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, &#39;\\$1&#39;);
  },

  splice: function(str, i, howmany, substr){
    var arr = _s.chars(str);
    arr.splice(~~i, ~~howmany, substr);
    return arr.join(&#39;&#39;);
  },

  insert: function(str, i, substr){
    return _s.splice(str, i, 0, substr);
  },

  include: function(str, needle){
    if (needle === &#39;&#39;) return true;
    if (str == null) return false;
    return String(str).indexOf(needle) !== -1;
  },

  join: function() {
    var args = slice.call(arguments),
      separator = args.shift();

    if (separator == null) separator = &#39;&#39;;

    return args.join(separator);
  },

  lines: function(str) {
    if (str == null) return [];
    return String(str).split(&quot;\n&quot;);
  },

  reverse: function(str){
    return _s.chars(str).reverse().join(&#39;&#39;);
  },

  startsWith: function(str, starts){
    if (starts === &#39;&#39;) return true;
    if (str == null || starts == null) return false;
    str = String(str); starts = String(starts);
    return str.length &gt;= starts.length &amp;&amp; str.slice(0, starts.length) === starts;
  },

  endsWith: function(str, ends){
    if (ends === &#39;&#39;) return true;
    if (str == null || ends == null) return false;
    str = String(str); ends = String(ends);
    return str.length &gt;= ends.length &amp;&amp; str.slice(str.length - ends.length) === ends;
  },

  succ: function(str){
    if (str == null) return &#39;&#39;;
    str = String(str);
    return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length-1) + 1);
  },

  titleize: function(str){
    if (str == null) return &#39;&#39;;
    str  = String(str).toLowerCase();
    return str.replace(/(?:^|\s|-)\S/g, function(c){ return c.toUpperCase(); });
  },

  camelize: function(str){
    return _s.trim(str).replace(/[-_\s]+(.)?/g, function(match, c){ return c ? c.toUpperCase() : &quot;&quot;; });
  },

  underscored: function(str){
    return _s.trim(str).replace(/([a-z\d])([A-Z]+)/g, &#39;$1_$2&#39;).replace(/[-\s]+/g, &#39;_&#39;).toLowerCase();
  },

  dasherize: function(str){
    return _s.trim(str).replace(/([A-Z])/g, &#39;-$1&#39;).replace(/[-_\s]+/g, &#39;-&#39;).toLowerCase();
  },

  classify: function(str){
    return _s.capitalize(_s.camelize(String(str).replace(/[\W_]/g, &#39; &#39;)).replace(/\s/g, &#39;&#39;));
  },

  humanize: function(str){
    return _s.capitalize(_s.underscored(str).replace(/_id$/,&#39;&#39;).replace(/_/g, &#39; &#39;));
  },

  trim: function(str, characters){
    if (str == null) return &#39;&#39;;
    if (!characters &amp;&amp; nativeTrim) return nativeTrim.call(str);
    characters = defaultToWhiteSpace(characters);
    return String(str).replace(new RegExp(&#39;^&#39; + characters + &#39;+|&#39; + characters + &#39;+$&#39;, &#39;g&#39;), &#39;&#39;);
  },

  ltrim: function(str, characters){
    if (str == null) return &#39;&#39;;
    if (!characters &amp;&amp; nativeTrimLeft) return nativeTrimLeft.call(str);
    characters = defaultToWhiteSpace(characters);
    return String(str).replace(new RegExp(&#39;^&#39; + characters + &#39;+&#39;), &#39;&#39;);
  },

  rtrim: function(str, characters){
    if (str == null) return &#39;&#39;;
    if (!characters &amp;&amp; nativeTrimRight) return nativeTrimRight.call(str);
    characters = defaultToWhiteSpace(characters);
    return String(str).replace(new RegExp(characters + &#39;+$&#39;), &#39;&#39;);
  },

  truncate: function(str, length, truncateStr){
    if (str == null) return &#39;&#39;;
    str = String(str); truncateStr = truncateStr || &#39;...&#39;;
    length = ~~length;
    return str.length &gt; length ? str.slice(0, length) + truncateStr : str;
  },

     _s.prune: a more elegant version of truncate
     prune extra chars, never leaving a half-chopped word.
     @author github.com/rwz

  prune: function(str, length, pruneStr){
    if (str == null) return &#39;&#39;;

    str = String(str); length = ~~length;
    pruneStr = pruneStr != null ? String(pruneStr) : &#39;...&#39;;

    if (str.length &lt;= length) return str;

    var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? &#39;A&#39; : &#39; &#39;; },
      template = str.slice(0, length+1).replace(/.(?=\W*\w*$)/g, tmpl); // &#39;Hello, world&#39; -&gt; &#39;HellAA AAAAA&#39;

    if (template.slice(template.length-2).match(/\w\w/))
      template = template.replace(/\s*\S+$/, &#39;&#39;);
    else
      template = _s.rtrim(template.slice(0, template.length-1));

    return (template+pruneStr).length &gt; str.length ? str : str.slice(0, template.length)+pruneStr;
  },

  words: function(str, delimiter) {
    if (_s.isBlank(str)) return [];
    return _s.trim(str, delimiter).split(delimiter || /\s+/);
  },

  pad: function(str, length, padStr, type) {
    str = str == null ? &#39;&#39; : String(str);
    length = ~~length;

    var padlen  = 0;

    if (!padStr)
      padStr = &#39; &#39;;
    else if (padStr.length &gt; 1)
      padStr = padStr.charAt(0);

    switch(type) {
      case &#39;right&#39;:
        padlen = length - str.length;
        return str + strRepeat(padStr, padlen);
      case &#39;both&#39;:
        padlen = length - str.length;
        return strRepeat(padStr, Math.ceil(padlen/2)) + str
                + strRepeat(padStr, Math.floor(padlen/2));
      default: // &#39;left&#39;
        padlen = length - str.length;
        return strRepeat(padStr, padlen) + str;
      }
  },

  lpad: function(str, length, padStr) {
    return _s.pad(str, length, padStr);
  },

  rpad: function(str, length, padStr) {
    return _s.pad(str, length, padStr, &#39;right&#39;);
  },

  lrpad: function(str, length, padStr) {
    return _s.pad(str, length, padStr, &#39;both&#39;);
  },

  sprintf: sprintf,

  vsprintf: function(fmt, argv){
    argv.unshift(fmt);
    return sprintf.apply(null, argv);
  },

  toNumber: function(str, decimals) {
    if (!str) return 0;
    str = _s.trim(str);
    if (!str.match(/^-?\d+(?:\.\d+)?$/)) return NaN;
    return parseNumber(parseNumber(str).toFixed(~~decimals));
  },

  numberFormat : function(number, dec, dsep, tsep) {
    if (isNaN(number) || number == null) return &#39;&#39;;

    number = number.toFixed(~~dec);
    tsep = typeof tsep == &#39;string&#39; ? tsep : &#39;,&#39;;

    var parts = number.split(&#39;.&#39;), fnums = parts[0],
      decimals = parts[1] ? (dsep || &#39;.&#39;) + parts[1] : &#39;&#39;;

    return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, &#39;$1&#39; + tsep) + decimals;
  },

  strRight: function(str, sep){
    if (str == null) return &#39;&#39;;
    str = String(str); sep = sep != null ? String(sep) : sep;
    var pos = !sep ? -1 : str.indexOf(sep);
    return ~pos ? str.slice(pos+sep.length, str.length) : str;
  },

  strRightBack: function(str, sep){
    if (str == null) return &#39;&#39;;
    str = String(str); sep = sep != null ? String(sep) : sep;
    var pos = !sep ? -1 : str.lastIndexOf(sep);
    return ~pos ? str.slice(pos+sep.length, str.length) : str;
  },

  strLeft: function(str, sep){
    if (str == null) return &#39;&#39;;
    str = String(str); sep = sep != null ? String(sep) : sep;
    var pos = !sep ? -1 : str.indexOf(sep);
    return ~pos ? str.slice(0, pos) : str;
  },

  strLeftBack: function(str, sep){
    if (str == null) return &#39;&#39;;
    str += &#39;&#39;; sep = sep != null ? &#39;&#39;+sep : sep;
    var pos = str.lastIndexOf(sep);
    return ~pos ? str.slice(0, pos) : str;
  },

  toSentence: function(array, separator, lastSeparator, serial) {
    separator = separator || &#39;, &#39;;
    lastSeparator = lastSeparator || &#39; and &#39;;
    var a = array.slice(), lastMember = a.pop();

    if (array.length &gt; 2 &amp;&amp; serial) lastSeparator = _s.rtrim(separator) + lastSeparator;

    return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
  },

  toSentenceSerial: function() {
    var args = slice.call(arguments);
    args[3] = true;
    return _s.toSentence.apply(_s, args);
  },

  slugify: function(str) {
    if (str == null) return &#39;&#39;;

    var from  = &quot;ÄÃ Ã¡Ã¤Ã¢Ã£Ã¥Ã¦ÄÄÄÃ¨Ã©Ã«ÃªÃ¬Ã­Ã¯Ã®ÅÅÃ²Ã³Ã¶Ã´ÃµÃ¸ÅÈÈÃ¹ÃºÃ¼Ã»Ã±Ã§Å¼Åº&quot;,
        to    = &quot;aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz&quot;,
        regex = new RegExp(defaultToWhiteSpace(from), &#39;g&#39;);

    str = String(str).toLowerCase().replace(regex, function(c){
      var index = from.indexOf(c);
      return to.charAt(index) || &#39;-&#39;;
    });

    return _s.dasherize(str.replace(/[^\w\s-]/g, &#39;&#39;));
  },

  surround: function(str, wrapper) {
    return [wrapper, str, wrapper].join(&#39;&#39;);
  },

  quote: function(str, quoteChar) {
    return _s.surround(str, quoteChar || &#39;&quot;&#39;);
  },

  unquote: function(str, quoteChar) {
    quoteChar = quoteChar || &#39;&quot;&#39;;
    if (str[0] === quoteChar &amp;&amp; str[str.length-1] === quoteChar)
      return str.slice(1,str.length-1);
    else return str;
  },

  exports: function() {
    var result = {};

    for (var prop in this) {
      if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue;
      result[prop] = this[prop];
    }

    return result;
  },

  repeat: function(str, qty, separator){
    if (str == null) return &#39;&#39;;

    qty = ~~qty;

    // using faster implementation if separator is not needed;
    if (separator == null) return strRepeat(String(str), qty);

    // this one is about 300x slower in Google Chrome
    for (var repeat = []; qty &gt; 0; repeat[--qty] = str) {}
    return repeat.join(separator);
  },

  naturalCmp: function(str1, str2){
    if (str1 == str2) return 0;
    if (!str1) return -1;
    if (!str2) return 1;

    var cmpRegex = /(\.\d+)|(\d+)|(\D+)/g,
      tokens1 = String(str1).toLowerCase().match(cmpRegex),
      tokens2 = String(str2).toLowerCase().match(cmpRegex),
      count = Math.min(tokens1.length, tokens2.length);

    for(var i = 0; i &lt; count; i++) {
      var a = tokens1[i], b = tokens2[i];

      if (a !== b){
        var num1 = parseInt(a, 10);
        if (!isNaN(num1)){
          var num2 = parseInt(b, 10);
          if (!isNaN(num2) &amp;&amp; num1 - num2)
            return num1 - num2;
        }
        return a &lt; b ? -1 : 1;
      }
    }

    if (tokens1.length === tokens2.length)
      return tokens1.length - tokens2.length;

    return str1 &lt; str2 ? -1 : 1;
  },

  levenshtein: function(str1, str2) {
    if (str1 == null &amp;&amp; str2 == null) return 0;
    if (str1 == null) return String(str2).length;
    if (str2 == null) return String(str1).length;

    str1 = String(str1); str2 = String(str2);

    var current = [], prev, value;

    for (var i = 0; i &lt;= str2.length; i++)
      for (var j = 0; j &lt;= str1.length; j++) {
        if (i &amp;&amp; j)
          if (str1.charAt(j - 1) === str2.charAt(i - 1))
            value = prev;
          else
            value = Math.min(current[j], current[j - 1], prev) + 1;
        else
          value = i + j;

        prev = current[j];
        current[j] = value;
      }

    return current.pop();
  },

  toBoolean: function(str, trueValues, falseValues) {
    if (typeof str === &quot;number&quot;) str = &quot;&quot; + str;
    if (typeof str !== &quot;string&quot;) return !!str;
    str = _s.trim(str);
    if (boolMatch(str, trueValues || [&quot;true&quot;, &quot;1&quot;])) return true;
    if (boolMatch(str, falseValues || [&quot;false&quot;, &quot;0&quot;])) return false;
  }
};

// Aliases

_s.strip    = _s.trim;
_s.lstrip   = _s.ltrim;
_s.rstrip   = _s.rtrim;
_s.center   = _s.lrpad;
_s.rjust    = _s.lpad;
_s.ljust    = _s.rpad;
_s.contains = _s.include;
_s.q        = _s.quote;
_s.toBool   = _s.toBoolean;

// Exporting

// CommonJS module is defined
if (typeof exports !== &#39;undefined&#39;) {
  if (typeof module !== &#39;undefined&#39; &amp;&amp; module.exports)
    module.exports = _s;

  exports._s = _s;
}

// Register as a named module with AMD.
if (typeof define === &#39;function&#39; &amp;&amp; define.amd)
  define(&#39;underscore.string&#39;, [], function(){ return _s; });

// Integrate with Underscore.js if defined
// or create our own underscore object.
root._ = root._ || {};
root._.string = root._.str = _s;</code></pre>

<p>}(this, <a
href="../../../../../../../../../../../classes/String.html">String</a>);</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
