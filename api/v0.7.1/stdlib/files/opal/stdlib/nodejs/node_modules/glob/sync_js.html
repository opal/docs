<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>sync.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            sync.js
        </h1>
        <ul class="files">
            <li>opal/stdlib/nodejs/node_modules/glob/sync.js</li>
            <li>Last modified: 2015-08-19 03:18:33 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>module.exports = globSync globSync.GlobSync = GlobSync</p>

<p>var fs = require(&#39;fs&#39;) var minimatch = require(&#39;minimatch&#39;)
var Minimatch = minimatch.Minimatch var Glob =
require(&#39;./glob.js&#39;).Glob var util = require(&#39;util&#39;) var
path = require(&#39;path&#39;) var assert = require(&#39;assert&#39;) var
common = require(&#39;./common.js&#39;) var alphasort = common.alphasort
var alphasorti = common.alphasorti var isAbsolute = common.isAbsolute var
setopts = common.setopts var ownProp = common.ownProp</p>

<p>function globSync (pattern, options) {</p>

<pre><code>if (typeof options === &#39;function&#39; || arguments.length === 3)
  throw new TypeError(&#39;callback provided to sync glob&#39;)

return new GlobSync(pattern, options).found</code></pre>

<p>}</p>

<p>function GlobSync (pattern, options) {</p>

<pre><code>if (!pattern)
  throw new Error(&#39;must provide pattern&#39;)

if (typeof options === &#39;function&#39; || arguments.length === 3)
  throw new TypeError(&#39;callback provided to sync glob&#39;)

if (!(this instanceof GlobSync))
  return new GlobSync(pattern, options)

setopts(this, pattern, options)

if (this.noprocess)
  return this

var n = this.minimatch.set.length
this.matches = new Array(n)
for (var i = 0; i &lt; n; i ++) {
  this._process(this.minimatch.set[i], i, false)
}
this._finish()</code></pre>

<p>}</p>

<p>GlobSync.prototype._finish = function () {</p>

<pre><code>assert(this instanceof GlobSync)
common.finish(this)
</code></pre>

<p>}</p>

<p>GlobSync.prototype._process = function (pattern, index, inGlobStar) {</p>

<pre><code>assert(this instanceof GlobSync)

// Get the first [n] parts of pattern that are all strings.
var n = 0
while (typeof pattern[n] === &#39;string&#39;) {
  n ++
}
// now n is the index of the first one that is *not* a string.

// See if there&#39;s anything else
var prefix
switch (n) {
  // if not, then this is rather simple
  case pattern.length:
    this._processSimple(pattern.join(&#39;/&#39;), index)
    return

  case 0:
    // pattern *starts* with some non-trivial item.
    // going to readdir(cwd), but not include the prefix in matches.
    prefix = null
    break

  default:
    // pattern has some string bits in the front.
    // whatever it starts with, whether that&#39;s &#39;absolute&#39; like /foo/bar,
    // or &#39;relative&#39; like &#39;../baz&#39;
    prefix = pattern.slice(0, n).join(&#39;/&#39;)
    break
}

var remain = pattern.slice(n)

// get the list of entries.
var read
if (prefix === null)
  read = &#39;.&#39;
else if (isAbsolute(prefix) || isAbsolute(pattern.join(&#39;/&#39;))) {
  if (!prefix || !isAbsolute(prefix))
    prefix = &#39;/&#39; + prefix
  read = prefix
} else
  read = prefix

var abs = this._makeAbs(read)

var isGlobStar = remain[0] === minimatch.GLOBSTAR
if (isGlobStar)
  this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
else
  this._processReaddir(prefix, read, abs, remain, index, inGlobStar)</code></pre>

<p>}</p>

<p>GlobSync.prototype._processReaddir = function (prefix, read, abs, remain,
index, inGlobStar) {</p>

<pre><code>var entries = this._readdir(abs, inGlobStar)

// if the abs isn&#39;t a dir, then nothing can match!
if (!entries)
  return

// It will only match dot entries if it starts with a dot, or if
// dot is set.  Stuff like @(.foo|.bar) isn&#39;t allowed.
var pn = remain[0]
var negate = !!this.minimatch.negate
var rawGlob = pn._glob
var dotOk = this.dot || rawGlob.charAt(0) === &#39;.&#39;

var matchedEntries = []
for (var i = 0; i &lt; entries.length; i++) {
  var e = entries[i]
  if (e.charAt(0) !== &#39;.&#39; || dotOk) {
    var m
    if (negate &amp;&amp; !prefix) {
      m = !e.match(pn)
    } else {
      m = e.match(pn)
    }
    if (m)
      matchedEntries.push(e)
  }
}

var len = matchedEntries.length
// If there are no matched entries, then nothing matches.
if (len === 0)
  return

// if this is the last remaining pattern bit, then no need for
// an additional stat *unless* the user has specified mark or
// stat explicitly.  We know they exist, since readdir returned
// them.

if (remain.length === 1 &amp;&amp; !this.mark &amp;&amp; !this.stat) {
  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  for (var i = 0; i &lt; len; i ++) {
    var e = matchedEntries[i]
    if (prefix) {
      if (prefix.slice(-1) !== &#39;/&#39;)
        e = prefix + &#39;/&#39; + e
      else
        e = prefix + e
    }

    if (e.charAt(0) === &#39;/&#39; &amp;&amp; !this.nomount) {
      e = path.join(this.root, e)
    }
    this.matches[index][e] = true
  }
  // This was the last one, and no stats were needed
  return
}

// now test all matched entries as stand-ins for that part
// of the pattern.
remain.shift()
for (var i = 0; i &lt; len; i ++) {
  var e = matchedEntries[i]
  var newPattern
  if (prefix)
    newPattern = [prefix, e]
  else
    newPattern = [e]
  this._process(newPattern.concat(remain), index, inGlobStar)
}</code></pre>

<p>}</p>

<p>GlobSync.prototype._emitMatch = function (index, e) {</p>

<pre><code>if (!this.matches[index][e]) {
  if (this.nodir) {
    var c = this.cache[this._makeAbs(e)]
    if (c === &#39;DIR&#39; || Array.isArray(c))
      return
  }

  this.matches[index][e] = true
  if (this.stat || this.mark)
    this._stat(this._makeAbs(e))
}</code></pre>

<p>}</p>

<p>GlobSync.prototype._readdirInGlobStar = function (abs) {</p>

<pre><code>var entries
var lstat
var stat
try {
  lstat = fs.lstatSync(abs)
} catch (er) {
  // lstat failed, doesn&#39;t exist
  return null
}

var isSym = lstat.isSymbolicLink()
this.symlinks[abs] = isSym

// If it&#39;s not a symlink or a dir, then it&#39;s definitely a regular file.
// don&#39;t bother doing a readdir in that case.
if (!isSym &amp;&amp; !lstat.isDirectory())
  this.cache[abs] = &#39;FILE&#39;
else
  entries = this._readdir(abs, false)

return entries</code></pre>

<p>}</p>

<p>GlobSync.prototype._readdir = function (abs, inGlobStar) {</p>

<pre><code>var entries

if (inGlobStar &amp;&amp; !ownProp(this.symlinks, abs))
  return this._readdirInGlobStar(abs)

if (ownProp(this.cache, abs)) {
  var c = this.cache[abs]
  if (!c || c === &#39;FILE&#39;)
    return null

  if (Array.isArray(c))
    return c
}

try {
  return this._readdirEntries(abs, fs.readdirSync(abs))
} catch (er) {
  this._readdirError(abs, er)
  return null
}</code></pre>

<p>}</p>

<p>GlobSync.prototype._readdirEntries = function (abs, entries) {</p>

<pre><code>// if we haven&#39;t asked to stat everything, then just
// assume that everything in there exists, so we can avoid
// having to stat it a second time.
if (!this.mark &amp;&amp; !this.stat) {
  for (var i = 0; i &lt; entries.length; i ++) {
    var e = entries[i]
    if (abs === &#39;/&#39;)
      e = abs + e
    else
      e = abs + &#39;/&#39; + e
    this.cache[e] = true
  }
}

this.cache[abs] = entries

// mark and cache dir-ness
return entries</code></pre>

<p>}</p>

<p>GlobSync.prototype._readdirError = function (f, er) {</p>

<pre><code>// handle errors, and cache the information
switch (er.code) {
  case &#39;ENOTDIR&#39;: // totally normal. means it *does* exist.
    this.cache[f] = &#39;FILE&#39;
    break

  case &#39;ENOENT&#39;: // not terribly unusual
  case &#39;ELOOP&#39;:
  case &#39;ENAMETOOLONG&#39;:
  case &#39;UNKNOWN&#39;:
    this.cache[f] = false
    break

  default: // some unusual error.  Treat as failure.
    this.cache[f] = false
    if (this.strict) throw er
    if (!this.silent) console.error(&#39;glob error&#39;, er)
    break
}</code></pre>

<p>}</p>

<p>GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain,
index, inGlobStar) {</p>

<pre><code>var entries = this._readdir(abs, inGlobStar)

// no entries means not a dir, so it can never have matches
// foo.txt/** doesn&#39;t match foo.txt
if (!entries)
  return

// test without the globstar, and with every child both below
// and replacing the globstar.
var remainWithoutGlobStar = remain.slice(1)
var gspref = prefix ? [ prefix ] : []
var noGlobStar = gspref.concat(remainWithoutGlobStar)

// the noGlobStar pattern exits the inGlobStar state
this._process(noGlobStar, index, false)

var len = entries.length
var isSym = this.symlinks[abs]

// If it&#39;s a symlink, and we&#39;re in a globstar, then stop
if (isSym &amp;&amp; inGlobStar)
  return

for (var i = 0; i &lt; len; i++) {
  var e = entries[i]
  if (e.charAt(0) === &#39;.&#39; &amp;&amp; !this.dot)
    continue

  // these two cases enter the inGlobStar state
  var instead = gspref.concat(entries[i], remainWithoutGlobStar)
  this._process(instead, index, true)

  var below = gspref.concat(entries[i], remain)
  this._process(below, index, true)
}</code></pre>

<p>}</p>

<p>GlobSync.prototype._processSimple = function (prefix, index) {</p>

<pre><code>// XXX review this.  Shouldn&#39;t it be doing the mounting etc
// before doing stat?  kinda weird?
var exists = this._stat(prefix)

if (!this.matches[index])
  this.matches[index] = Object.create(null)

// If it doesn&#39;t exist, then just mark the lack of results
if (!exists)
  return

if (prefix &amp;&amp; isAbsolute(prefix) &amp;&amp; !this.nomount) {
  var trail = /[\/\\]$/.test(prefix)
  if (prefix.charAt(0) === &#39;/&#39;) {
    prefix = path.join(this.root, prefix)
  } else {
    prefix = path.resolve(this.root, prefix)
    if (trail)
      prefix += &#39;/&#39;
  }
}

if (process.platform === &#39;win32&#39;)
  prefix = prefix.replace(/\\/g, &#39;/&#39;)

// Mark this as a match
this.matches[index][prefix] = true</code></pre>

<p>}</p>

<p>// Returns either &#39;DIR&#39;, &#39;FILE&#39;, or false
GlobSync.prototype._stat = function (f) {</p>

<pre><code>var abs = f
if (f.charAt(0) === &#39;/&#39;)
  abs = path.join(this.root, f)
else if (this.changedCwd)
  abs = path.resolve(this.cwd, f)

if (f.length &gt; this.maxLength)
  return false

if (!this.stat &amp;&amp; ownProp(this.cache, f)) {
  var c = this.cache[f]

  if (Array.isArray(c))
    c = &#39;DIR&#39;

  // It exists, but not how we need it
  if (abs.slice(-1) === &#39;/&#39; &amp;&amp; c !== &#39;DIR&#39;)
    return false

  return c
}

var exists
var stat = this.statCache[abs]
if (!stat) {
  try {
    stat = fs.statSync(abs)
  } catch (er) {
    return false
  }
}

this.statCache[abs] = stat

if (abs.slice(-1) === &#39;/&#39; &amp;&amp; !stat.isDirectory())
  return false

var c = stat.isDirectory() ? &#39;DIR&#39; : &#39;FILE&#39;
this.cache[f] = this.cache[f] || c
return c</code></pre>

<p>}</p>

<p>GlobSync.prototype._mark = function (p) {</p>

<pre><code>return common.mark(this, p)
</code></pre>

<p>}</p>

<p>GlobSync.prototype._makeAbs = function (f) {</p>

<pre><code>return common.makeAbs(this, f)
</code></pre>

<p>}</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
